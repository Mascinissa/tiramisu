
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}
 vars i00 i01 i02  interchange : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L1
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02 < 1024 | 0
			comp01
Evaluation : 2.468110

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 vars i00 i01 i02  interchange : i00 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      for (c5, 0, 3) {
        buf01[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = ((((((((buf00[((c1 + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))] + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L2
0- for 0 <= i02 < 1024 | 0
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i00 < 3 | 0
			comp01
Evaluation : 54.640099

{ comp01[t5, t6, t7] -> comp01[0, t17 = 0, i02 = t7, t18 = 0, i01 = t6, t19 = 0, i00 = t5, t20 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 vars i00 i01 i02  interchange : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c3 + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L1  L2
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02 < 1024 | 0
		2- for 0 <= i01 < 1024 | 0
			comp01
Evaluation : 48.905102

{ comp01[t5, t6, t7] -> comp01[0, t26 = 0, i00 = t5, t27 = 0, i02 = t7, t28 = 0, i01 = t6, t29 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
2.468110+54.640099+48.905102+2.434970+
remaining list
2.434970+2.468110+48.905102+54.640099+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Parallelize L0
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02 < 1024 | 0
			comp01
Evaluation : 2.135990

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Parallelize L1
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0 | P
		2- for 0 <= i02 < 1024 | 0
			comp01
Evaluation : 2.250190

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      parallel (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Parallelize L2
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02 < 1024 | 0 | P
			comp01
Evaluation : 384.018005

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
2.135990+2.250190+384.018005+2.434970+
remaining list
2.135990+2.250190+2.434970+384.018005+ Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 2.813820

{ comp01[t5, t6, t7] -> comp01[0, t53 = 0, i00 = t5, t55 = 0, i01_outer, t57 = 0, i02_outer, t59 = 0, i01_inner, t50 = 0, i02_inner, t61 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 2.729180

{ comp01[t5, t6, t7] -> comp01[0, t105 = 0, i00 = t5, t107 = 0, i01_outer, t109 = 0, i02_outer, t111 = 0, i01_inner, t102 = 0, i02_inner, t113 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 2.619980

{ comp01[t5, t6, t7] -> comp01[0, t157 = 0, i00 = t5, t159 = 0, i01_outer, t161 = 0, i02_outer, t163 = 0, i01_inner, t154 = 0, i02_inner, t165 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 2.729890

{ comp01[t5, t6, t7] -> comp01[0, t209 = 0, i00 = t5, t211 = 0, i01_outer, t213 = 0, i02_outer, t215 = 0, i01_inner, t206 = 0, i02_inner, t217 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 3.310920

{ comp01[t5, t6, t7] -> comp01[0, t261 = 0, i00 = t5, t263 = 0, i01_outer, t265 = 0, i02_outer, t267 = 0, i01_inner, t258 = 0, i02_inner, t269 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 2.681970

{ comp01[t5, t6, t7] -> comp01[0, t313 = 0, i00 = t5, t315 = 0, i01_outer, t317 = 0, i02_outer, t319 = 0, i01_inner, t310 = 0, i02_inner, t321 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 2.787110

{ comp01[t5, t6, t7] -> comp01[0, t365 = 0, i00 = t5, t367 = 0, i01_outer, t369 = 0, i02_outer, t371 = 0, i01_inner, t362 = 0, i02_inner, t373 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 2.840040

{ comp01[t5, t6, t7] -> comp01[0, t417 = 0, i00 = t5, t419 = 0, i01_outer, t421 = 0, i02_outer, t423 = 0, i01_inner, t414 = 0, i02_inner, t425 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 2.568010

{ comp01[t5, t6, t7] -> comp01[0, t469 = 0, i00 = t5, t471 = 0, i01_outer, t473 = 0, i02_outer, t475 = 0, i01_inner, t466 = 0, i02_inner, t477 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
2.813820+2.729180+2.619980+2.729890+3.310920+2.681970+2.787110+2.840040+2.568010+2.135990+
remaining list
2.135990+2.568010+2.619980+2.681970+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L2 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02_outer < 256 | 0
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 4.014970

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L2 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02_outer < 128 | 0
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 5.067110

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L2 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02_outer < 64 | 0
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 2.422090

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 6.541970

{ comp01[t5, t6, t7] -> comp01[0, t469 = 0, i00 = t5, t471 = 0, i01_outer, t473 = 0, i02_outer, t475 = 0, i01_inner, t466 = 0, i02_inner, t477 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 3.856900

{ comp01[t5, t6, t7] -> comp01[0, t469 = 0, i00 = t5, t471 = 0, i01_outer, t473 = 0, i02_outer, t475 = 0, i01_inner, t466 = 0, i02_inner, t477 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 3.316160

{ comp01[t5, t6, t7] -> comp01[0, t469 = 0, i00 = t5, t471 = 0, i01_outer, t473 = 0, i02_outer, t475 = 0, i01_inner, t466 = 0, i02_inner, t477 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 3.848080

{ comp01[t5, t6, t7] -> comp01[0, t157 = 0, i00 = t5, t159 = 0, i01_outer, t161 = 0, i02_outer, t163 = 0, i01_inner, t154 = 0, i02_inner, t165 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 3.782030

{ comp01[t5, t6, t7] -> comp01[0, t157 = 0, i00 = t5, t159 = 0, i01_outer, t161 = 0, i02_outer, t163 = 0, i01_inner, t154 = 0, i02_inner, t165 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 3.254890

{ comp01[t5, t6, t7] -> comp01[0, t157 = 0, i00 = t5, t159 = 0, i01_outer, t161 = 0, i02_outer, t163 = 0, i01_inner, t154 = 0, i02_inner, t165 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 5.170110

{ comp01[t5, t6, t7] -> comp01[0, t313 = 0, i00 = t5, t315 = 0, i01_outer, t317 = 0, i02_outer, t319 = 0, i01_inner, t310 = 0, i02_inner, t321 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 3.658060

{ comp01[t5, t6, t7] -> comp01[0, t313 = 0, i00 = t5, t315 = 0, i01_outer, t317 = 0, i02_outer, t319 = 0, i01_inner, t310 = 0, i02_inner, t321 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 3.275160

{ comp01[t5, t6, t7] -> comp01[0, t313 = 0, i00 = t5, t315 = 0, i01_outer, t317 = 0, i02_outer, t319 = 0, i01_inner, t310 = 0, i02_inner, t321 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 2.708910

{ comp01[t5, t6, t7] -> comp01[0, t1004 = 0, i00 = t5, t1006 = 0, i01_outer, t1008 = 0, i02_outer, t1010 = 0, i01_inner, t1001 = 0, i02_inner, t1012 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 2.677920

{ comp01[t5, t6, t7] -> comp01[0, t1056 = 0, i00 = t5, t1058 = 0, i01_outer, t1060 = 0, i02_outer, t1062 = 0, i01_inner, t1053 = 0, i02_inner, t1064 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 2.491950

{ comp01[t5, t6, t7] -> comp01[0, t1108 = 0, i00 = t5, t1110 = 0, i01_outer, t1112 = 0, i02_outer, t1114 = 0, i01_inner, t1105 = 0, i02_inner, t1116 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 2.781150

{ comp01[t5, t6, t7] -> comp01[0, t1160 = 0, i00 = t5, t1162 = 0, i01_outer, t1164 = 0, i02_outer, t1166 = 0, i01_inner, t1157 = 0, i02_inner, t1168 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 2.854110

{ comp01[t5, t6, t7] -> comp01[0, t1212 = 0, i00 = t5, t1214 = 0, i01_outer, t1216 = 0, i02_outer, t1218 = 0, i01_inner, t1209 = 0, i02_inner, t1220 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 2.570870

{ comp01[t5, t6, t7] -> comp01[0, t1264 = 0, i00 = t5, t1266 = 0, i01_outer, t1268 = 0, i02_outer, t1270 = 0, i01_inner, t1261 = 0, i02_inner, t1272 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 2.743010

{ comp01[t5, t6, t7] -> comp01[0, t1316 = 0, i00 = t5, t1318 = 0, i01_outer, t1320 = 0, i02_outer, t1322 = 0, i01_inner, t1313 = 0, i02_inner, t1324 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 2.943040

{ comp01[t5, t6, t7] -> comp01[0, t1368 = 0, i00 = t5, t1370 = 0, i01_outer, t1372 = 0, i02_outer, t1374 = 0, i01_inner, t1365 = 0, i02_inner, t1376 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 2.566100

{ comp01[t5, t6, t7] -> comp01[0, t1420 = 0, i00 = t5, t1422 = 0, i01_outer, t1424 = 0, i02_outer, t1426 = 0, i01_inner, t1417 = 0, i02_inner, t1428 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
2.708910+2.677920+2.491950+2.781150+2.854110+2.570870+2.743010+2.943040+2.566100+2.250190+
remaining list
2.250190+2.491950+2.566100+2.570870+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 1024) {
      for (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Parallelize L1
Unrolling L2 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0 | P
		2- for 0 <= i02_outer < 256 | 0
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 2.384900

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 1024) {
      for (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Parallelize L1
Unrolling L2 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0 | P
		2- for 0 <= i02_outer < 128 | 0
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 3.790860

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 1024) {
      for (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Parallelize L1
Unrolling L2 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0 | P
		2- for 0 <= i02_outer < 64 | 0
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 2.268080

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 3.885030

{ comp01[t5, t6, t7] -> comp01[0, t1108 = 0, i00 = t5, t1110 = 0, i01_outer, t1112 = 0, i02_outer, t1114 = 0, i01_inner, t1105 = 0, i02_inner, t1116 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 5.085950

{ comp01[t5, t6, t7] -> comp01[0, t1108 = 0, i00 = t5, t1110 = 0, i01_outer, t1112 = 0, i02_outer, t1114 = 0, i01_inner, t1105 = 0, i02_inner, t1116 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 3.538130

{ comp01[t5, t6, t7] -> comp01[0, t1108 = 0, i00 = t5, t1110 = 0, i01_outer, t1112 = 0, i02_outer, t1114 = 0, i01_inner, t1105 = 0, i02_inner, t1116 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 3.236060

{ comp01[t5, t6, t7] -> comp01[0, t1420 = 0, i00 = t5, t1422 = 0, i01_outer, t1424 = 0, i02_outer, t1426 = 0, i01_inner, t1417 = 0, i02_inner, t1428 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 5.587100

{ comp01[t5, t6, t7] -> comp01[0, t1420 = 0, i00 = t5, t1422 = 0, i01_outer, t1424 = 0, i02_outer, t1426 = 0, i01_inner, t1417 = 0, i02_inner, t1428 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 3.731010

{ comp01[t5, t6, t7] -> comp01[0, t1420 = 0, i00 = t5, t1422 = 0, i01_outer, t1424 = 0, i02_outer, t1426 = 0, i01_inner, t1417 = 0, i02_inner, t1428 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 3.618000

{ comp01[t5, t6, t7] -> comp01[0, t1264 = 0, i00 = t5, t1266 = 0, i01_outer, t1268 = 0, i02_outer, t1270 = 0, i01_inner, t1261 = 0, i02_inner, t1272 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 6.004810

{ comp01[t5, t6, t7] -> comp01[0, t1264 = 0, i00 = t5, t1266 = 0, i01_outer, t1268 = 0, i02_outer, t1270 = 0, i01_inner, t1261 = 0, i02_inner, t1272 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 3.805880

{ comp01[t5, t6, t7] -> comp01[0, t1264 = 0, i00 = t5, t1266 = 0, i01_outer, t1268 = 0, i02_outer, t1270 = 0, i01_inner, t1261 = 0, i02_inner, t1272 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 4.724030

{ comp01[t5, t6, t7] -> comp01[0, t1955 = 0, i00 = t5, t1957 = 0, i01_outer, t1959 = 0, i02_outer, t1961 = 0, i01_inner, t1952 = 0, i02_inner, t1963 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 4.854920

{ comp01[t5, t6, t7] -> comp01[0, t2006 = 0, i00 = t5, t2008 = 0, i01_outer, t2010 = 0, i02_outer, t2012 = 0, i01_inner, t2003 = 0, i02_inner, t2014 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 4.378080

{ comp01[t5, t6, t7] -> comp01[0, t2057 = 0, i00 = t5, t2059 = 0, i01_outer, t2061 = 0, i02_outer, t2063 = 0, i01_inner, t2054 = 0, i02_inner, t2065 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 4.887100

{ comp01[t5, t6, t7] -> comp01[0, t2108 = 0, i00 = t5, t2110 = 0, i01_outer, t2112 = 0, i02_outer, t2114 = 0, i01_inner, t2105 = 0, i02_inner, t2116 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 4.899980

{ comp01[t5, t6, t7] -> comp01[0, t2159 = 0, i00 = t5, t2161 = 0, i01_outer, t2163 = 0, i02_outer, t2165 = 0, i01_inner, t2156 = 0, i02_inner, t2167 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 4.486080

{ comp01[t5, t6, t7] -> comp01[0, t2210 = 0, i00 = t5, t2212 = 0, i01_outer, t2214 = 0, i02_outer, t2216 = 0, i01_inner, t2207 = 0, i02_inner, t2218 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 4.705910

{ comp01[t5, t6, t7] -> comp01[0, t2261 = 0, i00 = t5, t2263 = 0, i01_outer, t2265 = 0, i02_outer, t2267 = 0, i01_inner, t2258 = 0, i02_inner, t2269 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 4.797940

{ comp01[t5, t6, t7] -> comp01[0, t2312 = 0, i00 = t5, t2314 = 0, i01_outer, t2316 = 0, i02_outer, t2318 = 0, i01_inner, t2309 = 0, i02_inner, t2320 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 4.457950

{ comp01[t5, t6, t7] -> comp01[0, t2363 = 0, i00 = t5, t2365 = 0, i01_outer, t2367 = 0, i02_outer, t2369 = 0, i01_inner, t2360 = 0, i02_inner, t2371 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
4.724030+4.854920+4.378080+4.887100+4.899980+4.486080+4.705910+4.797940+4.457950+2.434970+
remaining list
2.434970+4.378080+4.457950+4.486080+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Unrolling L2 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02_outer < 256 | 0
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 5.434040

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Unrolling L2 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02_outer < 128 | 0
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 8.972880

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Unrolling L2 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02_outer < 64 | 0
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 3.675940

{ comp01[t5, t6, t7] -> comp01[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 7.982970

{ comp01[t5, t6, t7] -> comp01[0, t2057 = 0, i00 = t5, t2059 = 0, i01_outer, t2061 = 0, i02_outer, t2063 = 0, i01_inner, t2054 = 0, i02_inner, t2065 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 9.701010

{ comp01[t5, t6, t7] -> comp01[0, t2057 = 0, i00 = t5, t2059 = 0, i01_outer, t2061 = 0, i02_outer, t2063 = 0, i01_inner, t2054 = 0, i02_inner, t2065 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 7.648940

{ comp01[t5, t6, t7] -> comp01[0, t2057 = 0, i00 = t5, t2059 = 0, i01_outer, t2061 = 0, i02_outer, t2063 = 0, i01_inner, t2054 = 0, i02_inner, t2065 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 8.896830

{ comp01[t5, t6, t7] -> comp01[0, t2363 = 0, i00 = t5, t2365 = 0, i01_outer, t2367 = 0, i02_outer, t2369 = 0, i01_inner, t2360 = 0, i02_inner, t2371 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 9.905100

{ comp01[t5, t6, t7] -> comp01[0, t2363 = 0, i00 = t5, t2365 = 0, i01_outer, t2367 = 0, i02_outer, t2369 = 0, i01_inner, t2360 = 0, i02_inner, t2371 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 7.941010

{ comp01[t5, t6, t7] -> comp01[0, t2363 = 0, i00 = t5, t2365 = 0, i01_outer, t2367 = 0, i02_outer, t2369 = 0, i01_inner, t2360 = 0, i02_inner, t2371 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 8.558990

{ comp01[t5, t6, t7] -> comp01[0, t2210 = 0, i00 = t5, t2212 = 0, i01_outer, t2214 = 0, i02_outer, t2216 = 0, i01_inner, t2207 = 0, i02_inner, t2218 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 9.860990

{ comp01[t5, t6, t7] -> comp01[0, t2210 = 0, i00 = t5, t2212 = 0, i01_outer, t2214 = 0, i02_outer, t2216 = 0, i01_inner, t2207 = 0, i02_inner, t2218 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 7.681130

{ comp01[t5, t6, t7] -> comp01[0, t2210 = 0, i00 = t5, t2212 = 0, i01_outer, t2214 = 0, i02_outer, t2216 = 0, i01_inner, t2207 = 0, i02_inner, t2218 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 5.270000

{ comp01[t5, t6, t7] -> comp01[0, t2885 = 0, i00 = t5, t2887 = 0, i01_outer, t2889 = 0, i02_outer, t2891 = 0, i01_inner, t2882 = 0, i02_inner, t2893 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 5.198000

{ comp01[t5, t6, t7] -> comp01[0, t2937 = 0, i00 = t5, t2939 = 0, i01_outer, t2941 = 0, i02_outer, t2943 = 0, i01_inner, t2934 = 0, i02_inner, t2945 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 5.975010

{ comp01[t5, t6, t7] -> comp01[0, t2989 = 0, i00 = t5, t2991 = 0, i01_outer, t2993 = 0, i02_outer, t2995 = 0, i01_inner, t2986 = 0, i02_inner, t2997 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 4.900930

{ comp01[t5, t6, t7] -> comp01[0, t3041 = 0, i00 = t5, t3043 = 0, i01_outer, t3045 = 0, i02_outer, t3047 = 0, i01_inner, t3038 = 0, i02_inner, t3049 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 4.977940

{ comp01[t5, t6, t7] -> comp01[0, t3093 = 0, i00 = t5, t3095 = 0, i01_outer, t3097 = 0, i02_outer, t3099 = 0, i01_inner, t3090 = 0, i02_inner, t3101 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 4.796980

{ comp01[t5, t6, t7] -> comp01[0, t3145 = 0, i00 = t5, t3147 = 0, i01_outer, t3149 = 0, i02_outer, t3151 = 0, i01_inner, t3142 = 0, i02_inner, t3153 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp01
Evaluation : 6.478070

{ comp01[t5, t6, t7] -> comp01[0, t3197 = 0, i00 = t5, t3199 = 0, i01_outer, t3201 = 0, i02_outer, t3203 = 0, i01_inner, t3194 = 0, i02_inner, t3205 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp01
Evaluation : 4.555230

{ comp01[t5, t6, t7] -> comp01[0, t3249 = 0, i00 = t5, t3251 = 0, i01_outer, t3253 = 0, i02_outer, t3255 = 0, i01_inner, t3246 = 0, i02_inner, t3257 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp01
Evaluation : 4.580020

{ comp01[t5, t6, t7] -> comp01[0, t3301 = 0, i00 = t5, t3303 = 0, i01_outer, t3305 = 0, i02_outer, t3307 = 0, i01_inner, t3298 = 0, i02_inner, t3309 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
5.270000+5.198000+5.975010+4.900930+4.977940+4.796980+6.478070+4.555230+4.580020+384.018005+
remaining list
4.555230+4.580020+4.796980+4.900930+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*16) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 4.179950

{ comp01[t5, t6, t7] -> comp01[0, t3249 = 0, i00 = t5, t3251 = 0, i01_outer, t3253 = 0, i02_outer, t3255 = 0, i01_inner, t3246 = 0, i02_inner, t3257 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*8) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 7.054810

{ comp01[t5, t6, t7] -> comp01[0, t3249 = 0, i00 = t5, t3251 = 0, i01_outer, t3253 = 0, i02_outer, t3255 = 0, i01_inner, t3246 = 0, i02_inner, t3257 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*4) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*4) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*4) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*4) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 4 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 4.210950

{ comp01[t5, t6, t7] -> comp01[0, t3249 = 0, i00 = t5, t3251 = 0, i01_outer, t3253 = 0, i02_outer, t3255 = 0, i01_inner, t3246 = 0, i02_inner, t3257 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 3.976110

{ comp01[t5, t6, t7] -> comp01[0, t3301 = 0, i00 = t5, t3303 = 0, i01_outer, t3305 = 0, i02_outer, t3307 = 0, i01_inner, t3298 = 0, i02_inner, t3309 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 5.780940

{ comp01[t5, t6, t7] -> comp01[0, t3301 = 0, i00 = t5, t3303 = 0, i01_outer, t3305 = 0, i02_outer, t3307 = 0, i01_inner, t3298 = 0, i02_inner, t3309 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 4.132990

{ comp01[t5, t6, t7] -> comp01[0, t3301 = 0, i00 = t5, t3303 = 0, i01_outer, t3305 = 0, i02_outer, t3307 = 0, i01_inner, t3298 = 0, i02_inner, t3309 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*32) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*32) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*32) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 128
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 32 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 4.161120

{ comp01[t5, t6, t7] -> comp01[0, t3145 = 0, i00 = t5, t3147 = 0, i01_outer, t3149 = 0, i02_outer, t3151 = 0, i01_inner, t3142 = 0, i02_inner, t3153 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*16) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*16) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*16) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 128
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 16 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 5.814080

{ comp01[t5, t6, t7] -> comp01[0, t3145 = 0, i00 = t5, t3147 = 0, i01_outer, t3149 = 0, i02_outer, t3151 = 0, i01_inner, t3142 = 0, i02_inner, t3153 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 128
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 4.243850

{ comp01[t5, t6, t7] -> comp01[0, t3145 = 0, i00 = t5, t3147 = 0, i01_outer, t3149 = 0, i02_outer, t3151 = 0, i01_inner, t3142 = 0, i02_inner, t3153 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((((c5*8) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*8) + c9)*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*8) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*8) + c9)*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*4) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*8) + c9)*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 8 | 0
					5- for 0 <= i02_inner_inner < 4 | 1
						comp01
Evaluation : 4.346130

{ comp01[t5, t6, t7] -> comp01[0, t3041 = 0, i00 = t5, t3043 = 0, i01_outer, t3045 = 0, i02_outer, t3047 = 0, i01_inner, t3038 = 0, i02_inner, t3049 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((((c5*4) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*4) + c9)*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*4) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*4) + c9)*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*8) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*4) + c9)*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 4 | 0
					5- for 0 <= i02_inner_inner < 8 | 1
						comp01
Evaluation : 3.895040

{ comp01[t5, t6, t7] -> comp01[0, t3041 = 0, i00 = t5, t3043 = 0, i01_outer, t3045 = 0, i02_outer, t3047 = 0, i01_inner, t3038 = 0, i02_inner, t3049 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((((c5*2) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((((c5*2) + c9)*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((((c5*2) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((((c5*2) + c9)*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*2) + c9)*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*2) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*2) + c9)*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*2) + c9)*16) + c11)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*2) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((((c5*2) + c9)*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner_outer < 2 | 0
					5- for 0 <= i02_inner_inner < 16 | 1
						comp01
Evaluation : 4.581930

{ comp01[t5, t6, t7] -> comp01[0, t3041 = 0, i00 = t5, t3043 = 0, i01_outer, t3045 = 0, i02_outer, t3047 = 0, i01_inner, t3038 = 0, i02_inner, t3049 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
0- for 0 <= i01 < 1024 | 0 | P
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02 < 1024 | 0
			comp01
Evaluation : 2.280950

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    parallel (c3, 0, 3) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0 | P
		2- for 0 <= i02 < 1024 | 0
			comp01
Evaluation : 8.593080

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      parallel (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L2
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02 < 1024 | 0 | P
			comp01
Evaluation : 387.096008

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
2.280950+8.593080+387.096008+2.468110+
remaining list
2.280950+2.468110+8.593080+387.096008+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Unrolling L2 4
0- for 0 <= i01 < 1024 | 0 | P
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 256 | 0
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 2.472880

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Unrolling L2 8
0- for 0 <= i01 < 1024 | 0 | P
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 128 | 0
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 3.264900

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Unrolling L2 16
0- for 0 <= i01 < 1024 | 0 | P
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 64 | 0
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 2.289060

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Unrolling L2 4
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 256 | 0
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 5.640980

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Unrolling L2 8
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 128 | 0
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 8.795020

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      for (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Unrolling L2 16
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 64 | 0
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 4.837990

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    parallel (c3, 0, 3) {
      for (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Unrolling L2 4
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0 | P
		2- for 0 <= i02_outer < 256 | 0
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 11.983900

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    parallel (c3, 0, 3) {
      for (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Unrolling L2 8
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0 | P
		2- for 0 <= i02_outer < 128 | 0
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 12.944000

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    parallel (c3, 0, 3) {
      for (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Unrolling L2 16
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0 | P
		2- for 0 <= i02_outer < 64 | 0
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 9.862900

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      parallel (c5, 0, 256) {
        unrolled (c7, 0, 4) {
          buf01[((((c5*4) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*4) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*4) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*4) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L2
Unrolling L2 4
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 256 | 0 | P
			3- for 0 <= i02_inner < 4 | 1
				comp01
Evaluation : 109.815002

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      parallel (c5, 0, 128) {
        unrolled (c7, 0, 8) {
          buf01[((((c5*8) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*8) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*8) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*8) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L2
Unrolling L2 8
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 128 | 0 | P
			3- for 0 <= i02_inner < 8 | 1
				comp01
Evaluation : 69.920998

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 3) {
      parallel (c5, 0, 64) {
        unrolled (c7, 0, 16) {
          buf01[((((c5*16) + c7) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = ((((((((buf00[((((c5*16) + c7) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))] + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((((c5*16) + c7) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32((int64(c1)*(int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)1052676)))]) + buf00[((int32((int64(((c5*16) + c7)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32((int64(c3)*(int64)1052676)))])
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L2
Unrolling L2 16
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 3 | 0
		2- for 0 <= i02_outer < 64 | 0 | P
			3- for 0 <= i02_inner < 16 | 1
				comp01
Evaluation : 49.313099

{ comp01[t5, t6, t7] -> comp01[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }



input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c3 + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02 < 1024 | 0
		2- for 0 <= i01 < 1024 | 0
			comp01
Evaluation : 19.730101

{ comp01[t5, t6, t7] -> comp01[0, t26 = 0, i00 = t5, t27 = 0, i02 = t7, t28 = 0, i01 = t6, t29 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c3 + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02 < 1024 | 0 | P
		2- for 0 <= i01 < 1024 | 0
			comp01
Evaluation : 17.099899

{ comp01[t5, t6, t7] -> comp01[0, t26 = 0, i00 = t5, t27 = 0, i02 = t7, t28 = 0, i01 = t6, t29 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 1024) {
      parallel (c5, 0, 1024) {
        buf01[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c3 + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32((int64(c5)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02 < 1024 | 0
		2- for 0 <= i01 < 1024 | 0 | P
			comp01
Evaluation : 462.182007

{ comp01[t5, t6, t7] -> comp01[0, t26 = 0, i00 = t5, t27 = 0, i02 = t7, t28 = 0, i01 = t6, t29 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
19.730101+17.099899+462.182007+48.905102+
remaining list
17.099899+19.730101+48.905102+462.182007+ Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 5.949020

{ comp01[t5, t6, t7] -> comp01[0, t4154 = 0, i00 = t5, t4156 = 0, i02_outer, t4158 = 0, i01_outer, t4160 = 0, i02_inner, t4151 = 0, i01_inner, t4162 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 6.379130

{ comp01[t5, t6, t7] -> comp01[0, t4211 = 0, i00 = t5, t4213 = 0, i02_outer, t4215 = 0, i01_outer, t4217 = 0, i02_inner, t4208 = 0, i01_inner, t4219 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 7.650140

{ comp01[t5, t6, t7] -> comp01[0, t4268 = 0, i00 = t5, t4270 = 0, i02_outer, t4272 = 0, i01_outer, t4274 = 0, i02_inner, t4265 = 0, i01_inner, t4276 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 6.201980

{ comp01[t5, t6, t7] -> comp01[0, t4325 = 0, i00 = t5, t4327 = 0, i02_outer, t4329 = 0, i01_outer, t4331 = 0, i02_inner, t4322 = 0, i01_inner, t4333 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0 | P
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 6.619930

{ comp01[t5, t6, t7] -> comp01[0, t4382 = 0, i00 = t5, t4384 = 0, i02_outer, t4386 = 0, i01_outer, t4388 = 0, i02_inner, t4379 = 0, i01_inner, t4390 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0 | P
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 7.121090

{ comp01[t5, t6, t7] -> comp01[0, t4439 = 0, i00 = t5, t4441 = 0, i02_outer, t4443 = 0, i01_outer, t4445 = 0, i02_inner, t4436 = 0, i01_inner, t4447 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 6.073950

{ comp01[t5, t6, t7] -> comp01[0, t4496 = 0, i00 = t5, t4498 = 0, i02_outer, t4500 = 0, i01_outer, t4502 = 0, i02_inner, t4493 = 0, i01_inner, t4504 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0 | P
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 6.484990

{ comp01[t5, t6, t7] -> comp01[0, t4553 = 0, i00 = t5, t4555 = 0, i02_outer, t4557 = 0, i01_outer, t4559 = 0, i02_inner, t4550 = 0, i01_inner, t4561 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0 | P
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 7.106070

{ comp01[t5, t6, t7] -> comp01[0, t4610 = 0, i00 = t5, t4612 = 0, i02_outer, t4614 = 0, i01_outer, t4616 = 0, i02_inner, t4607 = 0, i01_inner, t4618 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
5.949020+6.379130+7.650140+6.201980+6.619930+7.121090+6.073950+6.484990+7.106070+17.099899+
remaining list
5.949020+6.073950+6.201980+6.379130+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 7.272960

{ comp01[t5, t6, t7] -> comp01[0, t4154 = 0, i00 = t5, t4156 = 0, i02_outer, t4158 = 0, i01_outer, t4160 = 0, i02_inner, t4151 = 0, i01_inner, t4162 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 5.563020

{ comp01[t5, t6, t7] -> comp01[0, t4154 = 0, i00 = t5, t4156 = 0, i02_outer, t4158 = 0, i01_outer, t4160 = 0, i02_inner, t4151 = 0, i01_inner, t4162 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 5.573990

{ comp01[t5, t6, t7] -> comp01[0, t4154 = 0, i00 = t5, t4156 = 0, i02_outer, t4158 = 0, i01_outer, t4160 = 0, i02_inner, t4151 = 0, i01_inner, t4162 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 6.824020

{ comp01[t5, t6, t7] -> comp01[0, t4496 = 0, i00 = t5, t4498 = 0, i02_outer, t4500 = 0, i01_outer, t4502 = 0, i02_inner, t4493 = 0, i01_inner, t4504 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.007910

{ comp01[t5, t6, t7] -> comp01[0, t4496 = 0, i00 = t5, t4498 = 0, i02_outer, t4500 = 0, i01_outer, t4502 = 0, i02_inner, t4493 = 0, i01_inner, t4504 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 5.790950

{ comp01[t5, t6, t7] -> comp01[0, t4496 = 0, i00 = t5, t4498 = 0, i02_outer, t4500 = 0, i01_outer, t4502 = 0, i02_inner, t4493 = 0, i01_inner, t4504 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 6.785150

{ comp01[t5, t6, t7] -> comp01[0, t4325 = 0, i00 = t5, t4327 = 0, i02_outer, t4329 = 0, i01_outer, t4331 = 0, i02_inner, t4322 = 0, i01_inner, t4333 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.360770

{ comp01[t5, t6, t7] -> comp01[0, t4325 = 0, i00 = t5, t4327 = 0, i02_outer, t4329 = 0, i01_outer, t4331 = 0, i02_inner, t4322 = 0, i01_inner, t4333 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0 | P
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 5.774020

{ comp01[t5, t6, t7] -> comp01[0, t4325 = 0, i00 = t5, t4327 = 0, i02_outer, t4329 = 0, i01_outer, t4331 = 0, i02_inner, t4322 = 0, i01_inner, t4333 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 64
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 16 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 7.200960

{ comp01[t5, t6, t7] -> comp01[0, t4211 = 0, i00 = t5, t4213 = 0, i02_outer, t4215 = 0, i01_outer, t4217 = 0, i02_inner, t4208 = 0, i01_inner, t4219 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 64
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.105900

{ comp01[t5, t6, t7] -> comp01[0, t4211 = 0, i00 = t5, t4213 = 0, i02_outer, t4215 = 0, i01_outer, t4217 = 0, i02_inner, t4208 = 0, i01_inner, t4219 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 64
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0 | P
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.065130

{ comp01[t5, t6, t7] -> comp01[0, t4211 = 0, i00 = t5, t4213 = 0, i02_outer, t4215 = 0, i01_outer, t4217 = 0, i02_inner, t4208 = 0, i01_inner, t4219 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 6.062980

{ comp01[t5, t6, t7] -> comp01[0, t5267 = 0, i00 = t5, t5269 = 0, i02_outer, t5271 = 0, i01_outer, t5273 = 0, i02_inner, t5264 = 0, i01_inner, t5275 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 7.171150

{ comp01[t5, t6, t7] -> comp01[0, t5324 = 0, i00 = t5, t5326 = 0, i02_outer, t5328 = 0, i01_outer, t5330 = 0, i02_inner, t5321 = 0, i01_inner, t5332 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 6.364110

{ comp01[t5, t6, t7] -> comp01[0, t5381 = 0, i00 = t5, t5383 = 0, i02_outer, t5385 = 0, i01_outer, t5387 = 0, i02_inner, t5378 = 0, i01_inner, t5389 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 5.809070

{ comp01[t5, t6, t7] -> comp01[0, t5438 = 0, i00 = t5, t5440 = 0, i02_outer, t5442 = 0, i01_outer, t5444 = 0, i02_inner, t5435 = 0, i01_inner, t5446 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 6.160020

{ comp01[t5, t6, t7] -> comp01[0, t5495 = 0, i00 = t5, t5497 = 0, i02_outer, t5499 = 0, i01_outer, t5501 = 0, i02_inner, t5492 = 0, i01_inner, t5503 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 6.539110

{ comp01[t5, t6, t7] -> comp01[0, t5552 = 0, i00 = t5, t5554 = 0, i02_outer, t5556 = 0, i01_outer, t5558 = 0, i02_inner, t5549 = 0, i01_inner, t5560 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 5.630020

{ comp01[t5, t6, t7] -> comp01[0, t5609 = 0, i00 = t5, t5611 = 0, i02_outer, t5613 = 0, i01_outer, t5615 = 0, i02_inner, t5606 = 0, i01_inner, t5617 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 5.743980

{ comp01[t5, t6, t7] -> comp01[0, t5666 = 0, i00 = t5, t5668 = 0, i02_outer, t5670 = 0, i01_outer, t5672 = 0, i02_inner, t5663 = 0, i01_inner, t5674 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 6.245850

{ comp01[t5, t6, t7] -> comp01[0, t5723 = 0, i00 = t5, t5725 = 0, i02_outer, t5727 = 0, i01_outer, t5729 = 0, i02_inner, t5720 = 0, i01_inner, t5731 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
6.062980+7.171150+6.364110+5.809070+6.160020+6.539110+5.630020+5.743980+6.245850+19.730101+
remaining list
5.630020+5.743980+5.809070+6.062980+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 6.230830

{ comp01[t5, t6, t7] -> comp01[0, t5609 = 0, i00 = t5, t5611 = 0, i02_outer, t5613 = 0, i01_outer, t5615 = 0, i02_inner, t5606 = 0, i01_inner, t5617 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 5.616900

{ comp01[t5, t6, t7] -> comp01[0, t5609 = 0, i00 = t5, t5611 = 0, i02_outer, t5613 = 0, i01_outer, t5615 = 0, i02_inner, t5606 = 0, i01_inner, t5617 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.672140

{ comp01[t5, t6, t7] -> comp01[0, t5609 = 0, i00 = t5, t5611 = 0, i02_outer, t5613 = 0, i01_outer, t5615 = 0, i02_inner, t5606 = 0, i01_inner, t5617 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 64
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 16 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 7.432940

{ comp01[t5, t6, t7] -> comp01[0, t5666 = 0, i00 = t5, t5668 = 0, i02_outer, t5670 = 0, i01_outer, t5672 = 0, i02_inner, t5663 = 0, i01_inner, t5674 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 64
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.322150

{ comp01[t5, t6, t7] -> comp01[0, t5666 = 0, i00 = t5, t5668 = 0, i02_outer, t5670 = 0, i01_outer, t5672 = 0, i02_inner, t5663 = 0, i01_inner, t5674 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 64
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 7.081990

{ comp01[t5, t6, t7] -> comp01[0, t5666 = 0, i00 = t5, t5668 = 0, i02_outer, t5670 = 0, i01_outer, t5672 = 0, i02_inner, t5663 = 0, i01_inner, t5674 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 6.478070

{ comp01[t5, t6, t7] -> comp01[0, t5438 = 0, i00 = t5, t5440 = 0, i02_outer, t5442 = 0, i01_outer, t5444 = 0, i02_inner, t5435 = 0, i01_inner, t5446 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 7.260080

{ comp01[t5, t6, t7] -> comp01[0, t5438 = 0, i00 = t5, t5440 = 0, i02_outer, t5442 = 0, i01_outer, t5444 = 0, i02_inner, t5435 = 0, i01_inner, t5446 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 7.005930

{ comp01[t5, t6, t7] -> comp01[0, t5438 = 0, i00 = t5, t5440 = 0, i02_outer, t5442 = 0, i01_outer, t5444 = 0, i02_inner, t5435 = 0, i01_inner, t5446 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 10.023100

{ comp01[t5, t6, t7] -> comp01[0, t5267 = 0, i00 = t5, t5269 = 0, i02_outer, t5271 = 0, i01_outer, t5273 = 0, i02_inner, t5264 = 0, i01_inner, t5275 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 5.742070

{ comp01[t5, t6, t7] -> comp01[0, t5267 = 0, i00 = t5, t5269 = 0, i02_outer, t5271 = 0, i01_outer, t5273 = 0, i02_inner, t5264 = 0, i01_inner, t5275 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.797080

{ comp01[t5, t6, t7] -> comp01[0, t5267 = 0, i00 = t5, t5269 = 0, i02_outer, t5271 = 0, i01_outer, t5273 = 0, i02_inner, t5264 = 0, i01_inner, t5275 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 14.326100

{ comp01[t5, t6, t7] -> comp01[0, t6380 = 0, i00 = t5, t6382 = 0, i02_outer, t6384 = 0, i01_outer, t6386 = 0, i02_inner, t6377 = 0, i01_inner, t6388 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 16.129999

{ comp01[t5, t6, t7] -> comp01[0, t6436 = 0, i00 = t5, t6438 = 0, i02_outer, t6440 = 0, i01_outer, t6442 = 0, i02_inner, t6433 = 0, i01_inner, t6444 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 17.595100

{ comp01[t5, t6, t7] -> comp01[0, t6492 = 0, i00 = t5, t6494 = 0, i02_outer, t6496 = 0, i01_outer, t6498 = 0, i02_inner, t6489 = 0, i01_inner, t6500 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 14.076000

{ comp01[t5, t6, t7] -> comp01[0, t6548 = 0, i00 = t5, t6550 = 0, i02_outer, t6552 = 0, i01_outer, t6554 = 0, i02_inner, t6545 = 0, i01_inner, t6556 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 15.201100

{ comp01[t5, t6, t7] -> comp01[0, t6604 = 0, i00 = t5, t6606 = 0, i02_outer, t6608 = 0, i01_outer, t6610 = 0, i02_inner, t6601 = 0, i01_inner, t6612 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 17.366199

{ comp01[t5, t6, t7] -> comp01[0, t6660 = 0, i00 = t5, t6662 = 0, i02_outer, t6664 = 0, i01_outer, t6666 = 0, i02_inner, t6657 = 0, i01_inner, t6668 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 13.788000

{ comp01[t5, t6, t7] -> comp01[0, t6716 = 0, i00 = t5, t6718 = 0, i02_outer, t6720 = 0, i01_outer, t6722 = 0, i02_inner, t6713 = 0, i01_inner, t6724 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 15.020800

{ comp01[t5, t6, t7] -> comp01[0, t6772 = 0, i00 = t5, t6774 = 0, i02_outer, t6776 = 0, i01_outer, t6778 = 0, i02_inner, t6769 = 0, i01_inner, t6780 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 8 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 16.882900

{ comp01[t5, t6, t7] -> comp01[0, t6828 = 0, i00 = t5, t6830 = 0, i02_outer, t6832 = 0, i01_outer, t6834 = 0, i02_inner, t6825 = 0, i01_inner, t6836 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
14.326100+16.129999+17.595100+14.076000+15.201100+17.366199+13.788000+15.020800+16.882900+48.905102+
remaining list
13.788000+14.076000+14.326100+15.020800+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 16.798000

{ comp01[t5, t6, t7] -> comp01[0, t6716 = 0, i00 = t5, t6718 = 0, i02_outer, t6720 = 0, i01_outer, t6722 = 0, i02_inner, t6713 = 0, i01_inner, t6724 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 13.964900

{ comp01[t5, t6, t7] -> comp01[0, t6716 = 0, i00 = t5, t6718 = 0, i02_outer, t6720 = 0, i01_outer, t6722 = 0, i02_inner, t6713 = 0, i01_inner, t6724 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 14.467000

{ comp01[t5, t6, t7] -> comp01[0, t6716 = 0, i00 = t5, t6718 = 0, i02_outer, t6720 = 0, i01_outer, t6722 = 0, i02_inner, t6713 = 0, i01_inner, t6724 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 16.202200

{ comp01[t5, t6, t7] -> comp01[0, t6548 = 0, i00 = t5, t6550 = 0, i02_outer, t6552 = 0, i01_outer, t6554 = 0, i02_inner, t6545 = 0, i01_inner, t6556 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 14.216200

{ comp01[t5, t6, t7] -> comp01[0, t6548 = 0, i00 = t5, t6550 = 0, i02_outer, t6552 = 0, i01_outer, t6554 = 0, i02_inner, t6545 = 0, i01_inner, t6556 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 14.793200

{ comp01[t5, t6, t7] -> comp01[0, t6548 = 0, i00 = t5, t6550 = 0, i02_outer, t6552 = 0, i01_outer, t6554 = 0, i02_inner, t6545 = 0, i01_inner, t6556 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 16.362200

{ comp01[t5, t6, t7] -> comp01[0, t6380 = 0, i00 = t5, t6382 = 0, i02_outer, t6384 = 0, i01_outer, t6386 = 0, i02_inner, t6377 = 0, i01_inner, t6388 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 14.181100

{ comp01[t5, t6, t7] -> comp01[0, t6380 = 0, i00 = t5, t6382 = 0, i02_outer, t6384 = 0, i01_outer, t6386 = 0, i02_inner, t6377 = 0, i01_inner, t6388 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*32) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 14.957000

{ comp01[t5, t6, t7] -> comp01[0, t6380 = 0, i00 = t5, t6382 = 0, i02_outer, t6384 = 0, i01_outer, t6386 = 0, i02_inner, t6377 = 0, i01_inner, t6388 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 64
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 16 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 18.784000

{ comp01[t5, t6, t7] -> comp01[0, t6772 = 0, i00 = t5, t6774 = 0, i02_outer, t6776 = 0, i01_outer, t6778 = 0, i02_inner, t6769 = 0, i01_inner, t6780 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 64
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 15.302200

{ comp01[t5, t6, t7] -> comp01[0, t6772 = 0, i00 = t5, t6774 = 0, i02_outer, t6776 = 0, i01_outer, t6778 = 0, i02_inner, t6769 = 0, i01_inner, t6780 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 64
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 15.414000

{ comp01[t5, t6, t7] -> comp01[0, t6772 = 0, i00 = t5, t6774 = 0, i02_outer, t6776 = 0, i01_outer, t6778 = 0, i02_inner, t6769 = 0, i01_inner, t6780 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 32 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 7.234100

{ comp01[t5, t6, t7] -> comp01[0, t7472 = 0, i00 = t5, t7474 = 0, i02_outer, t7476 = 0, i01_outer, t7478 = 0, i02_inner, t7469 = 0, i01_inner, t7480 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 32 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 7.118940

{ comp01[t5, t6, t7] -> comp01[0, t7529 = 0, i00 = t5, t7531 = 0, i02_outer, t7533 = 0, i01_outer, t7535 = 0, i02_inner, t7526 = 0, i01_inner, t7537 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf01[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 32 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 32 | 0
		2- for 0 <= i01_outer < 8 | 0 | P
			3- for 0 <= i02_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 8.093120

{ comp01[t5, t6, t7] -> comp01[0, t7586 = 0, i00 = t5, t7588 = 0, i02_outer, t7590 = 0, i01_outer, t7592 = 0, i02_inner, t7583 = 0, i01_inner, t7594 = 0] : (-t7 + i02_inner) mod 32 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 6.184100

{ comp01[t5, t6, t7] -> comp01[0, t7643 = 0, i00 = t5, t7645 = 0, i02_outer, t7647 = 0, i01_outer, t7649 = 0, i02_inner, t7640 = 0, i01_inner, t7651 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 6.789210

{ comp01[t5, t6, t7] -> comp01[0, t7700 = 0, i00 = t5, t7702 = 0, i02_outer, t7704 = 0, i01_outer, t7706 = 0, i02_inner, t7697 = 0, i01_inner, t7708 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf01[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 8 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 7.323030

{ comp01[t5, t6, t7] -> comp01[0, t7757 = 0, i00 = t5, t7759 = 0, i02_outer, t7761 = 0, i01_outer, t7763 = 0, i02_inner, t7754 = 0, i01_inner, t7765 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*32) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*32) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 32
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					comp01
Evaluation : 5.959990

{ comp01[t5, t6, t7] -> comp01[0, t7814 = 0, i00 = t5, t7816 = 0, i02_outer, t7818 = 0, i01_outer, t7820 = 0, i02_inner, t7811 = 0, i01_inner, t7822 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*64) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*64) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 64
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					comp01
Evaluation : 6.920100

{ comp01[t5, t6, t7] -> comp01[0, t7871 = 0, i00 = t5, t7873 = 0, i02_outer, t7875 = 0, i01_outer, t7877 = 0, i02_inner, t7868 = 0, i01_inner, t7879 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i02 i01  deapth of outer is:1 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf01[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((c5*128) + c9))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c5*128) + c9))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 128
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 8 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					comp01
Evaluation : 7.396940

{ comp01[t5, t6, t7] -> comp01[0, t7928 = 0, i00 = t5, t7930 = 0, i02_outer, t7932 = 0, i01_outer, t7934 = 0, i02_inner, t7925 = 0, i01_inner, t7936 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
7.234100+7.118940+8.093120+6.184100+6.789210+7.323030+5.959990+6.920100+7.396940+462.182007+
remaining list
5.959990+6.184100+6.789210+6.920100+
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 6.474970

{ comp01[t5, t6, t7] -> comp01[0, t7814 = 0, i00 = t5, t7816 = 0, i02_outer, t7818 = 0, i01_outer, t7820 = 0, i02_inner, t7811 = 0, i01_inner, t7822 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 5.726100

{ comp01[t5, t6, t7] -> comp01[0, t7814 = 0, i00 = t5, t7816 = 0, i02_outer, t7818 = 0, i01_outer, t7820 = 0, i02_inner, t7811 = 0, i01_inner, t7822 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.115910

{ comp01[t5, t6, t7] -> comp01[0, t7814 = 0, i00 = t5, t7816 = 0, i02_outer, t7818 = 0, i01_outer, t7820 = 0, i02_inner, t7811 = 0, i01_inner, t7822 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 32
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 6.758930

{ comp01[t5, t6, t7] -> comp01[0, t7643 = 0, i00 = t5, t7645 = 0, i02_outer, t7647 = 0, i01_outer, t7649 = 0, i02_inner, t7640 = 0, i01_inner, t7651 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 32
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.550070

{ comp01[t5, t6, t7] -> comp01[0, t7643 = 0, i00 = t5, t7645 = 0, i02_outer, t7647 = 0, i01_outer, t7649 = 0, i02_inner, t7640 = 0, i01_inner, t7651 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 2) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*2) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*2) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 32
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 32 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 2 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.353860

{ comp01[t5, t6, t7] -> comp01[0, t7643 = 0, i00 = t5, t7645 = 0, i02_outer, t7647 = 0, i01_outer, t7649 = 0, i02_inner, t7640 = 0, i01_inner, t7651 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 64
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 16 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 7.838010

{ comp01[t5, t6, t7] -> comp01[0, t7700 = 0, i00 = t5, t7702 = 0, i02_outer, t7704 = 0, i01_outer, t7706 = 0, i02_inner, t7697 = 0, i01_inner, t7708 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 64
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.840940

{ comp01[t5, t6, t7] -> comp01[0, t7700 = 0, i00 = t5, t7702 = 0, i02_outer, t7704 = 0, i01_outer, t7706 = 0, i02_inner, t7697 = 0, i01_inner, t7708 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*64) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*64) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 64
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 16 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 64 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.835940

{ comp01[t5, t6, t7] -> comp01[0, t7700 = 0, i00 = t5, t7702 = 0, i02_outer, t7704 = 0, i01_outer, t7706 = 0, i02_inner, t7697 = 0, i01_inner, t7708 = 0] : (-t7 + i02_inner) mod 64 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 16) {
            unrolled (c11, 0, 4) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*16) + c9)*4) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*16) + c9)*4) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 64
Unrolling L4 4
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 16 | 0
					5- for 0 <= i01_inner_inner < 4 | 1
						comp01
Evaluation : 7.406950

{ comp01[t5, t6, t7] -> comp01[0, t7871 = 0, i00 = t5, t7873 = 0, i02_outer, t7875 = 0, i01_outer, t7877 = 0, i02_inner, t7868 = 0, i01_inner, t7879 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 8) {
            unrolled (c11, 0, 8) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*8) + c9)*8) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*8) + c9)*8) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 64
Unrolling L4 8
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 8 | 0
					5- for 0 <= i01_inner_inner < 8 | 1
						comp01
Evaluation : 6.904130

{ comp01[t5, t6, t7] -> comp01[0, t7871 = 0, i00 = t5, t7873 = 0, i02_outer, t7875 = 0, i01_outer, t7877 = 0, i02_inner, t7868 = 0, i01_inner, t7879 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 4) {
            unrolled (c11, 0, 16) {
              buf01[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((((c3*128) + c7) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((((c3*128) + c7) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32((int64(((((c5*4) + c9)*16) + c11))*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((((c5*4) + c9)*16) + c11))*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
            }
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 64
Unrolling L4 16
0- for 0 <= i00 < 3 | 0
	1- for 0 <= i02_outer < 8 | 0
		2- for 0 <= i01_outer < 16 | 0 | P
			3- for 0 <= i02_inner < 128 | 0
				4- for 0 <= i01_inner_outer < 4 | 0
					5- for 0 <= i01_inner_inner < 16 | 1
						comp01
Evaluation : 6.822820

{ comp01[t5, t6, t7] -> comp01[0, t7871 = 0, i00 = t5, t7873 = 0, i02_outer, t7875 = 0, i01_outer, t7877 = 0, i02_inner, t7868 = 0, i01_inner, t7879 = 0] : (-t7 + i02_inner) mod 128 = 0 and (-t6 + i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      for (c5, 0, 3) {
        buf01[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = ((((((((buf00[((c1 + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))] + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
0- for 0 <= i02 < 1024 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i00 < 3 | 0
			comp01
Evaluation : 20.193100

{ comp01[t5, t6, t7] -> comp01[0, t17 = 0, i02 = t7, t18 = 0, i01 = t6, t19 = 0, i00 = t5, t20 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      for (c5, 0, 3) {
        buf01[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = ((((((((buf00[((c1 + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))] + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
0- for 0 <= i02 < 1024 | 0
	1- for 0 <= i01 < 1024 | 0 | P
		2- for 0 <= i00 < 3 | 0
			comp01
Evaluation : 168.123001

{ comp01[t5, t6, t7] -> comp01[0, t17 = 0, i02 = t7, t18 = 0, i01 = t6, t19 = 0, i00 = t5, t20 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      parallel (c5, 0, 3) {
        buf01[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = ((((((((buf00[((c1 + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))] + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)1052676)))]) + buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c5)*(int64)1052676)))])
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
0- for 0 <= i02 < 1024 | 0
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i00 < 3 | 0 | P
			comp01
Evaluation : 4151.109863

{ comp01[t5, t6, t7] -> comp01[0, t17 = 0, i02 = t7, t18 = 0, i01 = t6, t19 = 0, i00 = t5, t20 = 0] : 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
20.193100+168.123001+4151.109863+54.640099+
remaining list
20.193100+54.640099+168.123001+4151.109863+ Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= i02_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.223900

{ comp01[t5, t6, t7] -> comp01[0, t8603 = 0, i02_outer, t8605 = 0, i01_outer, t8607 = 0, i02_inner, t8600 = 0, i01_inner, t8609 = 0, i00 = t5, t8611 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= i02_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 9.713170

{ comp01[t5, t6, t7] -> comp01[0, t8660 = 0, i02_outer, t8662 = 0, i01_outer, t8664 = 0, i02_inner, t8657 = 0, i01_inner, t8666 = 0, i00 = t5, t8668 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= i02_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 9.751080

{ comp01[t5, t6, t7] -> comp01[0, t8717 = 0, i02_outer, t8719 = 0, i01_outer, t8721 = 0, i02_inner, t8714 = 0, i01_inner, t8723 = 0, i00 = t5, t8725 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= i02_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 9.888890

{ comp01[t5, t6, t7] -> comp01[0, t8774 = 0, i02_outer, t8776 = 0, i01_outer, t8778 = 0, i02_inner, t8771 = 0, i01_inner, t8780 = 0, i00 = t5, t8782 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= i02_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.191000

{ comp01[t5, t6, t7] -> comp01[0, t8831 = 0, i02_outer, t8833 = 0, i01_outer, t8835 = 0, i02_inner, t8828 = 0, i01_inner, t8837 = 0, i00 = t5, t8839 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= i02_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.473000

{ comp01[t5, t6, t7] -> comp01[0, t8888 = 0, i02_outer, t8890 = 0, i01_outer, t8892 = 0, i02_inner, t8885 = 0, i01_inner, t8894 = 0, i00 = t5, t8896 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= i02_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.262000

{ comp01[t5, t6, t7] -> comp01[0, t8945 = 0, i02_outer, t8947 = 0, i01_outer, t8949 = 0, i02_inner, t8942 = 0, i01_inner, t8951 = 0, i00 = t5, t8953 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= i02_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.300900

{ comp01[t5, t6, t7] -> comp01[0, t9002 = 0, i02_outer, t9004 = 0, i01_outer, t9006 = 0, i02_inner, t8999 = 0, i01_inner, t9008 = 0, i00 = t5, t9010 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= i02_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.303000

{ comp01[t5, t6, t7] -> comp01[0, t9059 = 0, i02_outer, t9061 = 0, i01_outer, t9063 = 0, i02_inner, t9056 = 0, i01_inner, t9065 = 0, i00 = t5, t9067 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
10.223900+9.713170+9.751080+9.888890+10.191000+10.473000+10.262000+10.300900+10.303000+20.193100+
remaining list
9.713170+9.751080+9.888890+10.191000+ Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 32 L1 32
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.091000

{ comp01[t5, t6, t7] -> comp01[0, t9116 = 0, i02_outer, t9118 = 0, i01_outer, t9120 = 0, i02_inner, t9113 = 0, i01_inner, t9122 = 0, i00 = t5, t9124 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 32 L1 64
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.250000

{ comp01[t5, t6, t7] -> comp01[0, t9172 = 0, i02_outer, t9174 = 0, i01_outer, t9176 = 0, i02_inner, t9169 = 0, i01_inner, t9178 = 0, i00 = t5, t9180 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 32 L1 128
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.014900

{ comp01[t5, t6, t7] -> comp01[0, t9228 = 0, i02_outer, t9230 = 0, i01_outer, t9232 = 0, i02_inner, t9225 = 0, i01_inner, t9234 = 0, i00 = t5, t9236 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 64 L1 32
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.369900

{ comp01[t5, t6, t7] -> comp01[0, t9284 = 0, i02_outer, t9286 = 0, i01_outer, t9288 = 0, i02_inner, t9281 = 0, i01_inner, t9290 = 0, i00 = t5, t9292 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 64 L1 64
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.502001

{ comp01[t5, t6, t7] -> comp01[0, t9340 = 0, i02_outer, t9342 = 0, i01_outer, t9344 = 0, i02_inner, t9337 = 0, i01_inner, t9346 = 0, i00 = t5, t9348 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 64 L1 128
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 17.778900

{ comp01[t5, t6, t7] -> comp01[0, t9396 = 0, i02_outer, t9398 = 0, i01_outer, t9400 = 0, i02_inner, t9393 = 0, i01_inner, t9402 = 0, i00 = t5, t9404 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 128 L1 32
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 17.865200

{ comp01[t5, t6, t7] -> comp01[0, t9452 = 0, i02_outer, t9454 = 0, i01_outer, t9456 = 0, i02_inner, t9449 = 0, i01_inner, t9458 = 0, i00 = t5, t9460 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 128 L1 64
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.098101

{ comp01[t5, t6, t7] -> comp01[0, t9508 = 0, i02_outer, t9510 = 0, i01_outer, t9512 = 0, i02_inner, t9505 = 0, i01_inner, t9514 = 0, i00 = t5, t9516 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 128 L1 128
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 18.115999

{ comp01[t5, t6, t7] -> comp01[0, t9564 = 0, i02_outer, t9566 = 0, i01_outer, t9568 = 0, i02_inner, t9561 = 0, i01_inner, t9570 = 0, i00 = t5, t9572 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
18.091000+18.250000+18.014900+18.369900+18.502001+17.778900+17.865200+18.098101+18.115999+54.640099+
remaining list
17.778900+17.865200+18.014900+18.091000+ Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 9.955880

{ comp01[t5, t6, t7] -> comp01[0, t9620 = 0, i02_outer, t9622 = 0, i01_outer, t9624 = 0, i02_inner, t9617 = 0, i01_inner, t9626 = 0, i00 = t5, t9628 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.772000

{ comp01[t5, t6, t7] -> comp01[0, t9677 = 0, i02_outer, t9679 = 0, i01_outer, t9681 = 0, i02_inner, t9674 = 0, i01_inner, t9683 = 0, i00 = t5, t9685 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 11.583100

{ comp01[t5, t6, t7] -> comp01[0, t9734 = 0, i02_outer, t9736 = 0, i01_outer, t9738 = 0, i02_inner, t9731 = 0, i01_inner, t9740 = 0, i00 = t5, t9742 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 9.535070

{ comp01[t5, t6, t7] -> comp01[0, t9791 = 0, i02_outer, t9793 = 0, i01_outer, t9795 = 0, i02_inner, t9788 = 0, i01_inner, t9797 = 0, i00 = t5, t9799 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 10.673000

{ comp01[t5, t6, t7] -> comp01[0, t9848 = 0, i02_outer, t9850 = 0, i01_outer, t9852 = 0, i02_inner, t9845 = 0, i01_inner, t9854 = 0, i00 = t5, t9856 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 11.777200

{ comp01[t5, t6, t7] -> comp01[0, t9905 = 0, i02_outer, t9907 = 0, i01_outer, t9909 = 0, i02_inner, t9902 = 0, i01_inner, t9911 = 0, i00 = t5, t9913 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 11.365200

{ comp01[t5, t6, t7] -> comp01[0, t9962 = 0, i02_outer, t9964 = 0, i01_outer, t9966 = 0, i02_inner, t9959 = 0, i01_inner, t9968 = 0, i00 = t5, t9970 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 12.116900

{ comp01[t5, t6, t7] -> comp01[0, t10019 = 0, i02_outer, t10021 = 0, i01_outer, t10023 = 0, i02_inner, t10016 = 0, i01_inner, t10025 = 0, i00 = t5, t10027 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0
					comp01
Evaluation : 12.038000

{ comp01[t5, t6, t7] -> comp01[0, t10076 = 0, i02_outer, t10078 = 0, i01_outer, t10080 = 0, i02_inner, t10073 = 0, i01_inner, t10082 = 0, i00 = t5, t10084 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
9.955880+10.772000+11.583100+9.535070+10.673000+11.777200+11.365200+12.116900+12.038000+168.123001+
remaining list
9.535070+9.955880+10.673000+10.772000+ Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 32 L1 32
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 21.080000

{ comp01[t5, t6, t7] -> comp01[0, t10133 = 0, i02_outer, t10135 = 0, i01_outer, t10137 = 0, i02_inner, t10130 = 0, i01_inner, t10139 = 0, i00 = t5, t10141 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 32 L1 64
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 16.451799

{ comp01[t5, t6, t7] -> comp01[0, t10190 = 0, i02_outer, t10192 = 0, i01_outer, t10194 = 0, i02_inner, t10187 = 0, i01_inner, t10196 = 0, i00 = t5, t10198 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 32 L1 128
0- for 0 <= i02_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 13.423000

{ comp01[t5, t6, t7] -> comp01[0, t10247 = 0, i02_outer, t10249 = 0, i01_outer, t10251 = 0, i02_inner, t10244 = 0, i01_inner, t10253 = 0, i00 = t5, t10255 = 0] : (t7 - i02_inner) mod 32 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -31 + t7 <= 32i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      parallel (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 64 L1 32
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 15.775000

{ comp01[t5, t6, t7] -> comp01[0, t10304 = 0, i02_outer, t10306 = 0, i01_outer, t10308 = 0, i02_inner, t10301 = 0, i01_inner, t10310 = 0, i00 = t5, t10312 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      parallel (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 64 L1 64
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 12.702900

{ comp01[t5, t6, t7] -> comp01[0, t10361 = 0, i02_outer, t10363 = 0, i01_outer, t10365 = 0, i02_inner, t10358 = 0, i01_inner, t10367 = 0, i00 = t5, t10369 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      parallel (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 64 L1 128
0- for 0 <= i02_outer < 16 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 9.246830

{ comp01[t5, t6, t7] -> comp01[0, t10418 = 0, i02_outer, t10420 = 0, i01_outer, t10422 = 0, i02_inner, t10415 = 0, i01_inner, t10424 = 0, i00 = t5, t10426 = 0] : (t7 - i02_inner) mod 64 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -63 + t7 <= 64i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      parallel (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 128 L1 32
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 14.131100

{ comp01[t5, t6, t7] -> comp01[0, t10475 = 0, i02_outer, t10477 = 0, i01_outer, t10479 = 0, i02_inner, t10472 = 0, i01_inner, t10481 = 0, i00 = t5, t10483 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 128 L1 64
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 10.451100

{ comp01[t5, t6, t7] -> comp01[0, t10532 = 0, i02_outer, t10534 = 0, i01_outer, t10536 = 0, i02_inner, t10529 = 0, i01_inner, t10538 = 0, i00 = t5, t10540 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i02 i01 i00  deapth of outer is:0 test : i02 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 3) {
            buf01[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = ((((((((buf00[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))] + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c9)*(int64)1052676)))]) + buf00[((int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32((int64(c9)*(int64)1052676)))])
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 128 L1 128
0- for 0 <= i02_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i00 < 3 | 0 | P
					comp01
Evaluation : 8.816000

{ comp01[t5, t6, t7] -> comp01[0, t10589 = 0, i02_outer, t10591 = 0, i01_outer, t10593 = 0, i02_inner, t10586 = 0, i01_inner, t10595 = 0, i00 = t5, t10597 = 0] : (t7 - i02_inner) mod 128 = 0 and (t6 - i01_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 <= t6 <= 1023 and 0 <= t7 <= 1023 and -127 + t7 <= 128i02_outer <= t7 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i02_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 0 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 0 ,0 1 0 0 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 1 ,0 0 1 2 ,
input00:1 0 0 0 ,0 1 0 2 ,0 0 1 2 ,

<legal>

original list
21.080000+16.451799+13.423000+15.775000+12.702900+9.246830+14.131100+10.451100+8.816000+4151.109863+
remaining list
8.816000+9.246830+10.451100+12.702900+NB explored schedules : 231
Best evaluation : 2.135990
Initial exec time : 2.532010
Initial evaluation : 2.434970
Search time : 303719 ms 
0- for 0 <= i00 < 3 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		2- for 0 <= i02 < 1024 | 0
			comp01

Generated Halide IR:
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024 * 3]
  allocate _comp01_b1[int32 * 1024 * 1024 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 1024) {
      for (c5, 0, 1024) {
        buf01[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = ((((((((buf00[((c5 + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))] + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32((int64(c3)*(int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)1052676)))]) + buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32((int64(c1)*(int64)1052676)))])
      }
    }
  }
}
Best schedule exec time : 2.216820
Speedup : 1.142181
