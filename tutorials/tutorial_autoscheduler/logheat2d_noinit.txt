
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      buf02[(c3 + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c3) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(c3 + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      buf02[(c3 + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c3) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(c3 + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      buf02[(c3 + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c3) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(c3 + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
    }
  }
}
 vars i00 i01  interchange : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      buf02[(c1 + int32((int64(c3)*(int64)1024)))] = ((buf00[(int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026)))] + buf00[(c1 + int32(((int64(c3)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026)))])*4))
    }
  }
}

-----------
Interchange L0  L1
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 1024 | 0
		comp02
Evaluation : 16.290199

{ comp02[t4, t5] -> comp02[0, t6 = 0, i01 = t5, t7 = 0, i00 = t4, t8 = 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }

input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
16.290199+0.702143+
remaining list
0.702143+16.290199+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      buf02[(c3 + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c3) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(c3 + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
    }
  }
}

-----------
Parallelize L0
0- for 0 <= i00 < 1024 | 0 | P
	1- for 0 <= i01 < 1024 | 0
		comp02
Evaluation : 0.504971

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }

input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      buf02[(c3 + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c3) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(c3 + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c3) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
    }
  }
}

-----------
Parallelize L1
0- for 0 <= i00 < 1024 | 0
	1- for 0 <= i01 < 1024 | 0 | P
		comp02
Evaluation : 127.934998

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }

input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
0.504971+127.934998+0.702143+
remaining list
0.504971+0.702143+127.934998+ Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 0.596046

{ comp02[t4, t5] -> comp02[0, t28 = 0, i00_outer, t30 = 0, i01_outer, t32 = 0, i00_inner, t25 = 0, i01_inner, t34 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 0.526190

{ comp02[t4, t5] -> comp02[0, t72 = 0, i00_outer, t74 = 0, i01_outer, t76 = 0, i00_inner, t69 = 0, i01_inner, t78 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 0.519991

{ comp02[t4, t5] -> comp02[0, t116 = 0, i00_outer, t118 = 0, i01_outer, t120 = 0, i00_inner, t113 = 0, i01_inner, t122 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 0.536919

{ comp02[t4, t5] -> comp02[0, t160 = 0, i00_outer, t162 = 0, i01_outer, t164 = 0, i00_inner, t157 = 0, i01_inner, t166 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 0.507116

{ comp02[t4, t5] -> comp02[0, t204 = 0, i00_outer, t206 = 0, i01_outer, t208 = 0, i00_inner, t201 = 0, i01_inner, t210 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 0.549793

{ comp02[t4, t5] -> comp02[0, t248 = 0, i00_outer, t250 = 0, i01_outer, t252 = 0, i00_inner, t245 = 0, i01_inner, t254 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 0.594139

{ comp02[t4, t5] -> comp02[0, t292 = 0, i00_outer, t294 = 0, i01_outer, t296 = 0, i00_inner, t289 = 0, i01_inner, t298 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 0.639915

{ comp02[t4, t5] -> comp02[0, t336 = 0, i00_outer, t338 = 0, i01_outer, t340 = 0, i00_inner, t333 = 0, i01_inner, t342 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 0.523090

{ comp02[t4, t5] -> comp02[0, t380 = 0, i00_outer, t382 = 0, i01_outer, t384 = 0, i00_inner, t377 = 0, i01_inner, t386 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
0.596046+0.526190+0.519991+0.536919+0.507116+0.549793+0.594139+0.639915+0.523090+0.504971+
remaining list
0.504971+0.507116+0.519991+0.523090+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 256) {
      unrolled (c5, 0, 4) {
        buf02[(((c3*4) + c5) + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(((c3*4) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*4) + c5)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(((c3*4) + c5) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*4) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*4) + c5)) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L1 4
0- for 0 <= i00 < 1024 | 0 | P
	1- for 0 <= i01_outer < 256 | 0
		2- for 0 <= i01_inner < 4 | 1
			comp02
Evaluation : 0.543833

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }


input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 128) {
      unrolled (c5, 0, 8) {
        buf02[(((c3*8) + c5) + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(((c3*8) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*8) + c5)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(((c3*8) + c5) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*8) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*8) + c5)) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L1 8
0- for 0 <= i00 < 1024 | 0 | P
	1- for 0 <= i01_outer < 128 | 0
		2- for 0 <= i01_inner < 8 | 1
			comp02
Evaluation : 0.545979

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }


input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 64) {
      unrolled (c5, 0, 16) {
        buf02[(((c3*16) + c5) + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(((c3*16) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*16) + c5)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(((c3*16) + c5) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*16) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*16) + c5)) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L1 16
0- for 0 <= i00 < 1024 | 0 | P
	1- for 0 <= i01_outer < 64 | 0
		2- for 0 <= i01_inner < 16 | 1
			comp02
Evaluation : 0.504971

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }


input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*16) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*16) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*16) + c7)*4) + c9) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*16) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*16) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 4
0- for 0 <= i00_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner_outer < 16 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 0.558138

{ comp02[t4, t5] -> comp02[0, t204 = 0, i00_outer, t206 = 0, i01_outer, t208 = 0, i00_inner, t201 = 0, i01_inner, t210 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*8) + c9) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 8
0- for 0 <= i00_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 0.427008

{ comp02[t4, t5] -> comp02[0, t204 = 0, i00_outer, t206 = 0, i01_outer, t208 = 0, i00_inner, t201 = 0, i01_inner, t210 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*4) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*4) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*4) + c7)*16) + c9) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*4) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*4) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 16
0- for 0 <= i00_outer < 16 | 0 | P
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner_outer < 4 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.581980

{ comp02[t4, t5] -> comp02[0, t204 = 0, i00_outer, t206 = 0, i01_outer, t208 = 0, i00_inner, t201 = 0, i01_inner, t210 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*32) + c7)*4) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= i00_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 32 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 0.771046

{ comp02[t4, t5] -> comp02[0, t116 = 0, i00_outer, t118 = 0, i01_outer, t120 = 0, i00_inner, t113 = 0, i01_inner, t122 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*16) + c7)*8) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= i00_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 16 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 0.594854

{ comp02[t4, t5] -> comp02[0, t116 = 0, i00_outer, t118 = 0, i01_outer, t120 = 0, i00_inner, t113 = 0, i01_inner, t122 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*16) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= i00_outer < 32 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.439882

{ comp02[t4, t5] -> comp02[0, t116 = 0, i00_outer, t118 = 0, i01_outer, t120 = 0, i00_inner, t113 = 0, i01_inner, t122 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*32) + c7)*4) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 32 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 0.776052

{ comp02[t4, t5] -> comp02[0, t380 = 0, i00_outer, t382 = 0, i01_outer, t384 = 0, i00_inner, t377 = 0, i01_inner, t386 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*16) + c7)*8) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 16 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 0.664949

{ comp02[t4, t5] -> comp02[0, t380 = 0, i00_outer, t382 = 0, i01_outer, t384 = 0, i00_inner, t377 = 0, i01_inner, t386 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*16) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.380993

{ comp02[t4, t5] -> comp02[0, t380 = 0, i00_outer, t382 = 0, i01_outer, t384 = 0, i00_inner, t377 = 0, i01_inner, t386 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 1.029010

{ comp02[t4, t5] -> comp02[0, t838 = 0, i00_outer, t840 = 0, i01_outer, t842 = 0, i00_inner, t835 = 0, i01_inner, t844 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 1.126050

{ comp02[t4, t5] -> comp02[0, t881 = 0, i00_outer, t883 = 0, i01_outer, t885 = 0, i00_inner, t878 = 0, i01_inner, t887 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 1.111980

{ comp02[t4, t5] -> comp02[0, t924 = 0, i00_outer, t926 = 0, i01_outer, t928 = 0, i00_inner, t921 = 0, i01_inner, t930 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 1.322030

{ comp02[t4, t5] -> comp02[0, t967 = 0, i00_outer, t969 = 0, i01_outer, t971 = 0, i00_inner, t964 = 0, i01_inner, t973 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 1.307010

{ comp02[t4, t5] -> comp02[0, t1010 = 0, i00_outer, t1012 = 0, i01_outer, t1014 = 0, i00_inner, t1007 = 0, i01_inner, t1016 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 1.210930

{ comp02[t4, t5] -> comp02[0, t1053 = 0, i00_outer, t1055 = 0, i01_outer, t1057 = 0, i00_inner, t1050 = 0, i01_inner, t1059 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 1.123910

{ comp02[t4, t5] -> comp02[0, t1096 = 0, i00_outer, t1098 = 0, i01_outer, t1100 = 0, i00_inner, t1093 = 0, i01_inner, t1102 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 16 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 1.343010

{ comp02[t4, t5] -> comp02[0, t1139 = 0, i00_outer, t1141 = 0, i01_outer, t1143 = 0, i00_inner, t1136 = 0, i01_inner, t1145 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 1.248120

{ comp02[t4, t5] -> comp02[0, t1182 = 0, i00_outer, t1184 = 0, i01_outer, t1186 = 0, i00_inner, t1179 = 0, i01_inner, t1188 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
1.029010+1.126050+1.111980+1.322030+1.307010+1.210930+1.123910+1.343010+1.248120+0.702143+
remaining list
0.702143+1.029010+1.111980+1.123910+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 256) {
      unrolled (c5, 0, 4) {
        buf02[(((c3*4) + c5) + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(((c3*4) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*4) + c5)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(((c3*4) + c5) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*4) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*4) + c5)) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
      }
    }
  }
}

-----------
Unrolling L1 4
0- for 0 <= i00 < 1024 | 0
	1- for 0 <= i01_outer < 256 | 0
		2- for 0 <= i01_inner < 4 | 1
			comp02
Evaluation : 0.921011

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }


input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 128) {
      unrolled (c5, 0, 8) {
        buf02[(((c3*8) + c5) + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(((c3*8) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*8) + c5)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(((c3*8) + c5) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*8) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*8) + c5)) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
      }
    }
  }
}

-----------
Unrolling L1 8
0- for 0 <= i00 < 1024 | 0
	1- for 0 <= i01_outer < 128 | 0
		2- for 0 <= i01_inner < 8 | 1
			comp02
Evaluation : 1.836060

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }


input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 64) {
      unrolled (c5, 0, 16) {
        buf02[(((c3*16) + c5) + int32((int64(c1)*(int64)1024)))] = ((buf00[(int32((int64(((c3*16) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*16) + c5)) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026)))] + buf00[(((c3*16) + c5) + int32(((int64(c1)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*16) + c5)) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*16) + c5)) + (int64)1)) + int32((int64(c1)*(int64)1026)))])*4))
      }
    }
  }
}

-----------
Unrolling L1 16
0- for 0 <= i00 < 1024 | 0
	1- for 0 <= i01_outer < 64 | 0
		2- for 0 <= i01_inner < 16 | 1
			comp02
Evaluation : 0.635147

{ comp02[t4, t5] -> comp02[0, 0, i00 = t4, 0, i01 = t5, 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }


input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*4) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 1.462940

{ comp02[t4, t5] -> comp02[0, t838 = 0, i00_outer, t840 = 0, i01_outer, t842 = 0, i00_inner, t835 = 0, i01_inner, t844 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*4) + c7)*8) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 4 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 1.905920

{ comp02[t4, t5] -> comp02[0, t838 = 0, i00_outer, t840 = 0, i01_outer, t842 = 0, i00_inner, t835 = 0, i01_inner, t844 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*2) + c7)*16) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 2 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 2.054930

{ comp02[t4, t5] -> comp02[0, t838 = 0, i00_outer, t840 = 0, i01_outer, t842 = 0, i00_inner, t835 = 0, i01_inner, t844 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*32) + c7)*4) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 32 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 1.933100

{ comp02[t4, t5] -> comp02[0, t924 = 0, i00_outer, t926 = 0, i01_outer, t928 = 0, i00_inner, t921 = 0, i01_inner, t930 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*16) + c7)*8) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 16 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 2.238040

{ comp02[t4, t5] -> comp02[0, t924 = 0, i00_outer, t926 = 0, i01_outer, t928 = 0, i00_inner, t921 = 0, i01_inner, t930 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*16) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.951052

{ comp02[t4, t5] -> comp02[0, t924 = 0, i00_outer, t926 = 0, i01_outer, t928 = 0, i00_inner, t921 = 0, i01_inner, t930 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*4) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 1.486060

{ comp02[t4, t5] -> comp02[0, t1096 = 0, i00_outer, t1098 = 0, i01_outer, t1100 = 0, i00_inner, t1093 = 0, i01_inner, t1102 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*4) + c7)*8) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 4 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 2.250190

{ comp02[t4, t5] -> comp02[0, t1096 = 0, i00_outer, t1098 = 0, i01_outer, t1100 = 0, i00_inner, t1093 = 0, i01_inner, t1102 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*2) + c7)*16) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 2 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 1.919030

{ comp02[t4, t5] -> comp02[0, t1096 = 0, i00_outer, t1098 = 0, i01_outer, t1100 = 0, i00_inner, t1093 = 0, i01_inner, t1102 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 1.003980

{ comp02[t4, t5] -> comp02[0, t1627 = 0, i00_outer, t1629 = 0, i01_outer, t1631 = 0, i00_inner, t1624 = 0, i01_inner, t1633 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 1.160140

{ comp02[t4, t5] -> comp02[0, t1671 = 0, i00_outer, t1673 = 0, i01_outer, t1675 = 0, i00_inner, t1668 = 0, i01_inner, t1677 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 1.181130

{ comp02[t4, t5] -> comp02[0, t1715 = 0, i00_outer, t1717 = 0, i01_outer, t1719 = 0, i00_inner, t1712 = 0, i01_inner, t1721 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 0.898123

{ comp02[t4, t5] -> comp02[0, t1759 = 0, i00_outer, t1761 = 0, i01_outer, t1763 = 0, i00_inner, t1756 = 0, i01_inner, t1765 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 1.088140

{ comp02[t4, t5] -> comp02[0, t1803 = 0, i00_outer, t1805 = 0, i01_outer, t1807 = 0, i00_inner, t1800 = 0, i01_inner, t1809 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 1.298900

{ comp02[t4, t5] -> comp02[0, t1847 = 0, i00_outer, t1849 = 0, i01_outer, t1851 = 0, i00_inner, t1844 = 0, i01_inner, t1853 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          buf02[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*32) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*32) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				comp02
Evaluation : 0.946045

{ comp02[t4, t5] -> comp02[0, t1891 = 0, i00_outer, t1893 = 0, i01_outer, t1895 = 0, i00_inner, t1888 = 0, i01_inner, t1897 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          buf02[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*64) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*64) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 16 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				comp02
Evaluation : 1.496790

{ comp02[t4, t5] -> comp02[0, t1935 = 0, i00_outer, t1937 = 0, i01_outer, t1939 = 0, i00_inner, t1932 = 0, i01_inner, t1941 = 0] : (-t5 + i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -63 + t5 <= 64i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i00 i01  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf02[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c3*128) + c7)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((c3*128) + c7) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				comp02
Evaluation : 0.917912

{ comp02[t4, t5] -> comp02[0, t1979 = 0, i00_outer, t1981 = 0, i01_outer, t1983 = 0, i00_inner, t1976 = 0, i01_inner, t1985 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
1.003980+1.160140+1.181130+0.898123+1.088140+1.298900+0.946045+1.496790+0.917912+127.934998+
remaining list
0.898123+0.917912+0.946045+1.003980+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*4) + c9) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 0.808954

{ comp02[t4, t5] -> comp02[0, t1759 = 0, i00_outer, t1761 = 0, i01_outer, t1763 = 0, i00_inner, t1756 = 0, i01_inner, t1765 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*4) + c7)*8) + c9) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner_outer < 4 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 0.803947

{ comp02[t4, t5] -> comp02[0, t1759 = 0, i00_outer, t1761 = 0, i01_outer, t1763 = 0, i00_inner, t1756 = 0, i01_inner, t1765 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*2) + c7)*16) + c9) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*64) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*64) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= i00_outer < 16 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner_outer < 2 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.822067

{ comp02[t4, t5] -> comp02[0, t1759 = 0, i00_outer, t1761 = 0, i01_outer, t1763 = 0, i00_inner, t1756 = 0, i01_inner, t1765 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t4 <= 64i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*32) + c7)*4) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*32) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 32 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 1.168010

{ comp02[t4, t5] -> comp02[0, t1979 = 0, i00_outer, t1981 = 0, i01_outer, t1983 = 0, i00_inner, t1976 = 0, i01_inner, t1985 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*16) + c7)*8) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*16) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 16 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 0.946999

{ comp02[t4, t5] -> comp02[0, t1979 = 0, i00_outer, t1981 = 0, i01_outer, t1983 = 0, i00_inner, t1976 = 0, i01_inner, t1985 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*16) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.675917

{ comp02[t4, t5] -> comp02[0, t1979 = 0, i00_outer, t1981 = 0, i01_outer, t1983 = 0, i00_inner, t1976 = 0, i01_inner, t1985 = 0] : (-t5 + i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -127 + t5 <= 128i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*4) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 0.705957

{ comp02[t4, t5] -> comp02[0, t1891 = 0, i00_outer, t1893 = 0, i01_outer, t1895 = 0, i00_inner, t1888 = 0, i01_inner, t1897 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*4) + c7)*8) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 4 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 0.703096

{ comp02[t4, t5] -> comp02[0, t1891 = 0, i00_outer, t1893 = 0, i01_outer, t1895 = 0, i00_inner, t1888 = 0, i01_inner, t1897 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*2) + c7)*16) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 2 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.700951

{ comp02[t4, t5] -> comp02[0, t1891 = 0, i00_outer, t1893 = 0, i01_outer, t1895 = 0, i00_inner, t1888 = 0, i01_inner, t1897 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t4 <= 128i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*4) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*4) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 4 | 1
					comp02
Evaluation : 0.859976

{ comp02[t4, t5] -> comp02[0, t1627 = 0, i00_outer, t1629 = 0, i01_outer, t1631 = 0, i00_inner, t1624 = 0, i01_inner, t1633 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*4) + c7)*8) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*4) + c7)*8) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 4 | 0
				4- for 0 <= i01_inner_inner < 8 | 1
					comp02
Evaluation : 1.350880

{ comp02[t4, t5] -> comp02[0, t1627 = 0, i00_outer, t1629 = 0, i01_outer, t1631 = 0, i00_inner, t1624 = 0, i01_inner, t1633 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*2) + c7)*16) + c9) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*32) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*2) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*32) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= i00_outer < 32 | 0
	1- for 0 <= i01_outer < 32 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner_outer < 2 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02
Evaluation : 0.935078

{ comp02[t4, t5] -> comp02[0, t1627 = 0, i00_outer, t1629 = 0, i01_outer, t1631 = 0, i00_inner, t1624 = 0, i01_inner, t1633 = 0] : (-t5 + i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t4 <= 32i00_outer <= t4 and -31 + t5 <= 32i01_outer <= t5 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      buf02[(c1 + int32((int64(c3)*(int64)1024)))] = ((buf00[(int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026)))] + buf00[(c1 + int32(((int64(c3)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026)))])*4))
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
0- for 0 <= i01 < 1024 | 0 | P
	1- for 0 <= i00 < 1024 | 0
		comp02
Evaluation : 4.372840

{ comp02[t4, t5] -> comp02[0, t6 = 0, i01 = t5, t7 = 0, i00 = t4, t8 = 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }

input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      buf02[(c1 + int32((int64(c3)*(int64)1024)))] = ((buf00[(int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026)))] + buf00[(c1 + int32(((int64(c3)*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026)))])*4))
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
0- for 0 <= i01 < 1024 | 0
	1- for 0 <= i00 < 1024 | 0 | P
		comp02
Evaluation : 184.992004

{ comp02[t4, t5] -> comp02[0, t6 = 0, i01 = t5, t7 = 0, i00 = t4, t8 = 0] : 0 <= t4 <= 1023 and 0 <= t5 <= 1023 }

input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
4.372840+184.992004+16.290199+
remaining list
4.372840+16.290199+184.992004+ Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= i01_outer < 32 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 1.274820

{ comp02[t4, t5] -> comp02[0, t2501 = 0, i01_outer, t2503 = 0, i00_outer, t2505 = 0, i01_inner, t2498 = 0, i00_inner, t2507 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= i01_outer < 32 | 0 | P
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 1.477000

{ comp02[t4, t5] -> comp02[0, t2549 = 0, i01_outer, t2551 = 0, i00_outer, t2553 = 0, i01_inner, t2546 = 0, i00_inner, t2555 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= i01_outer < 32 | 0 | P
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 1.641990

{ comp02[t4, t5] -> comp02[0, t2597 = 0, i01_outer, t2599 = 0, i00_outer, t2601 = 0, i01_inner, t2594 = 0, i00_inner, t2603 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= i01_outer < 16 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 1.427170

{ comp02[t4, t5] -> comp02[0, t2645 = 0, i01_outer, t2647 = 0, i00_outer, t2649 = 0, i01_inner, t2642 = 0, i00_inner, t2651 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= i01_outer < 16 | 0 | P
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 1.508000

{ comp02[t4, t5] -> comp02[0, t2693 = 0, i01_outer, t2695 = 0, i00_outer, t2697 = 0, i01_inner, t2690 = 0, i00_inner, t2699 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= i01_outer < 16 | 0 | P
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 1.479860

{ comp02[t4, t5] -> comp02[0, t2741 = 0, i01_outer, t2743 = 0, i00_outer, t2745 = 0, i01_inner, t2738 = 0, i00_inner, t2747 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 1.506090

{ comp02[t4, t5] -> comp02[0, t2789 = 0, i01_outer, t2791 = 0, i00_outer, t2793 = 0, i01_inner, t2786 = 0, i00_inner, t2795 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 1.387830

{ comp02[t4, t5] -> comp02[0, t2837 = 0, i01_outer, t2839 = 0, i00_outer, t2841 = 0, i01_inner, t2834 = 0, i00_inner, t2843 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 1.436000

{ comp02[t4, t5] -> comp02[0, t2885 = 0, i01_outer, t2887 = 0, i00_outer, t2889 = 0, i01_inner, t2882 = 0, i00_inner, t2891 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
1.274820+1.477000+1.641990+1.427170+1.508000+1.479860+1.506090+1.387830+1.436000+4.372840+
remaining list
1.274820+1.387830+1.427170+1.436000+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 32 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.250030

{ comp02[t4, t5] -> comp02[0, t2501 = 0, i01_outer, t2503 = 0, i00_outer, t2505 = 0, i01_inner, t2498 = 0, i00_inner, t2507 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 32 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.291990

{ comp02[t4, t5] -> comp02[0, t2501 = 0, i01_outer, t2503 = 0, i00_outer, t2505 = 0, i01_inner, t2498 = 0, i00_inner, t2507 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 32 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.276020

{ comp02[t4, t5] -> comp02[0, t2501 = 0, i01_outer, t2503 = 0, i00_outer, t2505 = 0, i01_inner, t2498 = 0, i00_inner, t2507 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 16 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.430990

{ comp02[t4, t5] -> comp02[0, t2837 = 0, i01_outer, t2839 = 0, i00_outer, t2841 = 0, i01_inner, t2834 = 0, i00_inner, t2843 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.356840

{ comp02[t4, t5] -> comp02[0, t2837 = 0, i01_outer, t2839 = 0, i00_outer, t2841 = 0, i01_inner, t2834 = 0, i00_inner, t2843 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.714940

{ comp02[t4, t5] -> comp02[0, t2837 = 0, i01_outer, t2839 = 0, i00_outer, t2841 = 0, i01_inner, t2834 = 0, i00_inner, t2843 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 16 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.535890

{ comp02[t4, t5] -> comp02[0, t2645 = 0, i01_outer, t2647 = 0, i00_outer, t2649 = 0, i01_inner, t2642 = 0, i00_inner, t2651 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 16 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.230960

{ comp02[t4, t5] -> comp02[0, t2645 = 0, i01_outer, t2647 = 0, i00_outer, t2649 = 0, i01_inner, t2642 = 0, i00_inner, t2651 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 16 | 0 | P
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.290080

{ comp02[t4, t5] -> comp02[0, t2645 = 0, i01_outer, t2647 = 0, i00_outer, t2649 = 0, i01_inner, t2642 = 0, i00_inner, t2651 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*32) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*32) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*32) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*32) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 32 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.472000

{ comp02[t4, t5] -> comp02[0, t2885 = 0, i01_outer, t2887 = 0, i00_outer, t2889 = 0, i01_inner, t2882 = 0, i00_inner, t2891 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*16) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*16) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 16 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.595020

{ comp02[t4, t5] -> comp02[0, t2885 = 0, i01_outer, t2887 = 0, i00_outer, t2889 = 0, i01_inner, t2882 = 0, i00_inner, t2891 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*8) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= i01_outer < 8 | 0 | P
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.562830

{ comp02[t4, t5] -> comp02[0, t2885 = 0, i01_outer, t2887 = 0, i00_outer, t2889 = 0, i01_inner, t2882 = 0, i00_inner, t2891 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 127 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 4.206180

{ comp02[t4, t5] -> comp02[0, t3449 = 0, i01_outer, t3451 = 0, i00_outer, t3453 = 0, i01_inner, t3446 = 0, i00_inner, t3455 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 64
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 4.514930

{ comp02[t4, t5] -> comp02[0, t3496 = 0, i01_outer, t3498 = 0, i00_outer, t3500 = 0, i01_inner, t3493 = 0, i00_inner, t3502 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 128
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 5.312920

{ comp02[t4, t5] -> comp02[0, t3543 = 0, i01_outer, t3545 = 0, i00_outer, t3547 = 0, i01_inner, t3540 = 0, i00_inner, t3549 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 4.204990

{ comp02[t4, t5] -> comp02[0, t3590 = 0, i01_outer, t3592 = 0, i00_outer, t3594 = 0, i01_inner, t3587 = 0, i00_inner, t3596 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 64
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 4.848960

{ comp02[t4, t5] -> comp02[0, t3637 = 0, i01_outer, t3639 = 0, i00_outer, t3641 = 0, i01_inner, t3634 = 0, i00_inner, t3643 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 128
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 5.221130

{ comp02[t4, t5] -> comp02[0, t3684 = 0, i01_outer, t3686 = 0, i00_outer, t3688 = 0, i01_inner, t3681 = 0, i00_inner, t3690 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 4.081010

{ comp02[t4, t5] -> comp02[0, t3731 = 0, i01_outer, t3733 = 0, i00_outer, t3735 = 0, i01_inner, t3728 = 0, i00_inner, t3737 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 4.305120

{ comp02[t4, t5] -> comp02[0, t3778 = 0, i01_outer, t3780 = 0, i00_outer, t3782 = 0, i01_inner, t3775 = 0, i00_inner, t3784 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 128
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 8 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 5.075930

{ comp02[t4, t5] -> comp02[0, t3825 = 0, i01_outer, t3827 = 0, i00_outer, t3829 = 0, i01_inner, t3822 = 0, i00_inner, t3831 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
4.206180+4.514930+5.312920+4.204990+4.848960+5.221130+4.081010+4.305120+5.075930+16.290199+
remaining list
4.081010+4.204990+4.206180+4.305120+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 4.163980

{ comp02[t4, t5] -> comp02[0, t3731 = 0, i01_outer, t3733 = 0, i00_outer, t3735 = 0, i01_inner, t3728 = 0, i00_inner, t3737 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 4.286050

{ comp02[t4, t5] -> comp02[0, t3731 = 0, i01_outer, t3733 = 0, i00_outer, t3735 = 0, i01_inner, t3728 = 0, i00_inner, t3737 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 4.136800

{ comp02[t4, t5] -> comp02[0, t3731 = 0, i01_outer, t3733 = 0, i00_outer, t3735 = 0, i01_inner, t3728 = 0, i00_inner, t3737 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 4.308940

{ comp02[t4, t5] -> comp02[0, t3590 = 0, i01_outer, t3592 = 0, i00_outer, t3594 = 0, i01_inner, t3587 = 0, i00_inner, t3596 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 4.357100

{ comp02[t4, t5] -> comp02[0, t3590 = 0, i01_outer, t3592 = 0, i00_outer, t3594 = 0, i01_inner, t3587 = 0, i00_inner, t3596 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 4.217150

{ comp02[t4, t5] -> comp02[0, t3590 = 0, i01_outer, t3592 = 0, i00_outer, t3594 = 0, i01_inner, t3587 = 0, i00_inner, t3596 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 4.221200

{ comp02[t4, t5] -> comp02[0, t3449 = 0, i01_outer, t3451 = 0, i00_outer, t3453 = 0, i01_inner, t3446 = 0, i00_inner, t3455 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 4.553080

{ comp02[t4, t5] -> comp02[0, t3449 = 0, i01_outer, t3451 = 0, i00_outer, t3453 = 0, i01_inner, t3446 = 0, i00_inner, t3455 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 4.364010

{ comp02[t4, t5] -> comp02[0, t3449 = 0, i01_outer, t3451 = 0, i00_outer, t3453 = 0, i01_inner, t3446 = 0, i00_inner, t3455 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 16 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 4.273180

{ comp02[t4, t5] -> comp02[0, t3778 = 0, i01_outer, t3780 = 0, i00_outer, t3782 = 0, i01_inner, t3775 = 0, i00_inner, t3784 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 4.627940

{ comp02[t4, t5] -> comp02[0, t3778 = 0, i01_outer, t3780 = 0, i00_outer, t3782 = 0, i01_inner, t3775 = 0, i00_inner, t3784 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 16 | 0
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 4.540920

{ comp02[t4, t5] -> comp02[0, t3778 = 0, i01_outer, t3780 = 0, i00_outer, t3782 = 0, i01_inner, t3775 = 0, i00_inner, t3784 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 1.533030

{ comp02[t4, t5] -> comp02[0, t4376 = 0, i01_outer, t4378 = 0, i00_outer, t4380 = 0, i01_inner, t4373 = 0, i00_inner, t4382 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 16 | 0 | P
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 1.847030

{ comp02[t4, t5] -> comp02[0, t4424 = 0, i01_outer, t4426 = 0, i00_outer, t4428 = 0, i01_inner, t4421 = 0, i00_inner, t4430 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          buf02[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 8 | 0 | P
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 2.104040

{ comp02[t4, t5] -> comp02[0, t4472 = 0, i01_outer, t4474 = 0, i00_outer, t4476 = 0, i01_inner, t4469 = 0, i00_inner, t4478 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 1.332040

{ comp02[t4, t5] -> comp02[0, t4520 = 0, i01_outer, t4522 = 0, i00_outer, t4524 = 0, i01_inner, t4517 = 0, i00_inner, t4526 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 16 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 1.488920

{ comp02[t4, t5] -> comp02[0, t4568 = 0, i01_outer, t4570 = 0, i00_outer, t4572 = 0, i01_inner, t4565 = 0, i00_inner, t4574 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          buf02[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 8 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 1.963140

{ comp02[t4, t5] -> comp02[0, t4616 = 0, i01_outer, t4618 = 0, i00_outer, t4620 = 0, i01_inner, t4613 = 0, i00_inner, t4622 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 32 | 0
				comp02
Evaluation : 1.477960

{ comp02[t4, t5] -> comp02[0, t4664 = 0, i01_outer, t4666 = 0, i00_outer, t4668 = 0, i01_inner, t4661 = 0, i00_inner, t4670 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 16 | 0 | P
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 64 | 0
				comp02
Evaluation : 1.544000

{ comp02[t4, t5] -> comp02[0, t4712 = 0, i01_outer, t4714 = 0, i00_outer, t4716 = 0, i01_inner, t4709 = 0, i00_inner, t4718 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 63 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
 Tiling 2 loop names: i01 i00  deapth of outer is:0 test : i01 & i00
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf02[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026)))])*4))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 8 | 0 | P
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner < 128 | 0
				comp02
Evaluation : 1.643900

{ comp02[t4, t5] -> comp02[0, t4760 = 0, i01_outer, t4762 = 0, i00_outer, t4764 = 0, i01_inner, t4757 = 0, i00_inner, t4766 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 128 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -127 + t4 <= 128i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 127 }



input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

original list
1.533030+1.847030+2.104040+1.332040+1.488920+1.963140+1.477960+1.544000+1.643900+184.992004+
remaining list
1.332040+1.477960+1.488920+1.533030+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.336100

{ comp02[t4, t5] -> comp02[0, t4520 = 0, i01_outer, t4522 = 0, i00_outer, t4524 = 0, i01_inner, t4517 = 0, i00_inner, t4526 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.385930

{ comp02[t4, t5] -> comp02[0, t4520 = 0, i01_outer, t4522 = 0, i00_outer, t4524 = 0, i01_inner, t4517 = 0, i00_inner, t4526 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.348020

{ comp02[t4, t5] -> comp02[0, t4520 = 0, i01_outer, t4522 = 0, i00_outer, t4524 = 0, i01_inner, t4517 = 0, i00_inner, t4526 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.227860

{ comp02[t4, t5] -> comp02[0, t4664 = 0, i01_outer, t4666 = 0, i00_outer, t4668 = 0, i01_inner, t4661 = 0, i00_inner, t4670 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.313210

{ comp02[t4, t5] -> comp02[0, t4664 = 0, i01_outer, t4666 = 0, i00_outer, t4668 = 0, i01_inner, t4661 = 0, i00_inner, t4670 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*128) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*128) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 8 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 128 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.672980

{ comp02[t4, t5] -> comp02[0, t4664 = 0, i01_outer, t4666 = 0, i00_outer, t4668 = 0, i01_inner, t4661 = 0, i00_inner, t4670 = 0] : (t5 - i01_inner) mod 128 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -127 + t5 <= 128i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 127 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*16) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 64
Unrolling L3 4
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 16 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 16 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.508950

{ comp02[t4, t5] -> comp02[0, t4568 = 0, i01_outer, t4570 = 0, i00_outer, t4572 = 0, i01_inner, t4565 = 0, i00_inner, t4574 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 64
Unrolling L3 8
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 16 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.508000

{ comp02[t4, t5] -> comp02[0, t4568 = 0, i01_outer, t4570 = 0, i00_outer, t4572 = 0, i01_inner, t4565 = 0, i00_inner, t4574 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*64) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*64) + c5) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 64
Unrolling L3 16
0- for 0 <= i01_outer < 16 | 0
	1- for 0 <= i00_outer < 16 | 0 | P
		2- for 0 <= i01_inner < 64 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.638890

{ comp02[t4, t5] -> comp02[0, t4568 = 0, i01_outer, t4570 = 0, i00_outer, t4572 = 0, i01_inner, t4565 = 0, i00_inner, t4574 = 0] : (t5 - i01_inner) mod 64 = 0 and (t4 - i00_inner) mod 64 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -63 + t5 <= 64i01_outer <= t5 and -63 + t4 <= 64i00_outer <= t4 and 0 <= i01_inner <= 63 and 0 <= i00_inner <= 63 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*8) + c7)*4) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 8 | 0
				4- for 0 <= i00_inner_inner < 4 | 1
					comp02
Evaluation : 1.638170

{ comp02[t4, t5] -> comp02[0, t4376 = 0, i01_outer, t4378 = 0, i00_outer, t4380 = 0, i01_inner, t4373 = 0, i00_inner, t4382 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*4) + c7)*8) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 4 | 0
				4- for 0 <= i00_inner_inner < 8 | 1
					comp02
Evaluation : 1.590010

{ comp02[t4, t5] -> comp02[0, t4376 = 0, i01_outer, t4378 = 0, i00_outer, t4380 = 0, i01_inner, t4373 = 0, i00_inner, t4382 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            buf02[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = ((buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((c1*32) + c5)) + (int64)2)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))] + buf00[(((c1*32) + c5) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((((c3*2) + c7)*16) + c9))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= i01_outer < 32 | 0
	1- for 0 <= i00_outer < 32 | 0 | P
		2- for 0 <= i01_inner < 32 | 0
			3- for 0 <= i00_inner_outer < 2 | 0
				4- for 0 <= i00_inner_inner < 16 | 1
					comp02
Evaluation : 1.594070

{ comp02[t4, t5] -> comp02[0, t4376 = 0, i01_outer, t4378 = 0, i00_outer, t4380 = 0, i01_inner, t4373 = 0, i00_inner, t4382 = 0] : (t5 - i01_inner) mod 32 = 0 and (t4 - i00_inner) mod 32 = 0 and 0 <= t4 <= 1023 and 0 <= t5 <= 1023 and -31 + t5 <= 32i01_outer <= t5 and -31 + t4 <= 32i00_outer <= t4 and 0 <= i01_inner <= 31 and 0 <= i00_inner <= 31 }




input00:1 0 1 ,0 1 1 ,
input00:1 0 1 ,0 1 2 ,
input00:1 0 1 ,0 1 0 ,
input00:1 0 2 ,0 1 1 ,
input00:1 0 0 ,0 1 1 ,

<legal>
NB explored schedules : 131
Best evaluation : 0.380993
Initial exec time : 0.684023
Initial evaluation : 0.702143
Search time : 151362 ms 
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner_outer < 8 | 0
				4- for 0 <= i01_inner_inner < 16 | 1
					comp02

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 1024]
  allocate _comp02_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf02[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = ((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]*3) + ((((buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)2)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))] + buf00[(((((c3*8) + c7)*16) + c9) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)1026)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32(((int64(((c1*128) + c5))*(int64)1026) + (int64)2052)))]) + buf00[(int32((int64(((((c3*8) + c7)*16) + c9)) + (int64)1)) + int32((int64(((c1*128) + c5))*(int64)1026)))])*4))
          }
        }
      }
    }
  }
}
Best schedule exec time : 0.550985
Speedup : 1.241455
