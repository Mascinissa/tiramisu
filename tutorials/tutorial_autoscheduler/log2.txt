
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}
 vars y x  interchange : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c1 + int32((int64(c3)*(int64)1024)))] = (((((input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c1 + int32((int64(c3)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Interchange L0  L1
0- for 0 <= x < 1024 | 0
	1- for 0 <= y < 1024 | 0
		RGB2Gray
Evaluation : 36.063900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t7 = 0, x = t6, t8 = 0, y = t5, t9 = 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
36.063900+1.248480+
remaining list
1.248480+36.063900+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Parallelize L0
0- for 0 <= y < 1024 | 0 | P
	1- for 0 <= x < 1024 | 0
		RGB2Gray
Evaluation : 1.231430

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Parallelize L1
0- for 0 <= y < 1024 | 0
	1- for 0 <= x < 1024 | 0 | P
		RGB2Gray
Evaluation : 157.110992

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
1.231430+157.110992+1.248480+
remaining list
1.231430+1.248480+157.110992+ Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.228930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t29 = 0, y_outer, t31 = 0, x_outer, t33 = 0, y_inner, t26 = 0, x_inner, t35 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.205330

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t72 = 0, y_outer, t74 = 0, x_outer, t76 = 0, y_inner, t69 = 0, x_inner, t78 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.214980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t115 = 0, y_outer, t117 = 0, x_outer, t119 = 0, y_inner, t112 = 0, x_inner, t121 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.286510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t158 = 0, y_outer, t160 = 0, x_outer, t162 = 0, y_inner, t155 = 0, x_inner, t164 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.214030

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t201 = 0, y_outer, t203 = 0, x_outer, t205 = 0, y_inner, t198 = 0, x_inner, t207 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.206640

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t244 = 0, y_outer, t246 = 0, x_outer, t248 = 0, y_inner, t241 = 0, x_inner, t250 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.241560

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t287 = 0, y_outer, t289 = 0, x_outer, t291 = 0, y_inner, t284 = 0, x_inner, t293 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.214500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t330 = 0, y_outer, t332 = 0, x_outer, t334 = 0, y_inner, t327 = 0, x_inner, t336 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.167060

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t373 = 0, y_outer, t375 = 0, x_outer, t377 = 0, y_inner, t370 = 0, x_inner, t379 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
1.228930+1.205330+1.214980+1.286510+1.214030+1.206640+1.241560+1.214500+1.167060+1.231430+
remaining list
1.167060+1.205330+1.206640+1.214030+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.761910

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t373 = 0, y_outer, t375 = 0, x_outer, t377 = 0, y_inner, t370 = 0, x_inner, t379 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.652360

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t373 = 0, y_outer, t375 = 0, x_outer, t377 = 0, y_inner, t370 = 0, x_inner, t379 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.255990

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t373 = 0, y_outer, t375 = 0, x_outer, t377 = 0, y_inner, t370 = 0, x_inner, t379 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 4
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.764540

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t72 = 0, y_outer, t74 = 0, x_outer, t76 = 0, y_inner, t69 = 0, x_inner, t78 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 8
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.830580

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t72 = 0, y_outer, t74 = 0, x_outer, t76 = 0, y_inner, t69 = 0, x_inner, t78 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 16
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.727940

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t72 = 0, y_outer, t74 = 0, x_outer, t76 = 0, y_inner, t69 = 0, x_inner, t78 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.965520

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t244 = 0, y_outer, t246 = 0, x_outer, t248 = 0, y_inner, t241 = 0, x_inner, t250 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.676920

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t244 = 0, y_outer, t246 = 0, x_outer, t248 = 0, y_inner, t241 = 0, x_inner, t250 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.374960

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t244 = 0, y_outer, t246 = 0, x_outer, t248 = 0, y_inner, t241 = 0, x_inner, t250 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 2.895120

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t201 = 0, y_outer, t203 = 0, x_outer, t205 = 0, y_inner, t198 = 0, x_inner, t207 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.739500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t201 = 0, y_outer, t203 = 0, x_outer, t205 = 0, y_inner, t198 = 0, x_inner, t207 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.226070

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t201 = 0, y_outer, t203 = 0, x_outer, t205 = 0, y_inner, t198 = 0, x_inner, t207 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 2.323510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t872 = 0, y_outer, t874 = 0, x_outer, t876 = 0, y_inner, t869 = 0, x_inner, t878 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 2.104520

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t914 = 0, y_outer, t916 = 0, x_outer, t918 = 0, y_inner, t911 = 0, x_inner, t920 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 2.079490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t956 = 0, y_outer, t958 = 0, x_outer, t960 = 0, y_inner, t953 = 0, x_inner, t962 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 2.238040

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t998 = 0, y_outer, t1000 = 0, x_outer, t1002 = 0, y_inner, t995 = 0, x_inner, t1004 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 2.119540

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1040 = 0, y_outer, t1042 = 0, x_outer, t1044 = 0, y_inner, t1037 = 0, x_inner, t1046 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 2.077460

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1082 = 0, y_outer, t1084 = 0, x_outer, t1086 = 0, y_inner, t1079 = 0, x_inner, t1088 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 2.197150

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1124 = 0, y_outer, t1126 = 0, x_outer, t1128 = 0, y_inner, t1121 = 0, x_inner, t1130 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 2.150890

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1166 = 0, y_outer, t1168 = 0, x_outer, t1170 = 0, y_inner, t1163 = 0, x_inner, t1172 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.989010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1208 = 0, y_outer, t1210 = 0, x_outer, t1212 = 0, y_inner, t1205 = 0, x_inner, t1214 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
2.323510+2.104520+2.079490+2.238040+2.119540+2.077460+2.197150+2.150890+1.989010+1.248480+
remaining list
1.248480+1.989010+2.077460+2.079490+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 256) {
      unrolled (c5, 0, 4) {
        RGB2Gray_buf[(((c3*4) + c5) + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((((c3*4) + c5) + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*4) + c5) + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*4) + c5) + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
      }
    }
  }
}

-----------
Unrolling L1 4
0- for 0 <= y < 1024 | 0
	1- for 0 <= x_outer < 256 | 0
		2- for 0 <= x_inner < 4 | 1
			RGB2Gray
Evaluation : 1.531000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }


input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 128) {
      unrolled (c5, 0, 8) {
        RGB2Gray_buf[(((c3*8) + c5) + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((((c3*8) + c5) + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*8) + c5) + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*8) + c5) + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
      }
    }
  }
}

-----------
Unrolling L1 8
0- for 0 <= y < 1024 | 0
	1- for 0 <= x_outer < 128 | 0
		2- for 0 <= x_inner < 8 | 1
			RGB2Gray
Evaluation : 1.781580

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }


input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 64) {
      unrolled (c5, 0, 16) {
        RGB2Gray_buf[(((c3*16) + c5) + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((((c3*16) + c5) + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*16) + c5) + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*16) + c5) + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
      }
    }
  }
}

-----------
Unrolling L1 16
0- for 0 <= y < 1024 | 0
	1- for 0 <= x_outer < 64 | 0
		2- for 0 <= x_inner < 16 | 1
			RGB2Gray
Evaluation : 1.215460

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }


input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.972930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1208 = 0, y_outer, t1210 = 0, x_outer, t1212 = 0, y_inner, t1205 = 0, x_inner, t1214 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.037430

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1208 = 0, y_outer, t1210 = 0, x_outer, t1212 = 0, y_inner, t1205 = 0, x_inner, t1214 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 2.017500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1208 = 0, y_outer, t1210 = 0, x_outer, t1212 = 0, y_inner, t1205 = 0, x_inner, t1214 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.384560

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1082 = 0, y_outer, t1084 = 0, x_outer, t1086 = 0, y_inner, t1079 = 0, x_inner, t1088 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.995470

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1082 = 0, y_outer, t1084 = 0, x_outer, t1086 = 0, y_inner, t1079 = 0, x_inner, t1088 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 2.053140

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1082 = 0, y_outer, t1084 = 0, x_outer, t1086 = 0, y_inner, t1079 = 0, x_inner, t1088 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.399940

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t956 = 0, y_outer, t958 = 0, x_outer, t960 = 0, y_inner, t953 = 0, x_inner, t962 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.015970

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t956 = 0, y_outer, t958 = 0, x_outer, t960 = 0, y_inner, t953 = 0, x_inner, t962 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 2.053500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t956 = 0, y_outer, t958 = 0, x_outer, t960 = 0, y_inner, t953 = 0, x_inner, t962 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.470570

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1643 = 0, y_outer, t1645 = 0, x_outer, t1647 = 0, y_inner, t1640 = 0, x_inner, t1649 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.502510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1686 = 0, y_outer, t1688 = 0, x_outer, t1690 = 0, y_inner, t1683 = 0, x_inner, t1692 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.694080

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1729 = 0, y_outer, t1731 = 0, x_outer, t1733 = 0, y_inner, t1726 = 0, x_inner, t1735 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.441120

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.451490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1815 = 0, y_outer, t1817 = 0, x_outer, t1819 = 0, y_inner, t1812 = 0, x_inner, t1821 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.484510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1858 = 0, y_outer, t1860 = 0, x_outer, t1862 = 0, y_inner, t1855 = 0, x_inner, t1864 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.354930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.409050

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1944 = 0, y_outer, t1946 = 0, x_outer, t1948 = 0, y_inner, t1941 = 0, x_inner, t1950 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.400350

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
1.470570+1.502510+1.694080+1.441120+1.451490+1.484510+1.354930+1.409050+1.400350+157.110992+
remaining list
1.354930+1.400350+1.409050+1.441120+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.995560

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.292590

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 2 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.374480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.914500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.881120

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.354930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.937630

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1944 = 0, y_outer, t1946 = 0, x_outer, t1948 = 0, y_inner, t1941 = 0, x_inner, t1950 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.888040

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1944 = 0, y_outer, t1946 = 0, x_outer, t1948 = 0, y_inner, t1941 = 0, x_inner, t1950 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.392130

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1944 = 0, y_outer, t1946 = 0, x_outer, t1948 = 0, y_inner, t1941 = 0, x_inner, t1950 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.953480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.365070

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 2 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.407500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c1 + int32((int64(c3)*(int64)1024)))] = (((((input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c1 + int32((int64(c3)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
0- for 0 <= x < 1024 | 0 | P
	1- for 0 <= y < 1024 | 0
		RGB2Gray
Evaluation : 9.839530

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t7 = 0, x = t6, t8 = 0, y = t5, t9 = 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      RGB2Gray_buf[(c1 + int32((int64(c3)*(int64)1024)))] = (((((input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c1 + int32((int64(c3)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
0- for 0 <= x < 1024 | 0
	1- for 0 <= y < 1024 | 0 | P
		RGB2Gray
Evaluation : 198.205994

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t7 = 0, x = t6, t8 = 0, y = t5, t9 = 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
9.839530+198.205994+36.063900+
remaining list
9.839530+36.063900+198.205994+ Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.211900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2496 = 0, x_outer, t2498 = 0, y_outer, t2500 = 0, x_inner, t2493 = 0, y_inner, t2502 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.150510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2543 = 0, x_outer, t2545 = 0, y_outer, t2547 = 0, x_inner, t2540 = 0, y_inner, t2549 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 4.329090

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2590 = 0, x_outer, t2592 = 0, y_outer, t2594 = 0, x_inner, t2587 = 0, y_inner, t2596 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.480600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2637 = 0, x_outer, t2639 = 0, y_outer, t2641 = 0, x_inner, t2634 = 0, y_inner, t2643 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.935150

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2684 = 0, x_outer, t2686 = 0, y_outer, t2688 = 0, x_inner, t2681 = 0, y_inner, t2690 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 4.925010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2731 = 0, x_outer, t2733 = 0, y_outer, t2735 = 0, x_inner, t2728 = 0, y_inner, t2737 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.143360

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.930620

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2825 = 0, x_outer, t2827 = 0, y_outer, t2829 = 0, x_inner, t2822 = 0, y_inner, t2831 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 4.632950

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2872 = 0, x_outer, t2874 = 0, y_outer, t2876 = 0, x_inner, t2869 = 0, y_inner, t2878 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
4.211900+4.150510+4.329090+4.480600+4.935150+4.925010+4.143360+4.930620+4.632950+9.839530+
remaining list
4.143360+4.150510+4.211900+4.329090+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.587050

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.474640

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.583950

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.058960

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2543 = 0, x_outer, t2545 = 0, y_outer, t2547 = 0, x_inner, t2540 = 0, y_inner, t2549 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.291060

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2543 = 0, x_outer, t2545 = 0, y_outer, t2547 = 0, x_inner, t2540 = 0, y_inner, t2549 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.408480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2543 = 0, x_outer, t2545 = 0, y_outer, t2547 = 0, x_inner, t2540 = 0, y_inner, t2549 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.145500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2496 = 0, x_outer, t2498 = 0, y_outer, t2500 = 0, x_inner, t2493 = 0, y_inner, t2502 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.177450

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2496 = 0, x_outer, t2498 = 0, y_outer, t2500 = 0, x_inner, t2493 = 0, y_inner, t2502 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.086490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2496 = 0, x_outer, t2498 = 0, y_outer, t2500 = 0, x_inner, t2493 = 0, y_inner, t2502 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 32 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.433040

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2590 = 0, x_outer, t2592 = 0, y_outer, t2594 = 0, x_inner, t2587 = 0, y_inner, t2596 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.192950

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2590 = 0, x_outer, t2592 = 0, y_outer, t2594 = 0, x_inner, t2587 = 0, y_inner, t2596 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.814510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2590 = 0, x_outer, t2592 = 0, y_outer, t2594 = 0, x_inner, t2587 = 0, y_inner, t2596 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 14.061900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 64
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 13.996400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3469 = 0, x_outer, t3471 = 0, y_outer, t3473 = 0, x_inner, t3466 = 0, y_inner, t3475 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 128
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 13.835400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3515 = 0, x_outer, t3517 = 0, y_outer, t3519 = 0, x_inner, t3512 = 0, y_inner, t3521 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 13.810400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3561 = 0, x_outer, t3563 = 0, y_outer, t3565 = 0, x_inner, t3558 = 0, y_inner, t3567 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 64
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 14.139500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3607 = 0, x_outer, t3609 = 0, y_outer, t3611 = 0, x_inner, t3604 = 0, y_inner, t3613 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 128
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 14.092600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3653 = 0, x_outer, t3655 = 0, y_outer, t3657 = 0, x_inner, t3650 = 0, y_inner, t3659 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 14.271100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3699 = 0, x_outer, t3701 = 0, y_outer, t3703 = 0, x_inner, t3696 = 0, y_inner, t3705 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 14.315600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3745 = 0, x_outer, t3747 = 0, y_outer, t3749 = 0, x_inner, t3742 = 0, y_inner, t3751 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 128
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 14.522400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3791 = 0, x_outer, t3793 = 0, y_outer, t3795 = 0, x_inner, t3788 = 0, y_inner, t3797 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
14.061900+13.996400+13.835400+13.810400+14.139500+14.092600+14.271100+14.315600+14.522400+36.063900+
remaining list
13.810400+13.835400+13.996400+14.061900+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 14.371500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3561 = 0, x_outer, t3563 = 0, y_outer, t3565 = 0, x_inner, t3558 = 0, y_inner, t3567 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.372100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3561 = 0, x_outer, t3563 = 0, y_outer, t3565 = 0, x_inner, t3558 = 0, y_inner, t3567 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.604400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3561 = 0, x_outer, t3563 = 0, y_outer, t3565 = 0, x_inner, t3558 = 0, y_inner, t3567 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 32 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 15.301900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3515 = 0, x_outer, t3517 = 0, y_outer, t3519 = 0, x_inner, t3512 = 0, y_inner, t3521 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.729100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3515 = 0, x_outer, t3517 = 0, y_outer, t3519 = 0, x_inner, t3512 = 0, y_inner, t3521 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.993900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3515 = 0, x_outer, t3517 = 0, y_outer, t3519 = 0, x_inner, t3512 = 0, y_inner, t3521 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 14.032000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3469 = 0, x_outer, t3471 = 0, y_outer, t3473 = 0, x_inner, t3466 = 0, y_inner, t3475 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.244000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3469 = 0, x_outer, t3471 = 0, y_outer, t3473 = 0, x_inner, t3466 = 0, y_inner, t3475 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.829500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3469 = 0, x_outer, t3471 = 0, y_outer, t3473 = 0, x_inner, t3466 = 0, y_inner, t3475 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 14.345600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.333500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.779900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.750010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.984140

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4376 = 0, x_outer, t4378 = 0, y_outer, t4380 = 0, x_inner, t4373 = 0, y_inner, t4382 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 9.532930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4423 = 0, x_outer, t4425 = 0, y_outer, t4427 = 0, x_inner, t4420 = 0, y_inner, t4429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 5.824090

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4470 = 0, x_outer, t4472 = 0, y_outer, t4474 = 0, x_inner, t4467 = 0, y_inner, t4476 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 5.925540

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4517 = 0, x_outer, t4519 = 0, y_outer, t4521 = 0, x_inner, t4514 = 0, y_inner, t4523 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 8 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 7.068400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4564 = 0, x_outer, t4566 = 0, y_outer, t4568 = 0, x_inner, t4561 = 0, y_inner, t4570 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.266980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 5.316380

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 8 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 5.967970

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4705 = 0, x_outer, t4707 = 0, y_outer, t4709 = 0, x_inner, t4702 = 0, y_inner, t4711 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
4.750010+4.984140+9.532930+5.824090+5.925540+7.068400+4.266980+5.316380+5.967970+198.205994+
remaining list
4.266980+4.750010+4.984140+5.316380+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.486610

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 6.070020

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 5.493400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 6.173970

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.010960

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.826550

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.415920

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4376 = 0, x_outer, t4378 = 0, y_outer, t4380 = 0, x_inner, t4373 = 0, y_inner, t4382 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.178930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4376 = 0, x_outer, t4378 = 0, y_outer, t4380 = 0, x_inner, t4373 = 0, y_inner, t4382 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 5.288480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4376 = 0, x_outer, t4378 = 0, y_outer, t4380 = 0, x_inner, t4373 = 0, y_inner, t4382 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.558370

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.362030

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 5.295520

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
NB explored schedules : 131
Best evaluation : 1.167060
Initial exec time : 1.200080
Initial evaluation : 1.248480
Search time : 187648 ms 
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}
Best schedule exec time : 1.223090
Speedup : 0.981187
