
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}
 vars y x  interchange : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c1 + int32((int64(c3)*(int64)1024)))] = (((((input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c1 + int32((int64(c3)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Interchange L0  L1
0- for 0 <= x < 1024 | 0
	1- for 0 <= y < 1024 | 0
		RGB2Gray
Evaluation : 34.835899

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t7 = 0, x = t6, t8 = 0, y = t5, t9 = 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
34.835899+1.264450+
remaining list
1.264450+34.835899+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Parallelize L0
0- for 0 <= y < 1024 | 0 | P
	1- for 0 <= x < 1024 | 0
		RGB2Gray
Evaluation : 1.402140

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      RGB2Gray_buf[(c3 + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c3 + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c3 + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Parallelize L1
0- for 0 <= y < 1024 | 0
	1- for 0 <= x < 1024 | 0 | P
		RGB2Gray
Evaluation : 134.914993

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
1.402140+134.914993+1.264450+
remaining list
1.264450+1.402140+134.914993+ Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 2.304430

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t29 = 0, y_outer, t31 = 0, x_outer, t33 = 0, y_inner, t26 = 0, x_inner, t35 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 2.199650

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t71 = 0, y_outer, t73 = 0, x_outer, t75 = 0, y_inner, t68 = 0, x_inner, t77 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 2.051000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t113 = 0, y_outer, t115 = 0, x_outer, t117 = 0, y_inner, t110 = 0, x_inner, t119 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 2.207990

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t155 = 0, y_outer, t157 = 0, x_outer, t159 = 0, y_inner, t152 = 0, x_inner, t161 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 2.079010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t197 = 0, y_outer, t199 = 0, x_outer, t201 = 0, y_inner, t194 = 0, x_inner, t203 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 2.335070

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t239 = 0, y_outer, t241 = 0, x_outer, t243 = 0, y_inner, t236 = 0, x_inner, t245 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 2.171520

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t281 = 0, y_outer, t283 = 0, x_outer, t285 = 0, y_inner, t278 = 0, x_inner, t287 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 2.023100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t323 = 0, y_outer, t325 = 0, x_outer, t327 = 0, y_inner, t320 = 0, x_inner, t329 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 2.259020

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t365 = 0, y_outer, t367 = 0, x_outer, t369 = 0, y_inner, t362 = 0, x_inner, t371 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
2.304430+2.199650+2.051000+2.207990+2.079010+2.335070+2.171520+2.023100+2.259020+1.264450+
remaining list
1.264450+2.023100+2.051000+2.079010+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 256) {
      unrolled (c5, 0, 4) {
        RGB2Gray_buf[(((c3*4) + c5) + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((((c3*4) + c5) + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*4) + c5) + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*4) + c5) + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
      }
    }
  }
}

-----------
Unrolling L1 4
0- for 0 <= y < 1024 | 0
	1- for 0 <= x_outer < 256 | 0
		2- for 0 <= x_inner < 4 | 1
			RGB2Gray
Evaluation : 1.535530

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }


input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 128) {
      unrolled (c5, 0, 8) {
        RGB2Gray_buf[(((c3*8) + c5) + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((((c3*8) + c5) + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*8) + c5) + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*8) + c5) + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
      }
    }
  }
}

-----------
Unrolling L1 8
0- for 0 <= y < 1024 | 0
	1- for 0 <= x_outer < 128 | 0
		2- for 0 <= x_inner < 8 | 1
			RGB2Gray
Evaluation : 1.706480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }


input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    for (c3, 0, 64) {
      unrolled (c5, 0, 16) {
        RGB2Gray_buf[(((c3*16) + c5) + int32((int64(c1)*(int64)1024)))] = (((((input_buf[((((c3*16) + c5) + int32((int64(c1)*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*16) + c5) + int32((int64(c1)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*16) + c5) + int32((int64(c1)*(int64)1024)))]*4899)) + 8192)/16384)
      }
    }
  }
}

-----------
Unrolling L1 16
0- for 0 <= y < 1024 | 0
	1- for 0 <= x_outer < 64 | 0
		2- for 0 <= x_inner < 16 | 1
			RGB2Gray
Evaluation : 1.234410

{ RGB2Gray[t5, t6] -> RGB2Gray[0, 0, y = t5, 0, x = t6, 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }


input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.221010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t323 = 0, y_outer, t325 = 0, x_outer, t327 = 0, y_inner, t320 = 0, x_inner, t329 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.462050

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t323 = 0, y_outer, t325 = 0, x_outer, t327 = 0, y_inner, t320 = 0, x_inner, t329 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 2.150060

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t323 = 0, y_outer, t325 = 0, x_outer, t327 = 0, y_inner, t320 = 0, x_inner, t329 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.392910

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t113 = 0, y_outer, t115 = 0, x_outer, t117 = 0, y_inner, t110 = 0, x_inner, t119 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.032420

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t113 = 0, y_outer, t115 = 0, x_outer, t117 = 0, y_inner, t110 = 0, x_inner, t119 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 2.287390

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t113 = 0, y_outer, t115 = 0, x_outer, t117 = 0, y_inner, t110 = 0, x_inner, t119 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.282160

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t197 = 0, y_outer, t199 = 0, x_outer, t201 = 0, y_inner, t194 = 0, x_inner, t203 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 5.605460

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t197 = 0, y_outer, t199 = 0, x_outer, t201 = 0, y_inner, t194 = 0, x_inner, t203 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 2.293110

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t197 = 0, y_outer, t199 = 0, x_outer, t201 = 0, y_inner, t194 = 0, x_inner, t203 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.250510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t800 = 0, y_outer, t802 = 0, x_outer, t804 = 0, y_inner, t797 = 0, x_inner, t806 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.047970

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t843 = 0, y_outer, t845 = 0, x_outer, t847 = 0, y_inner, t840 = 0, x_inner, t849 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.199960

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t886 = 0, y_outer, t888 = 0, x_outer, t890 = 0, y_inner, t883 = 0, x_inner, t892 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.232500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t929 = 0, y_outer, t931 = 0, x_outer, t933 = 0, y_inner, t926 = 0, x_inner, t935 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.217840

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t972 = 0, y_outer, t974 = 0, x_outer, t976 = 0, y_inner, t969 = 0, x_inner, t978 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.210450

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1015 = 0, y_outer, t1017 = 0, x_outer, t1019 = 0, y_inner, t1012 = 0, x_inner, t1021 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.212360

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1058 = 0, y_outer, t1060 = 0, x_outer, t1062 = 0, y_inner, t1055 = 0, x_inner, t1064 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.227620

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1101 = 0, y_outer, t1103 = 0, x_outer, t1105 = 0, y_inner, t1098 = 0, x_inner, t1107 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.218440

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1144 = 0, y_outer, t1146 = 0, x_outer, t1148 = 0, y_inner, t1141 = 0, x_inner, t1150 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
1.250510+1.047970+1.199960+1.232500+1.217840+1.210450+1.212360+1.227620+1.218440+1.402140+
remaining list
1.047970+1.199960+1.210450+1.212360+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 4
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.891020

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t843 = 0, y_outer, t845 = 0, x_outer, t847 = 0, y_inner, t840 = 0, x_inner, t849 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 8
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.911040

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t843 = 0, y_outer, t845 = 0, x_outer, t847 = 0, y_inner, t840 = 0, x_inner, t849 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
Unrolling L3 16
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.238940

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t843 = 0, y_outer, t845 = 0, x_outer, t847 = 0, y_inner, t840 = 0, x_inner, t849 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.821520

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t886 = 0, y_outer, t888 = 0, x_outer, t890 = 0, y_inner, t883 = 0, x_inner, t892 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.677510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t886 = 0, y_outer, t888 = 0, x_outer, t890 = 0, y_inner, t883 = 0, x_inner, t892 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.274940

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t886 = 0, y_outer, t888 = 0, x_outer, t890 = 0, y_inner, t883 = 0, x_inner, t892 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.860500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1015 = 0, y_outer, t1017 = 0, x_outer, t1019 = 0, y_inner, t1012 = 0, x_inner, t1021 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.705410

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1015 = 0, y_outer, t1017 = 0, x_outer, t1019 = 0, y_inner, t1012 = 0, x_inner, t1021 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0 | P
	1- for 0 <= x_outer < 8 | 0
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.334070

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1015 = 0, y_outer, t1017 = 0, x_outer, t1019 = 0, y_inner, t1012 = 0, x_inner, t1021 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.875520

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1058 = 0, y_outer, t1060 = 0, x_outer, t1062 = 0, y_inner, t1055 = 0, x_inner, t1064 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.274470

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1058 = 0, y_outer, t1060 = 0, x_outer, t1062 = 0, y_inner, t1055 = 0, x_inner, t1064 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0 | P
	1- for 0 <= x_outer < 32 | 0
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 2 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.257420

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1058 = 0, y_outer, t1060 = 0, x_outer, t1062 = 0, y_inner, t1055 = 0, x_inner, t1064 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.505490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1643 = 0, y_outer, t1645 = 0, x_outer, t1647 = 0, y_inner, t1640 = 0, x_inner, t1649 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.498460

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1686 = 0, y_outer, t1688 = 0, x_outer, t1690 = 0, y_inner, t1683 = 0, x_inner, t1692 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= y_outer < 32 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.621010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1729 = 0, y_outer, t1731 = 0, x_outer, t1733 = 0, y_inner, t1726 = 0, x_inner, t1735 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t5 <= 32y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.479980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.600620

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1815 = 0, y_outer, t1817 = 0, x_outer, t1819 = 0, y_inner, t1812 = 0, x_inner, t1821 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.400950

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1858 = 0, y_outer, t1860 = 0, x_outer, t1862 = 0, y_inner, t1855 = 0, x_inner, t1864 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*32) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 32 | 0
				RGB2Gray
Evaluation : 1.492500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 16 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray
Evaluation : 1.734500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1944 = 0, y_outer, t1946 = 0, x_outer, t1948 = 0, y_inner, t1941 = 0, x_inner, t1950 = 0] : (-t6 + x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -63 + t6 <= 64x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: y x  deapth of outer is:0 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*128) + c7) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner < 128 | 0
				RGB2Gray
Evaluation : 1.446490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
1.505490+1.498460+1.621010+1.479980+1.600620+1.400950+1.492500+1.734500+1.446490+134.914993+
remaining list
1.400950+1.446490+1.479980+1.492500+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 2.071620

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1858 = 0, y_outer, t1860 = 0, x_outer, t1862 = 0, y_inner, t1855 = 0, x_inner, t1864 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.950500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1858 = 0, y_outer, t1860 = 0, x_outer, t1862 = 0, y_inner, t1855 = 0, x_inner, t1864 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.528620

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1858 = 0, y_outer, t1860 = 0, x_outer, t1862 = 0, y_inner, t1855 = 0, x_inner, t1864 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*32) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 32 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 1.920580

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*16) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 16 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.792430

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 8 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.482960

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1987 = 0, y_outer, t1989 = 0, x_outer, t1991 = 0, y_inner, t1984 = 0, x_inner, t1993 = 0] : (-t6 + x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -127 + t6 <= 128x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 2.174380

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.506090

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*64) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= y_outer < 16 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 64 | 0
			3- for 0 <= x_inner_outer < 2 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.483920

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1772 = 0, y_outer, t1774 = 0, x_outer, t1776 = 0, y_inner, t1769 = 0, x_inner, t1778 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t5 <= 64y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*8) + c7)*4) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 8 | 0
				4- for 0 <= x_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 2.050880

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*4) + c7)*8) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 4 | 0
				4- for 0 <= x_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 1.498940

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))] = (((((input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((((c3*2) + c7)*16) + c9) + int32((int64(((c1*128) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= y_outer < 8 | 0
	1- for 0 <= x_outer < 32 | 0 | P
		2- for 0 <= y_inner < 128 | 0
			3- for 0 <= x_inner_outer < 2 | 0
				4- for 0 <= x_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 1.465080

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t1901 = 0, y_outer, t1903 = 0, x_outer, t1905 = 0, y_inner, t1898 = 0, x_inner, t1907 = 0] : (-t6 + x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t5 <= 128y_outer <= t5 and -31 + t6 <= 32x_outer <= t6 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 1024) {
    for (c3, 0, 1024) {
      RGB2Gray_buf[(c1 + int32((int64(c3)*(int64)1024)))] = (((((input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c1 + int32((int64(c3)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
0- for 0 <= x < 1024 | 0 | P
	1- for 0 <= y < 1024 | 0
		RGB2Gray
Evaluation : 10.249500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t7 = 0, x = t6, t8 = 0, y = t5, t9 = 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 1024) {
    parallel (c3, 0, 1024) {
      RGB2Gray_buf[(c1 + int32((int64(c3)*(int64)1024)))] = (((((input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 2097152)]*1868) + (input_buf[((c1 + int32((int64(c3)*(int64)1024))) + 1048576)]*9617)) + (input_buf[(c1 + int32((int64(c3)*(int64)1024)))]*4899)) + 8192)/16384)
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
0- for 0 <= x < 1024 | 0
	1- for 0 <= y < 1024 | 0 | P
		RGB2Gray
Evaluation : 214.001999

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t7 = 0, x = t6, t8 = 0, y = t5, t9 = 0] : 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }

input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
10.249500+214.001999+34.835899+
remaining list
10.249500+34.835899+214.001999+ Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.989980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2496 = 0, x_outer, t2498 = 0, y_outer, t2500 = 0, x_inner, t2493 = 0, y_inner, t2502 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.342440

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2543 = 0, x_outer, t2545 = 0, y_outer, t2547 = 0, x_inner, t2540 = 0, y_inner, t2549 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= x_outer < 32 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 4.405980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2590 = 0, x_outer, t2592 = 0, y_outer, t2594 = 0, x_inner, t2587 = 0, y_inner, t2596 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 3.796100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2637 = 0, x_outer, t2639 = 0, y_outer, t2641 = 0, x_inner, t2634 = 0, y_inner, t2643 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.125480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2684 = 0, x_outer, t2686 = 0, y_outer, t2688 = 0, x_inner, t2681 = 0, y_inner, t2690 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 4.271980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2731 = 0, x_outer, t2733 = 0, y_outer, t2735 = 0, x_inner, t2728 = 0, y_inner, t2737 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.269480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.415990

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2825 = 0, x_outer, t2827 = 0, y_outer, t2829 = 0, x_inner, t2822 = 0, y_inner, t2831 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 5.057930

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2872 = 0, x_outer, t2874 = 0, y_outer, t2876 = 0, x_inner, t2869 = 0, y_inner, t2878 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
4.989980+4.342440+4.405980+3.796100+4.125480+4.271980+4.269480+4.415990+5.057930+10.249500+
remaining list
3.796100+4.125480+4.269480+4.271980+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 9.112000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2637 = 0, x_outer, t2639 = 0, y_outer, t2641 = 0, x_inner, t2634 = 0, y_inner, t2643 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.627110

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2637 = 0, x_outer, t2639 = 0, y_outer, t2641 = 0, x_inner, t2634 = 0, y_inner, t2643 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 6.065010

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2637 = 0, x_outer, t2639 = 0, y_outer, t2641 = 0, x_inner, t2634 = 0, y_inner, t2643 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.183050

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2684 = 0, x_outer, t2686 = 0, y_outer, t2688 = 0, x_inner, t2681 = 0, y_inner, t2690 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.864570

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2684 = 0, x_outer, t2686 = 0, y_outer, t2688 = 0, x_inner, t2681 = 0, y_inner, t2690 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.480840

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2684 = 0, x_outer, t2686 = 0, y_outer, t2688 = 0, x_inner, t2681 = 0, y_inner, t2690 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.049060

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.128460

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0 | P
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 5.122180

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2778 = 0, x_outer, t2780 = 0, y_outer, t2782 = 0, x_inner, t2775 = 0, y_inner, t2784 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*32) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 4
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 32 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.031110

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2731 = 0, x_outer, t2733 = 0, y_outer, t2735 = 0, x_inner, t2728 = 0, y_inner, t2737 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 8
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.093530

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2731 = 0, x_outer, t2733 = 0, y_outer, t2735 = 0, x_inner, t2728 = 0, y_inner, t2737 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
Tiling L0 64 L1 128
Unrolling L3 16
0- for 0 <= x_outer < 16 | 0 | P
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.417540

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t2731 = 0, x_outer, t2733 = 0, y_outer, t2735 = 0, x_inner, t2728 = 0, y_inner, t2737 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 13.619500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 64
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 14.239700

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3469 = 0, x_outer, t3471 = 0, y_outer, t3473 = 0, x_inner, t3466 = 0, y_inner, t3475 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 128
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 14.277600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3515 = 0, x_outer, t3517 = 0, y_outer, t3519 = 0, x_inner, t3512 = 0, y_inner, t3521 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 32
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 14.297000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3561 = 0, x_outer, t3563 = 0, y_outer, t3565 = 0, x_inner, t3558 = 0, y_inner, t3567 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 64
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 14.197300

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3607 = 0, x_outer, t3609 = 0, y_outer, t3611 = 0, x_inner, t3604 = 0, y_inner, t3613 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 128
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 14.418100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3653 = 0, x_outer, t3655 = 0, y_outer, t3657 = 0, x_inner, t3650 = 0, y_inner, t3659 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 14.140500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3699 = 0, x_outer, t3701 = 0, y_outer, t3703 = 0, x_inner, t3696 = 0, y_inner, t3705 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 14.160500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3745 = 0, x_outer, t3747 = 0, y_outer, t3749 = 0, x_inner, t3742 = 0, y_inner, t3751 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 128
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 8 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 14.830900

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3791 = 0, x_outer, t3793 = 0, y_outer, t3795 = 0, x_inner, t3788 = 0, y_inner, t3797 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
13.619500+14.239700+14.277600+14.297000+14.197300+14.418100+14.140500+14.160500+14.830900+34.835899+
remaining list
13.619500+14.140500+14.160500+14.197300+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 13.927500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.184100

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.473400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3423 = 0, x_outer, t3425 = 0, y_outer, t3427 = 0, x_inner, t3420 = 0, y_inner, t3429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 14.024000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3699 = 0, x_outer, t3701 = 0, y_outer, t3703 = 0, x_inner, t3696 = 0, y_inner, t3705 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 13.928500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3699 = 0, x_outer, t3701 = 0, y_outer, t3703 = 0, x_inner, t3696 = 0, y_inner, t3705 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.868500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3699 = 0, x_outer, t3701 = 0, y_outer, t3703 = 0, x_inner, t3696 = 0, y_inner, t3705 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 14.488000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3745 = 0, x_outer, t3747 = 0, y_outer, t3749 = 0, x_inner, t3742 = 0, y_inner, t3751 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.757000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3745 = 0, x_outer, t3747 = 0, y_outer, t3749 = 0, x_inner, t3742 = 0, y_inner, t3751 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 15.453500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3745 = 0, x_outer, t3747 = 0, y_outer, t3749 = 0, x_inner, t3742 = 0, y_inner, t3751 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 14.625000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3607 = 0, x_outer, t3609 = 0, y_outer, t3611 = 0, x_inner, t3604 = 0, y_inner, t3613 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 14.788600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3607 = 0, x_outer, t3609 = 0, y_outer, t3611 = 0, x_inner, t3604 = 0, y_inner, t3613 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Tiling L0 64 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 14.916700

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t3607 = 0, x_outer, t3609 = 0, y_outer, t3611 = 0, x_inner, t3604 = 0, y_inner, t3613 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.485490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 6.752490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4376 = 0, x_outer, t4378 = 0, y_outer, t4380 = 0, x_inner, t4373 = 0, y_inner, t4382 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 8 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 10.935400

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4423 = 0, x_outer, t4425 = 0, y_outer, t4427 = 0, x_inner, t4420 = 0, y_inner, t4429 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 5.800490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4470 = 0, x_outer, t4472 = 0, y_outer, t4474 = 0, x_inner, t4467 = 0, y_inner, t4476 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 8.630990

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4517 = 0, x_outer, t4519 = 0, y_outer, t4521 = 0, x_inner, t4514 = 0, y_inner, t4523 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 8 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 8.453490

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4564 = 0, x_outer, t4566 = 0, y_outer, t4568 = 0, x_inner, t4561 = 0, y_inner, t4570 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				RGB2Gray
Evaluation : 4.791980

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				RGB2Gray
Evaluation : 4.529480

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
 Tiling 2 loop names: x y  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 8 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				RGB2Gray
Evaluation : 5.951880

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4705 = 0, x_outer, t4707 = 0, y_outer, t4709 = 0, x_inner, t4702 = 0, y_inner, t4711 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 128 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -127 + t5 <= 128y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }



input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

original list
4.485490+6.752490+10.935400+5.800490+8.630990+8.453490+4.791980+4.529480+5.951880+214.001999+
remaining list
4.485490+4.529480+4.791980+5.800490+
Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.358530

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.417540

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*32) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 32 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 32 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.580500

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4329 = 0, x_outer, t4331 = 0, y_outer, t4333 = 0, x_inner, t4326 = 0, y_inner, t4335 = 0] : (t6 - x_inner) mod 32 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -31 + t6 <= 32x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*16) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 16 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.281040

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.355070

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 64
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 16 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 4.936580

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4658 = 0, x_outer, t4660 = 0, y_outer, t4662 = 0, x_inner, t4655 = 0, y_inner, t4664 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 64 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -63 + t5 <= 64y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 5.463000

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 3.973600

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, 0, 128) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*128) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 128 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 8 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 3.957030

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4611 = 0, x_outer, t4613 = 0, y_outer, t4615 = 0, x_inner, t4608 = 0, y_inner, t4617 = 0] : (t6 - x_inner) mod 128 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -127 + t6 <= 128x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 4) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*8) + c7)*4) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 4
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 8 | 0
				4- for 0 <= y_inner_inner < 4 | 1
					RGB2Gray
Evaluation : 4.065510

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4470 = 0, x_outer, t4472 = 0, y_outer, t4474 = 0, x_inner, t4467 = 0, y_inner, t4476 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 4) {
          unrolled (c9, 0, 8) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*4) + c7)*8) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 8
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 4 | 0
				4- for 0 <= y_inner_inner < 8 | 1
					RGB2Gray
Evaluation : 4.044530

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4470 = 0, x_outer, t4472 = 0, y_outer, t4474 = 0, x_inner, t4467 = 0, y_inner, t4476 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, 0, 64) {
        for (c7, 0, 2) {
          unrolled (c9, 0, 16) {
            RGB2Gray_buf[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))] = (((((input_buf[((((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c1*64) + c5) + int32((int64(((((c3*2) + c7)*16) + c9))*(int64)1024)))]*4899)) + 8192)/16384)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
Tiling L0 64 L1 32
Unrolling L3 16
0- for 0 <= x_outer < 16 | 0
	1- for 0 <= y_outer < 32 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner_outer < 2 | 0
				4- for 0 <= y_inner_inner < 16 | 1
					RGB2Gray
Evaluation : 3.984450

{ RGB2Gray[t5, t6] -> RGB2Gray[0, t4470 = 0, x_outer, t4472 = 0, y_outer, t4474 = 0, x_inner, t4467 = 0, y_inner, t4476 = 0] : (t6 - x_inner) mod 64 = 0 and (t5 - y_inner) mod 32 = 0 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 and -63 + t6 <= 64x_outer <= t6 and -31 + t5 <= 32y_outer <= t5 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:0 0 2 ,1 0 0 ,0 1 0 ,
input_img:0 0 1 ,1 0 0 ,0 1 0 ,
input_img:0 0 0 ,1 0 0 ,0 1 0 ,

<legal>
NB explored schedules : 131
Best evaluation : 1.047970
Initial exec time : 1.371150
Initial evaluation : 1.264450
Search time : 188823 ms 
0- for 0 <= y_outer < 32 | 0 | P
	1- for 0 <= x_outer < 16 | 0
		2- for 0 <= y_inner < 32 | 0
			3- for 0 <= x_inner < 64 | 0
				RGB2Gray

Generated Halide IR:
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
assert((reinterpret(uint64, RGB2Gray_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("RGB2Gray_buf"))
let RGB2Gray_buf = _halide_buffer_get_host(RGB2Gray_buf.buffer)
let input_buf = _halide_buffer_get_host(input_buf.buffer)
produce  {
  allocate _input_img_b0[int32 * 1024 * 1024 * 3]
  allocate _RGB2Gray_b1[int32 * 1024 * 1024]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          RGB2Gray_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))] = (((((input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 2097152)]*1868) + (input_buf[((((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024))) + 1048576)]*9617)) + (input_buf[(((c3*64) + c7) + int32((int64(((c1*32) + c5))*(int64)1024)))]*4899)) + 8192)/16384)
        }
      }
    }
  }
}
Best schedule exec time : 1.372580
Speedup : 0.998958
