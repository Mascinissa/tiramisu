
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 896) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 896) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 896) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}
 vars i00 i01 i02  interchange : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 896) {
    for (c3, 0, 768) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Interchange L0  L1
0- for 0 <= i01 < 896 | 0
	1- for 0 <= i00 < 768 | 0
		2- for 0 <= i02 < 1024 | 0
			comp02
Evaluation : 945.044983

{ comp02[t5, t6, t7] -> comp02[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 vars i00 i01 i02  interchange : i00 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 1024) {
    for (c3, 0, 896) {
      for (c5, 0, 768) {
        buf02[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)917504)))] = ((((((buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c5)*(int64)921348)))] + (buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c5)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c5)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c5)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c5)*(int64)921348) + (int64)921348)))]) + buf00[((c1 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c5)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c1) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c5)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Interchange L0  L2
0- for 0 <= i02 < 1024 | 0
	1- for 0 <= i01 < 896 | 0
		2- for 0 <= i00 < 768 | 0
			comp02
Evaluation : 50355.601562

{ comp02[t5, t6, t7] -> comp02[0, t17 = 0, i02 = t7, t18 = 0, i01 = t6, t19 = 0, i00 = t5, t20 = 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 vars i00 i01 i02  interchange : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 1024) {
      for (c5, 0, 896) {
        buf02[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c3 + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c3) + (int64)2)) + int32(((int64(c5)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Interchange L1  L2
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i02 < 1024 | 0
		2- for 0 <= i01 < 896 | 0
			comp02
Evaluation : 22814.800781

{ comp02[t5, t6, t7] -> comp02[0, t26 = 0, i00 = t5, t27 = 0, i02 = t7, t28 = 0, i01 = t6, t29 = 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

original list
945.044983+50355.601562+22814.800781+856.083008+
remaining list
856.083008+945.044983+22814.800781+50355.601562+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 896) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Parallelize L0
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01 < 896 | 0
		2- for 0 <= i02 < 1024 | 0
			comp02
Evaluation : 534.739990

{ comp02[t5, t6, t7] -> comp02[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 896) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Parallelize L1
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01 < 896 | 0 | P
		2- for 0 <= i02 < 1024 | 0
			comp02
Evaluation : 730.505981

{ comp02[t5, t6, t7] -> comp02[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 896) {
      parallel (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c3)*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Parallelize L2
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01 < 896 | 0
		2- for 0 <= i02 < 1024 | 0 | P
			comp02
Evaluation : 83272.296875

{ comp02[t5, t6, t7] -> comp02[0, 0, i00 = t5, 0, i01 = t6, 0, i02 = t7, 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

original list
534.739990+730.505981+83272.296875+856.083008+
remaining list
534.739990+730.505981+856.083008+83272.296875+ Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 480.255005

{ comp02[t5, t6, t7] -> comp02[0, t53 = 0, i00_outer, t55 = 0, i01_outer, t57 = 0, i00_inner, t50 = 0, i01_inner, t59 = 0, i02 = t7, t61 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 514.174988

{ comp02[t5, t6, t7] -> comp02[0, t118 = 0, i00_outer, t120 = 0, i01_outer, t122 = 0, i02_outer, t124 = 0, i00_inner, t126 = 0, i01_inner, t115 = 0, i02_inner, t128 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 510.002014

{ comp02[t5, t6, t7] -> comp02[0, t201 = 0, i00_outer, t203 = 0, i01_outer, t205 = 0, i02_outer, t207 = 0, i00_inner, t209 = 0, i01_inner, t198 = 0, i02_inner, t211 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 510.730011

{ comp02[t5, t6, t7] -> comp02[0, t284 = 0, i00_outer, t286 = 0, i01_outer, t288 = 0, i02_outer, t290 = 0, i00_inner, t292 = 0, i01_inner, t281 = 0, i02_inner, t294 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 508.545990

{ comp02[t5, t6, t7] -> comp02[0, t354 = 0, i00_outer, t356 = 0, i01_outer, t358 = 0, i00_inner, t351 = 0, i01_inner, t360 = 0, i02 = t7, t362 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 540.476990

{ comp02[t5, t6, t7] -> comp02[0, t419 = 0, i00_outer, t421 = 0, i01_outer, t423 = 0, i02_outer, t425 = 0, i00_inner, t427 = 0, i01_inner, t416 = 0, i02_inner, t429 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 538.830994

{ comp02[t5, t6, t7] -> comp02[0, t502 = 0, i00_outer, t504 = 0, i01_outer, t506 = 0, i02_outer, t508 = 0, i00_inner, t510 = 0, i01_inner, t499 = 0, i02_inner, t512 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 522.353027

{ comp02[t5, t6, t7] -> comp02[0, t585 = 0, i00_outer, t587 = 0, i01_outer, t589 = 0, i02_outer, t591 = 0, i00_inner, t593 = 0, i01_inner, t582 = 0, i02_inner, t595 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 641.497009

{ comp02[t5, t6, t7] -> comp02[0, t655 = 0, i00_outer, t657 = 0, i01_outer, t659 = 0, i00_inner, t652 = 0, i01_inner, t661 = 0, i02 = t7, t663 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 570.991028

{ comp02[t5, t6, t7] -> comp02[0, t720 = 0, i00_outer, t722 = 0, i01_outer, t724 = 0, i02_outer, t726 = 0, i00_inner, t728 = 0, i01_inner, t717 = 0, i02_inner, t730 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 564.390015

{ comp02[t5, t6, t7] -> comp02[0, t803 = 0, i00_outer, t805 = 0, i01_outer, t807 = 0, i02_outer, t809 = 0, i00_inner, t811 = 0, i01_inner, t800 = 0, i02_inner, t813 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 526.752991

{ comp02[t5, t6, t7] -> comp02[0, t886 = 0, i00_outer, t888 = 0, i01_outer, t890 = 0, i02_outer, t892 = 0, i00_inner, t894 = 0, i01_inner, t883 = 0, i02_inner, t896 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 465.510010

{ comp02[t5, t6, t7] -> comp02[0, t956 = 0, i00_outer, t958 = 0, i01_outer, t960 = 0, i00_inner, t953 = 0, i01_inner, t962 = 0, i02 = t7, t964 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 548.333984

{ comp02[t5, t6, t7] -> comp02[0, t1021 = 0, i00_outer, t1023 = 0, i01_outer, t1025 = 0, i02_outer, t1027 = 0, i00_inner, t1029 = 0, i01_inner, t1018 = 0, i02_inner, t1031 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 532.867004

{ comp02[t5, t6, t7] -> comp02[0, t1104 = 0, i00_outer, t1106 = 0, i01_outer, t1108 = 0, i02_outer, t1110 = 0, i00_inner, t1112 = 0, i01_inner, t1101 = 0, i02_inner, t1114 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 522.460022

{ comp02[t5, t6, t7] -> comp02[0, t1187 = 0, i00_outer, t1189 = 0, i01_outer, t1191 = 0, i02_outer, t1193 = 0, i00_inner, t1195 = 0, i01_inner, t1184 = 0, i02_inner, t1197 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 503.415009

{ comp02[t5, t6, t7] -> comp02[0, t1257 = 0, i00_outer, t1259 = 0, i01_outer, t1261 = 0, i00_inner, t1254 = 0, i01_inner, t1263 = 0, i02 = t7, t1265 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 564.806030

{ comp02[t5, t6, t7] -> comp02[0, t1322 = 0, i00_outer, t1324 = 0, i01_outer, t1326 = 0, i02_outer, t1328 = 0, i00_inner, t1330 = 0, i01_inner, t1319 = 0, i02_inner, t1332 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 551.120972

{ comp02[t5, t6, t7] -> comp02[0, t1405 = 0, i00_outer, t1407 = 0, i01_outer, t1409 = 0, i02_outer, t1411 = 0, i00_inner, t1413 = 0, i01_inner, t1402 = 0, i02_inner, t1415 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 526.663025

{ comp02[t5, t6, t7] -> comp02[0, t1488 = 0, i00_outer, t1490 = 0, i01_outer, t1492 = 0, i02_outer, t1494 = 0, i00_inner, t1496 = 0, i01_inner, t1485 = 0, i02_inner, t1498 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 651.937012

{ comp02[t5, t6, t7] -> comp02[0, t1558 = 0, i00_outer, t1560 = 0, i01_outer, t1562 = 0, i00_inner, t1555 = 0, i01_inner, t1564 = 0, i02 = t7, t1566 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 661.578979

{ comp02[t5, t6, t7] -> comp02[0, t1623 = 0, i00_outer, t1625 = 0, i01_outer, t1627 = 0, i02_outer, t1629 = 0, i00_inner, t1631 = 0, i01_inner, t1620 = 0, i02_inner, t1633 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 567.177002

{ comp02[t5, t6, t7] -> comp02[0, t1706 = 0, i00_outer, t1708 = 0, i01_outer, t1710 = 0, i02_outer, t1712 = 0, i00_inner, t1714 = 0, i01_inner, t1703 = 0, i02_inner, t1716 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 524.849976

{ comp02[t5, t6, t7] -> comp02[0, t1789 = 0, i00_outer, t1791 = 0, i01_outer, t1793 = 0, i02_outer, t1795 = 0, i00_inner, t1797 = 0, i01_inner, t1786 = 0, i02_inner, t1799 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 465.721008

{ comp02[t5, t6, t7] -> comp02[0, t1859 = 0, i00_outer, t1861 = 0, i01_outer, t1863 = 0, i00_inner, t1856 = 0, i01_inner, t1865 = 0, i02 = t7, t1867 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 617.732971

{ comp02[t5, t6, t7] -> comp02[0, t1924 = 0, i00_outer, t1926 = 0, i01_outer, t1928 = 0, i02_outer, t1930 = 0, i00_inner, t1932 = 0, i01_inner, t1921 = 0, i02_inner, t1934 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 595.893005

{ comp02[t5, t6, t7] -> comp02[0, t2007 = 0, i00_outer, t2009 = 0, i01_outer, t2011 = 0, i02_outer, t2013 = 0, i00_inner, t2015 = 0, i01_inner, t2004 = 0, i02_inner, t2017 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 560.465027

{ comp02[t5, t6, t7] -> comp02[0, t2090 = 0, i00_outer, t2092 = 0, i01_outer, t2094 = 0, i02_outer, t2096 = 0, i00_inner, t2098 = 0, i01_inner, t2087 = 0, i02_inner, t2100 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 497.714996

{ comp02[t5, t6, t7] -> comp02[0, t2160 = 0, i00_outer, t2162 = 0, i01_outer, t2164 = 0, i00_inner, t2157 = 0, i01_inner, t2166 = 0, i02 = t7, t2168 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 690.112976

{ comp02[t5, t6, t7] -> comp02[0, t2225 = 0, i00_outer, t2227 = 0, i01_outer, t2229 = 0, i02_outer, t2231 = 0, i00_inner, t2233 = 0, i01_inner, t2222 = 0, i02_inner, t2235 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 613.106995

{ comp02[t5, t6, t7] -> comp02[0, t2308 = 0, i00_outer, t2310 = 0, i01_outer, t2312 = 0, i02_outer, t2314 = 0, i00_inner, t2316 = 0, i01_inner, t2305 = 0, i02_inner, t2318 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 563.525024

{ comp02[t5, t6, t7] -> comp02[0, t2391 = 0, i00_outer, t2393 = 0, i01_outer, t2395 = 0, i02_outer, t2397 = 0, i00_inner, t2399 = 0, i01_inner, t2388 = 0, i02_inner, t2401 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 617.916992

{ comp02[t5, t6, t7] -> comp02[0, t2461 = 0, i00_outer, t2463 = 0, i01_outer, t2465 = 0, i00_inner, t2458 = 0, i01_inner, t2467 = 0, i02 = t7, t2469 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 739.674011

{ comp02[t5, t6, t7] -> comp02[0, t2526 = 0, i00_outer, t2528 = 0, i01_outer, t2530 = 0, i02_outer, t2532 = 0, i00_inner, t2534 = 0, i01_inner, t2523 = 0, i02_inner, t2536 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 620.299988

{ comp02[t5, t6, t7] -> comp02[0, t2609 = 0, i00_outer, t2611 = 0, i01_outer, t2613 = 0, i02_outer, t2615 = 0, i00_inner, t2617 = 0, i01_inner, t2606 = 0, i02_inner, t2619 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 560.031006

{ comp02[t5, t6, t7] -> comp02[0, t2692 = 0, i00_outer, t2694 = 0, i01_outer, t2696 = 0, i02_outer, t2698 = 0, i00_inner, t2700 = 0, i01_inner, t2689 = 0, i02_inner, t2702 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 583.997009

{ comp02[t5, t6, t7] -> comp02[0, t2762 = 0, i00 = t5, t2764 = 0, i01_outer, t2766 = 0, i02_outer, t2768 = 0, i01_inner, t2759 = 0, i02_inner, t2770 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 602.468018

{ comp02[t5, t6, t7] -> comp02[0, t2814 = 0, i00 = t5, t2816 = 0, i01_outer, t2818 = 0, i02_outer, t2820 = 0, i01_inner, t2811 = 0, i02_inner, t2822 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 128
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 569.155029

{ comp02[t5, t6, t7] -> comp02[0, t2866 = 0, i00 = t5, t2868 = 0, i01_outer, t2870 = 0, i02_outer, t2872 = 0, i01_inner, t2863 = 0, i02_inner, t2874 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 596.987976

{ comp02[t5, t6, t7] -> comp02[0, t2918 = 0, i00 = t5, t2920 = 0, i01_outer, t2922 = 0, i02_outer, t2924 = 0, i01_inner, t2915 = 0, i02_inner, t2926 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 577.445984

{ comp02[t5, t6, t7] -> comp02[0, t2970 = 0, i00 = t5, t2972 = 0, i01_outer, t2974 = 0, i02_outer, t2976 = 0, i01_inner, t2967 = 0, i02_inner, t2978 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 128
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 585.513977

{ comp02[t5, t6, t7] -> comp02[0, t3022 = 0, i00 = t5, t3024 = 0, i01_outer, t3026 = 0, i02_outer, t3028 = 0, i01_inner, t3019 = 0, i02_inner, t3030 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 588.499023

{ comp02[t5, t6, t7] -> comp02[0, t3074 = 0, i00 = t5, t3076 = 0, i01_outer, t3078 = 0, i02_outer, t3080 = 0, i01_inner, t3071 = 0, i02_inner, t3082 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 577.806030

{ comp02[t5, t6, t7] -> comp02[0, t3126 = 0, i00 = t5, t3128 = 0, i01_outer, t3130 = 0, i02_outer, t3132 = 0, i01_inner, t3123 = 0, i02_inner, t3134 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 768) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 128
0- for 0 <= i00 < 768 | 0 | P
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 584.523010

{ comp02[t5, t6, t7] -> comp02[0, t3178 = 0, i00 = t5, t3180 = 0, i01_outer, t3182 = 0, i02_outer, t3184 = 0, i01_inner, t3175 = 0, i02_inner, t3186 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

original list
480.255005+514.174988+510.002014+510.730011+508.545990+540.476990+538.830994+522.353027+641.497009+570.991028+564.390015+526.752991+465.510010+548.333984+532.867004+522.460022+503.415009+564.806030+551.120972+526.663025+651.937012+661.578979+567.177002+524.849976+465.721008+617.732971+595.893005+560.465027+497.714996+690.112976+613.106995+563.525024+617.916992+739.674011+620.299988+560.031006+583.997009+602.468018+569.155029+596.987976+577.445984+585.513977+588.499023+577.806030+584.523010+534.739990+
remaining list
465.510010+465.721008+480.255005+497.714996+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 506.114990

{ comp02[t5, t6, t7] -> comp02[0, t956 = 0, i00_outer, t958 = 0, i01_outer, t960 = 0, i00_inner, t953 = 0, i01_inner, t962 = 0, i02 = t7, t964 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 534.414001

{ comp02[t5, t6, t7] -> comp02[0, t956 = 0, i00_outer, t958 = 0, i01_outer, t960 = 0, i00_inner, t953 = 0, i01_inner, t962 = 0, i02 = t7, t964 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 12 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 481.204987

{ comp02[t5, t6, t7] -> comp02[0, t956 = 0, i00_outer, t958 = 0, i01_outer, t960 = 0, i00_inner, t953 = 0, i01_inner, t962 = 0, i02 = t7, t964 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 505.729004

{ comp02[t5, t6, t7] -> comp02[0, t1859 = 0, i00_outer, t1861 = 0, i01_outer, t1863 = 0, i00_inner, t1856 = 0, i01_inner, t1865 = 0, i02 = t7, t1867 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 677.101990

{ comp02[t5, t6, t7] -> comp02[0, t1859 = 0, i00_outer, t1861 = 0, i01_outer, t1863 = 0, i00_inner, t1856 = 0, i01_inner, t1865 = 0, i02 = t7, t1867 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 488.372986

{ comp02[t5, t6, t7] -> comp02[0, t1859 = 0, i00_outer, t1861 = 0, i01_outer, t1863 = 0, i00_inner, t1856 = 0, i01_inner, t1865 = 0, i02 = t7, t1867 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 502.842010

{ comp02[t5, t6, t7] -> comp02[0, t53 = 0, i00_outer, t55 = 0, i01_outer, t57 = 0, i00_inner, t50 = 0, i01_inner, t59 = 0, i02 = t7, t61 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 534.552002

{ comp02[t5, t6, t7] -> comp02[0, t53 = 0, i00_outer, t55 = 0, i01_outer, t57 = 0, i00_inner, t50 = 0, i01_inner, t59 = 0, i02 = t7, t61 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 24 | 0 | P
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 484.910004

{ comp02[t5, t6, t7] -> comp02[0, t53 = 0, i00_outer, t55 = 0, i01_outer, t57 = 0, i00_inner, t50 = 0, i01_inner, t59 = 0, i02 = t7, t61 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 542.093018

{ comp02[t5, t6, t7] -> comp02[0, t2160 = 0, i00_outer, t2162 = 0, i01_outer, t2164 = 0, i00_inner, t2157 = 0, i01_inner, t2166 = 0, i02 = t7, t2168 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 698.398987

{ comp02[t5, t6, t7] -> comp02[0, t2160 = 0, i00_outer, t2162 = 0, i01_outer, t2164 = 0, i00_inner, t2157 = 0, i01_inner, t2166 = 0, i02 = t7, t2168 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0 | P
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 532.937012

{ comp02[t5, t6, t7] -> comp02[0, t2160 = 0, i00_outer, t2162 = 0, i01_outer, t2164 = 0, i00_inner, t2157 = 0, i01_inner, t2166 = 0, i02 = t7, t2168 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 461.622986

{ comp02[t5, t6, t7] -> comp02[0, t3770 = 0, i00_outer, t3772 = 0, i01_outer, t3774 = 0, i00_inner, t3767 = 0, i01_inner, t3776 = 0, i02 = t7, t3778 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 539.401978

{ comp02[t5, t6, t7] -> comp02[0, t3835 = 0, i00_outer, t3837 = 0, i01_outer, t3839 = 0, i02_outer, t3841 = 0, i00_inner, t3843 = 0, i01_inner, t3832 = 0, i02_inner, t3845 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 514.418030

{ comp02[t5, t6, t7] -> comp02[0, t3918 = 0, i00_outer, t3920 = 0, i01_outer, t3922 = 0, i02_outer, t3924 = 0, i00_inner, t3926 = 0, i01_inner, t3915 = 0, i02_inner, t3928 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 514.252014

{ comp02[t5, t6, t7] -> comp02[0, t4001 = 0, i00_outer, t4003 = 0, i01_outer, t4005 = 0, i02_outer, t4007 = 0, i00_inner, t4009 = 0, i01_inner, t3998 = 0, i02_inner, t4011 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 506.862000

{ comp02[t5, t6, t7] -> comp02[0, t4071 = 0, i00_outer, t4073 = 0, i01_outer, t4075 = 0, i00_inner, t4068 = 0, i01_inner, t4077 = 0, i02 = t7, t4079 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 573.898010

{ comp02[t5, t6, t7] -> comp02[0, t4136 = 0, i00_outer, t4138 = 0, i01_outer, t4140 = 0, i02_outer, t4142 = 0, i00_inner, t4144 = 0, i01_inner, t4133 = 0, i02_inner, t4146 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 539.867004

{ comp02[t5, t6, t7] -> comp02[0, t4219 = 0, i00_outer, t4221 = 0, i01_outer, t4223 = 0, i02_outer, t4225 = 0, i00_inner, t4227 = 0, i01_inner, t4216 = 0, i02_inner, t4229 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 523.299011

{ comp02[t5, t6, t7] -> comp02[0, t4302 = 0, i00_outer, t4304 = 0, i01_outer, t4306 = 0, i02_outer, t4308 = 0, i00_inner, t4310 = 0, i01_inner, t4299 = 0, i02_inner, t4312 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 638.700989

{ comp02[t5, t6, t7] -> comp02[0, t4372 = 0, i00_outer, t4374 = 0, i01_outer, t4376 = 0, i00_inner, t4369 = 0, i01_inner, t4378 = 0, i02 = t7, t4380 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 589.265991

{ comp02[t5, t6, t7] -> comp02[0, t4437 = 0, i00_outer, t4439 = 0, i01_outer, t4441 = 0, i02_outer, t4443 = 0, i00_inner, t4445 = 0, i01_inner, t4434 = 0, i02_inner, t4447 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 576.575989

{ comp02[t5, t6, t7] -> comp02[0, t4520 = 0, i00_outer, t4522 = 0, i01_outer, t4524 = 0, i02_outer, t4526 = 0, i00_inner, t4528 = 0, i01_inner, t4517 = 0, i02_inner, t4530 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 536.793030

{ comp02[t5, t6, t7] -> comp02[0, t4603 = 0, i00_outer, t4605 = 0, i01_outer, t4607 = 0, i02_outer, t4609 = 0, i00_inner, t4611 = 0, i01_inner, t4600 = 0, i02_inner, t4613 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 457.414001

{ comp02[t5, t6, t7] -> comp02[0, t4673 = 0, i00_outer, t4675 = 0, i01_outer, t4677 = 0, i00_inner, t4670 = 0, i01_inner, t4679 = 0, i02 = t7, t4681 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 539.452026

{ comp02[t5, t6, t7] -> comp02[0, t4738 = 0, i00_outer, t4740 = 0, i01_outer, t4742 = 0, i02_outer, t4744 = 0, i00_inner, t4746 = 0, i01_inner, t4735 = 0, i02_inner, t4748 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 522.703979

{ comp02[t5, t6, t7] -> comp02[0, t4821 = 0, i00_outer, t4823 = 0, i01_outer, t4825 = 0, i02_outer, t4827 = 0, i00_inner, t4829 = 0, i01_inner, t4818 = 0, i02_inner, t4831 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 507.717987

{ comp02[t5, t6, t7] -> comp02[0, t4904 = 0, i00_outer, t4906 = 0, i01_outer, t4908 = 0, i02_outer, t4910 = 0, i00_inner, t4912 = 0, i01_inner, t4901 = 0, i02_inner, t4914 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 14) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 496.842010

{ comp02[t5, t6, t7] -> comp02[0, t4974 = 0, i00_outer, t4976 = 0, i01_outer, t4978 = 0, i00_inner, t4971 = 0, i01_inner, t4980 = 0, i02 = t7, t4982 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 583.044006

{ comp02[t5, t6, t7] -> comp02[0, t5039 = 0, i00_outer, t5041 = 0, i01_outer, t5043 = 0, i02_outer, t5045 = 0, i00_inner, t5047 = 0, i01_inner, t5036 = 0, i02_inner, t5049 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 570.512024

{ comp02[t5, t6, t7] -> comp02[0, t5122 = 0, i00_outer, t5124 = 0, i01_outer, t5126 = 0, i02_outer, t5128 = 0, i00_inner, t5130 = 0, i01_inner, t5119 = 0, i02_inner, t5132 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 532.635010

{ comp02[t5, t6, t7] -> comp02[0, t5205 = 0, i00_outer, t5207 = 0, i01_outer, t5209 = 0, i02_outer, t5211 = 0, i00_inner, t5213 = 0, i01_inner, t5202 = 0, i02_inner, t5215 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 7) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 630.408020

{ comp02[t5, t6, t7] -> comp02[0, t5275 = 0, i00_outer, t5277 = 0, i01_outer, t5279 = 0, i00_inner, t5272 = 0, i01_inner, t5281 = 0, i02 = t7, t5283 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 678.375000

{ comp02[t5, t6, t7] -> comp02[0, t5340 = 0, i00_outer, t5342 = 0, i01_outer, t5344 = 0, i02_outer, t5346 = 0, i00_inner, t5348 = 0, i01_inner, t5337 = 0, i02_inner, t5350 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 592.531982

{ comp02[t5, t6, t7] -> comp02[0, t5423 = 0, i00_outer, t5425 = 0, i01_outer, t5427 = 0, i02_outer, t5429 = 0, i00_inner, t5431 = 0, i01_inner, t5420 = 0, i02_inner, t5433 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 531.158020

{ comp02[t5, t6, t7] -> comp02[0, t5506 = 0, i00_outer, t5508 = 0, i01_outer, t5510 = 0, i02_outer, t5512 = 0, i00_inner, t5514 = 0, i01_inner, t5503 = 0, i02_inner, t5516 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 458.272003

{ comp02[t5, t6, t7] -> comp02[0, t5576 = 0, i00_outer, t5578 = 0, i01_outer, t5580 = 0, i00_inner, t5573 = 0, i01_inner, t5582 = 0, i02 = t7, t5584 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 599.065979

{ comp02[t5, t6, t7] -> comp02[0, t5641 = 0, i00_outer, t5643 = 0, i01_outer, t5645 = 0, i02_outer, t5647 = 0, i00_inner, t5649 = 0, i01_inner, t5638 = 0, i02_inner, t5651 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 576.979004

{ comp02[t5, t6, t7] -> comp02[0, t5724 = 0, i00_outer, t5726 = 0, i01_outer, t5728 = 0, i02_outer, t5730 = 0, i00_inner, t5732 = 0, i01_inner, t5721 = 0, i02_inner, t5734 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 530.888977

{ comp02[t5, t6, t7] -> comp02[0, t5807 = 0, i00_outer, t5809 = 0, i01_outer, t5811 = 0, i02_outer, t5813 = 0, i00_inner, t5815 = 0, i01_inner, t5804 = 0, i02_inner, t5817 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 495.694000

{ comp02[t5, t6, t7] -> comp02[0, t5877 = 0, i00_outer, t5879 = 0, i01_outer, t5881 = 0, i00_inner, t5874 = 0, i01_inner, t5883 = 0, i02 = t7, t5885 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 682.721008

{ comp02[t5, t6, t7] -> comp02[0, t5942 = 0, i00_outer, t5944 = 0, i01_outer, t5946 = 0, i02_outer, t5948 = 0, i00_inner, t5950 = 0, i01_inner, t5939 = 0, i02_inner, t5952 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 596.994019

{ comp02[t5, t6, t7] -> comp02[0, t6025 = 0, i00_outer, t6027 = 0, i01_outer, t6029 = 0, i02_outer, t6031 = 0, i00_inner, t6033 = 0, i01_inner, t6022 = 0, i02_inner, t6035 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 546.549988

{ comp02[t5, t6, t7] -> comp02[0, t6108 = 0, i00_outer, t6110 = 0, i01_outer, t6112 = 0, i02_outer, t6114 = 0, i00_inner, t6116 = 0, i01_inner, t6105 = 0, i02_inner, t6118 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 7) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 629.218018

{ comp02[t5, t6, t7] -> comp02[0, t6178 = 0, i00_outer, t6180 = 0, i01_outer, t6182 = 0, i00_inner, t6175 = 0, i01_inner, t6184 = 0, i02 = t7, t6186 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 706.028015

{ comp02[t5, t6, t7] -> comp02[0, t6243 = 0, i00_outer, t6245 = 0, i01_outer, t6247 = 0, i02_outer, t6249 = 0, i00_inner, t6251 = 0, i01_inner, t6240 = 0, i02_inner, t6253 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 603.408020

{ comp02[t5, t6, t7] -> comp02[0, t6326 = 0, i00_outer, t6328 = 0, i01_outer, t6330 = 0, i02_outer, t6332 = 0, i00_inner, t6334 = 0, i01_inner, t6323 = 0, i02_inner, t6336 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 543.843994

{ comp02[t5, t6, t7] -> comp02[0, t6409 = 0, i00_outer, t6411 = 0, i01_outer, t6413 = 0, i02_outer, t6415 = 0, i00_inner, t6417 = 0, i01_inner, t6406 = 0, i02_inner, t6419 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 837.120972

{ comp02[t5, t6, t7] -> comp02[0, t6479 = 0, i00 = t5, t6481 = 0, i01_outer, t6483 = 0, i02_outer, t6485 = 0, i01_inner, t6476 = 0, i02_inner, t6487 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 798.630981

{ comp02[t5, t6, t7] -> comp02[0, t6531 = 0, i00 = t5, t6533 = 0, i01_outer, t6535 = 0, i02_outer, t6537 = 0, i01_inner, t6528 = 0, i02_inner, t6539 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 786.439026

{ comp02[t5, t6, t7] -> comp02[0, t6583 = 0, i00 = t5, t6585 = 0, i01_outer, t6587 = 0, i02_outer, t6589 = 0, i01_inner, t6580 = 0, i02_inner, t6591 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 890.161987

{ comp02[t5, t6, t7] -> comp02[0, t6635 = 0, i00 = t5, t6637 = 0, i01_outer, t6639 = 0, i02_outer, t6641 = 0, i01_inner, t6632 = 0, i02_inner, t6643 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 853.158020

{ comp02[t5, t6, t7] -> comp02[0, t6687 = 0, i00 = t5, t6689 = 0, i01_outer, t6691 = 0, i02_outer, t6693 = 0, i01_inner, t6684 = 0, i02_inner, t6695 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 830.739014

{ comp02[t5, t6, t7] -> comp02[0, t6739 = 0, i00 = t5, t6741 = 0, i01_outer, t6743 = 0, i02_outer, t6745 = 0, i01_inner, t6736 = 0, i02_inner, t6747 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 873.713989

{ comp02[t5, t6, t7] -> comp02[0, t6791 = 0, i00 = t5, t6793 = 0, i01_outer, t6795 = 0, i02_outer, t6797 = 0, i01_inner, t6788 = 0, i02_inner, t6799 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 854.434998

{ comp02[t5, t6, t7] -> comp02[0, t6843 = 0, i00 = t5, t6845 = 0, i01_outer, t6847 = 0, i02_outer, t6849 = 0, i01_inner, t6840 = 0, i02_inner, t6851 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    parallel (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0 | P
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 828.955017

{ comp02[t5, t6, t7] -> comp02[0, t6895 = 0, i00 = t5, t6897 = 0, i01_outer, t6899 = 0, i02_outer, t6901 = 0, i01_inner, t6892 = 0, i02_inner, t6903 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

original list
461.622986+539.401978+514.418030+514.252014+506.862000+573.898010+539.867004+523.299011+638.700989+589.265991+576.575989+536.793030+457.414001+539.452026+522.703979+507.717987+496.842010+583.044006+570.512024+532.635010+630.408020+678.375000+592.531982+531.158020+458.272003+599.065979+576.979004+530.888977+495.694000+682.721008+596.994019+546.549988+629.218018+706.028015+603.408020+543.843994+837.120972+798.630981+786.439026+890.161987+853.158020+830.739014+873.713989+854.434998+828.955017+730.505981+
remaining list
457.414001+458.272003+461.622986+495.694000+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 484.049988

{ comp02[t5, t6, t7] -> comp02[0, t4673 = 0, i00_outer, t4675 = 0, i01_outer, t4677 = 0, i00_inner, t4670 = 0, i01_inner, t4679 = 0, i02 = t7, t4681 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 548.059021

{ comp02[t5, t6, t7] -> comp02[0, t4673 = 0, i00_outer, t4675 = 0, i01_outer, t4677 = 0, i00_inner, t4670 = 0, i01_inner, t4679 = 0, i02 = t7, t4681 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    parallel (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 457.058014

{ comp02[t5, t6, t7] -> comp02[0, t4673 = 0, i00_outer, t4675 = 0, i01_outer, t4677 = 0, i00_inner, t4670 = 0, i01_inner, t4679 = 0, i02 = t7, t4681 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 472.084015

{ comp02[t5, t6, t7] -> comp02[0, t5576 = 0, i00_outer, t5578 = 0, i01_outer, t5580 = 0, i00_inner, t5573 = 0, i01_inner, t5582 = 0, i02 = t7, t5584 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 527.859985

{ comp02[t5, t6, t7] -> comp02[0, t5576 = 0, i00_outer, t5578 = 0, i01_outer, t5580 = 0, i00_inner, t5573 = 0, i01_inner, t5582 = 0, i02 = t7, t5584 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 458.088989

{ comp02[t5, t6, t7] -> comp02[0, t5576 = 0, i00_outer, t5578 = 0, i01_outer, t5580 = 0, i00_inner, t5573 = 0, i01_inner, t5582 = 0, i02 = t7, t5584 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 480.800995

{ comp02[t5, t6, t7] -> comp02[0, t3770 = 0, i00_outer, t3772 = 0, i01_outer, t3774 = 0, i00_inner, t3767 = 0, i01_inner, t3776 = 0, i02 = t7, t3778 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 538.888000

{ comp02[t5, t6, t7] -> comp02[0, t3770 = 0, i00_outer, t3772 = 0, i01_outer, t3774 = 0, i00_inner, t3767 = 0, i01_inner, t3776 = 0, i02 = t7, t3778 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    parallel (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 465.985992

{ comp02[t5, t6, t7] -> comp02[0, t3770 = 0, i00_outer, t3772 = 0, i01_outer, t3774 = 0, i00_inner, t3767 = 0, i01_inner, t3776 = 0, i02 = t7, t3778 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 535.187988

{ comp02[t5, t6, t7] -> comp02[0, t5877 = 0, i00_outer, t5879 = 0, i01_outer, t5881 = 0, i00_inner, t5874 = 0, i01_inner, t5883 = 0, i02 = t7, t5885 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 610.307983

{ comp02[t5, t6, t7] -> comp02[0, t5877 = 0, i00_outer, t5879 = 0, i01_outer, t5881 = 0, i00_inner, t5874 = 0, i01_inner, t5883 = 0, i02 = t7, t5885 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    parallel (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 496.437988

{ comp02[t5, t6, t7] -> comp02[0, t5877 = 0, i00_outer, t5879 = 0, i01_outer, t5881 = 0, i00_inner, t5874 = 0, i01_inner, t5883 = 0, i02 = t7, t5885 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 577.398987

{ comp02[t5, t6, t7] -> comp02[0, t7487 = 0, i00_outer, t7489 = 0, i01_outer, t7491 = 0, i00_inner, t7484 = 0, i01_inner, t7493 = 0, i02 = t7, t7495 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1112.160034

{ comp02[t5, t6, t7] -> comp02[0, t7551 = 0, i00_outer, t7553 = 0, i01_outer, t7555 = 0, i02_outer, t7557 = 0, i00_inner, t7559 = 0, i01_inner, t7548 = 0, i02_inner, t7561 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1018.140015

{ comp02[t5, t6, t7] -> comp02[0, t7633 = 0, i00_outer, t7635 = 0, i01_outer, t7637 = 0, i02_outer, t7639 = 0, i00_inner, t7641 = 0, i01_inner, t7630 = 0, i02_inner, t7643 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 944.659973

{ comp02[t5, t6, t7] -> comp02[0, t7715 = 0, i00_outer, t7717 = 0, i01_outer, t7719 = 0, i02_outer, t7721 = 0, i00_inner, t7723 = 0, i01_inner, t7712 = 0, i02_inner, t7725 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 577.421021

{ comp02[t5, t6, t7] -> comp02[0, t7784 = 0, i00_outer, t7786 = 0, i01_outer, t7788 = 0, i00_inner, t7781 = 0, i01_inner, t7790 = 0, i02 = t7, t7792 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1143.170044

{ comp02[t5, t6, t7] -> comp02[0, t7848 = 0, i00_outer, t7850 = 0, i01_outer, t7852 = 0, i02_outer, t7854 = 0, i00_inner, t7856 = 0, i01_inner, t7845 = 0, i02_inner, t7858 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1075.949951

{ comp02[t5, t6, t7] -> comp02[0, t7930 = 0, i00_outer, t7932 = 0, i01_outer, t7934 = 0, i02_outer, t7936 = 0, i00_inner, t7938 = 0, i01_inner, t7927 = 0, i02_inner, t7940 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 968.755981

{ comp02[t5, t6, t7] -> comp02[0, t8012 = 0, i00_outer, t8014 = 0, i01_outer, t8016 = 0, i02_outer, t8018 = 0, i00_inner, t8020 = 0, i01_inner, t8009 = 0, i02_inner, t8022 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 583.239990

{ comp02[t5, t6, t7] -> comp02[0, t8081 = 0, i00_outer, t8083 = 0, i01_outer, t8085 = 0, i00_inner, t8078 = 0, i01_inner, t8087 = 0, i02 = t7, t8089 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1133.469971

{ comp02[t5, t6, t7] -> comp02[0, t8145 = 0, i00_outer, t8147 = 0, i01_outer, t8149 = 0, i02_outer, t8151 = 0, i00_inner, t8153 = 0, i01_inner, t8142 = 0, i02_inner, t8155 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1089.119995

{ comp02[t5, t6, t7] -> comp02[0, t8227 = 0, i00_outer, t8229 = 0, i01_outer, t8231 = 0, i02_outer, t8233 = 0, i00_inner, t8235 = 0, i01_inner, t8224 = 0, i02_inner, t8237 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 998.257996

{ comp02[t5, t6, t7] -> comp02[0, t8309 = 0, i00_outer, t8311 = 0, i01_outer, t8313 = 0, i02_outer, t8315 = 0, i00_inner, t8317 = 0, i01_inner, t8306 = 0, i02_inner, t8319 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 572.140991

{ comp02[t5, t6, t7] -> comp02[0, t8378 = 0, i00_outer, t8380 = 0, i01_outer, t8382 = 0, i00_inner, t8375 = 0, i01_inner, t8384 = 0, i02 = t7, t8386 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1145.829956

{ comp02[t5, t6, t7] -> comp02[0, t8442 = 0, i00_outer, t8444 = 0, i01_outer, t8446 = 0, i02_outer, t8448 = 0, i00_inner, t8450 = 0, i01_inner, t8439 = 0, i02_inner, t8452 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1068.489990

{ comp02[t5, t6, t7] -> comp02[0, t8524 = 0, i00_outer, t8526 = 0, i01_outer, t8528 = 0, i02_outer, t8530 = 0, i00_inner, t8532 = 0, i01_inner, t8521 = 0, i02_inner, t8534 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 956.419006

{ comp02[t5, t6, t7] -> comp02[0, t8606 = 0, i00_outer, t8608 = 0, i01_outer, t8610 = 0, i02_outer, t8612 = 0, i00_inner, t8614 = 0, i01_inner, t8603 = 0, i02_inner, t8616 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 576.651978

{ comp02[t5, t6, t7] -> comp02[0, t8675 = 0, i00_outer, t8677 = 0, i01_outer, t8679 = 0, i00_inner, t8672 = 0, i01_inner, t8681 = 0, i02 = t7, t8683 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1130.390015

{ comp02[t5, t6, t7] -> comp02[0, t8739 = 0, i00_outer, t8741 = 0, i01_outer, t8743 = 0, i02_outer, t8745 = 0, i00_inner, t8747 = 0, i01_inner, t8736 = 0, i02_inner, t8749 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1078.780029

{ comp02[t5, t6, t7] -> comp02[0, t8821 = 0, i00_outer, t8823 = 0, i01_outer, t8825 = 0, i02_outer, t8827 = 0, i00_inner, t8829 = 0, i01_inner, t8818 = 0, i02_inner, t8831 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 968.942993

{ comp02[t5, t6, t7] -> comp02[0, t8903 = 0, i00_outer, t8905 = 0, i01_outer, t8907 = 0, i02_outer, t8909 = 0, i00_inner, t8911 = 0, i01_inner, t8900 = 0, i02_inner, t8913 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 574.317993

{ comp02[t5, t6, t7] -> comp02[0, t8972 = 0, i00_outer, t8974 = 0, i01_outer, t8976 = 0, i00_inner, t8969 = 0, i01_inner, t8978 = 0, i02 = t7, t8980 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1127.020020

{ comp02[t5, t6, t7] -> comp02[0, t9036 = 0, i00_outer, t9038 = 0, i01_outer, t9040 = 0, i02_outer, t9042 = 0, i00_inner, t9044 = 0, i01_inner, t9033 = 0, i02_inner, t9046 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1080.530029

{ comp02[t5, t6, t7] -> comp02[0, t9118 = 0, i00_outer, t9120 = 0, i01_outer, t9122 = 0, i02_outer, t9124 = 0, i00_inner, t9126 = 0, i01_inner, t9115 = 0, i02_inner, t9128 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 1022.830017

{ comp02[t5, t6, t7] -> comp02[0, t9200 = 0, i00_outer, t9202 = 0, i01_outer, t9204 = 0, i02_outer, t9206 = 0, i00_inner, t9208 = 0, i01_inner, t9197 = 0, i02_inner, t9210 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 575.971985

{ comp02[t5, t6, t7] -> comp02[0, t9269 = 0, i00_outer, t9271 = 0, i01_outer, t9273 = 0, i00_inner, t9266 = 0, i01_inner, t9275 = 0, i02 = t7, t9277 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1143.520020

{ comp02[t5, t6, t7] -> comp02[0, t9333 = 0, i00_outer, t9335 = 0, i01_outer, t9337 = 0, i02_outer, t9339 = 0, i00_inner, t9341 = 0, i01_inner, t9330 = 0, i02_inner, t9343 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1077.969971

{ comp02[t5, t6, t7] -> comp02[0, t9415 = 0, i00_outer, t9417 = 0, i01_outer, t9419 = 0, i02_outer, t9421 = 0, i00_inner, t9423 = 0, i01_inner, t9412 = 0, i02_inner, t9425 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 960.822998

{ comp02[t5, t6, t7] -> comp02[0, t9497 = 0, i00_outer, t9499 = 0, i01_outer, t9501 = 0, i02_outer, t9503 = 0, i00_inner, t9505 = 0, i01_inner, t9494 = 0, i02_inner, t9507 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 568.502991

{ comp02[t5, t6, t7] -> comp02[0, t9566 = 0, i00_outer, t9568 = 0, i01_outer, t9570 = 0, i00_inner, t9563 = 0, i01_inner, t9572 = 0, i02 = t7, t9574 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1136.869995

{ comp02[t5, t6, t7] -> comp02[0, t9630 = 0, i00_outer, t9632 = 0, i01_outer, t9634 = 0, i02_outer, t9636 = 0, i00_inner, t9638 = 0, i01_inner, t9627 = 0, i02_inner, t9640 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1081.959961

{ comp02[t5, t6, t7] -> comp02[0, t9712 = 0, i00_outer, t9714 = 0, i01_outer, t9716 = 0, i02_outer, t9718 = 0, i00_inner, t9720 = 0, i01_inner, t9709 = 0, i02_inner, t9722 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 1010.049988

{ comp02[t5, t6, t7] -> comp02[0, t9794 = 0, i00_outer, t9796 = 0, i01_outer, t9798 = 0, i02_outer, t9800 = 0, i00_inner, t9802 = 0, i01_inner, t9791 = 0, i02_inner, t9804 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0
					comp02
Evaluation : 575.864990

{ comp02[t5, t6, t7] -> comp02[0, t9863 = 0, i00_outer, t9865 = 0, i01_outer, t9867 = 0, i00_inner, t9860 = 0, i01_inner, t9869 = 0, i02 = t7, t9871 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 1182.160034

{ comp02[t5, t6, t7] -> comp02[0, t9927 = 0, i00_outer, t9929 = 0, i01_outer, t9931 = 0, i02_outer, t9933 = 0, i00_inner, t9935 = 0, i01_inner, t9924 = 0, i02_inner, t9937 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 1157.689941

{ comp02[t5, t6, t7] -> comp02[0, t10009 = 0, i00_outer, t10011 = 0, i01_outer, t10013 = 0, i02_outer, t10015 = 0, i00_inner, t10017 = 0, i01_inner, t10006 = 0, i02_inner, t10019 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 1054.119995

{ comp02[t5, t6, t7] -> comp02[0, t10091 = 0, i00_outer, t10093 = 0, i01_outer, t10095 = 0, i02_outer, t10097 = 0, i00_inner, t10099 = 0, i01_inner, t10088 = 0, i02_inner, t10101 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 28) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 1602.150024

{ comp02[t5, t6, t7] -> comp02[0, t10160 = 0, i00 = t5, t10162 = 0, i01_outer, t10164 = 0, i02_outer, t10166 = 0, i01_inner, t10157 = 0, i02_inner, t10168 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 28) {
      for (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 1510.689941

{ comp02[t5, t6, t7] -> comp02[0, t10211 = 0, i00 = t5, t10213 = 0, i01_outer, t10215 = 0, i02_outer, t10217 = 0, i01_inner, t10208 = 0, i02_inner, t10219 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 28) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 1447.079956

{ comp02[t5, t6, t7] -> comp02[0, t10262 = 0, i00 = t5, t10264 = 0, i01_outer, t10266 = 0, i02_outer, t10268 = 0, i01_inner, t10259 = 0, i02_inner, t10270 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 14) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 1625.510010

{ comp02[t5, t6, t7] -> comp02[0, t10313 = 0, i00 = t5, t10315 = 0, i01_outer, t10317 = 0, i02_outer, t10319 = 0, i01_inner, t10310 = 0, i02_inner, t10321 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 14) {
      for (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 1522.189941

{ comp02[t5, t6, t7] -> comp02[0, t10364 = 0, i00 = t5, t10366 = 0, i01_outer, t10368 = 0, i02_outer, t10370 = 0, i01_inner, t10361 = 0, i02_inner, t10372 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 14) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 1481.939941

{ comp02[t5, t6, t7] -> comp02[0, t10415 = 0, i00 = t5, t10417 = 0, i01_outer, t10419 = 0, i02_outer, t10421 = 0, i01_inner, t10412 = 0, i02_inner, t10423 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 7) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 1605.420044

{ comp02[t5, t6, t7] -> comp02[0, t10466 = 0, i00 = t5, t10468 = 0, i01_outer, t10470 = 0, i02_outer, t10472 = 0, i01_inner, t10463 = 0, i02_inner, t10474 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 7) {
      for (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 1532.810059

{ comp02[t5, t6, t7] -> comp02[0, t10517 = 0, i00 = t5, t10519 = 0, i01_outer, t10521 = 0, i02_outer, t10523 = 0, i01_inner, t10514 = 0, i02_inner, t10525 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 7) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 1464.910034

{ comp02[t5, t6, t7] -> comp02[0, t10568 = 0, i00 = t5, t10570 = 0, i01_outer, t10572 = 0, i02_outer, t10574 = 0, i01_inner, t10565 = 0, i02_inner, t10576 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

original list
577.398987+1112.160034+1018.140015+944.659973+577.421021+1143.170044+1075.949951+968.755981+583.239990+1133.469971+1089.119995+998.257996+572.140991+1145.829956+1068.489990+956.419006+576.651978+1130.390015+1078.780029+968.942993+574.317993+1127.020020+1080.530029+1022.830017+575.971985+1143.520020+1077.969971+960.822998+568.502991+1136.869995+1081.959961+1010.049988+575.864990+1182.160034+1157.689941+1054.119995+1602.150024+1510.689941+1447.079956+1625.510010+1522.189941+1481.939941+1605.420044+1532.810059+1464.910034+856.083008+
remaining list
568.502991+572.140991+574.317993+575.864990+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 1064.800049

{ comp02[t5, t6, t7] -> comp02[0, t9566 = 0, i00_outer, t9568 = 0, i01_outer, t9570 = 0, i00_inner, t9563 = 0, i01_inner, t9572 = 0, i02 = t7, t9574 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 1908.569946

{ comp02[t5, t6, t7] -> comp02[0, t9566 = 0, i00_outer, t9568 = 0, i01_outer, t9570 = 0, i00_inner, t9563 = 0, i01_inner, t9572 = 0, i02 = t7, t9574 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 564.411011

{ comp02[t5, t6, t7] -> comp02[0, t9566 = 0, i00_outer, t9568 = 0, i01_outer, t9570 = 0, i00_inner, t9563 = 0, i01_inner, t9572 = 0, i02 = t7, t9574 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 1146.729980

{ comp02[t5, t6, t7] -> comp02[0, t8378 = 0, i00_outer, t8380 = 0, i01_outer, t8382 = 0, i00_inner, t8375 = 0, i01_inner, t8384 = 0, i02 = t7, t8386 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 1900.640015

{ comp02[t5, t6, t7] -> comp02[0, t8378 = 0, i00_outer, t8380 = 0, i01_outer, t8382 = 0, i00_inner, t8375 = 0, i01_inner, t8384 = 0, i02 = t7, t8386 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 571.348022

{ comp02[t5, t6, t7] -> comp02[0, t8378 = 0, i00_outer, t8380 = 0, i01_outer, t8382 = 0, i00_inner, t8375 = 0, i01_inner, t8384 = 0, i02 = t7, t8386 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L4 4
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 1244.300049

{ comp02[t5, t6, t7] -> comp02[0, t8972 = 0, i00_outer, t8974 = 0, i01_outer, t8976 = 0, i00_inner, t8969 = 0, i01_inner, t8978 = 0, i02 = t7, t8980 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L4 8
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 1918.229980

{ comp02[t5, t6, t7] -> comp02[0, t8972 = 0, i00_outer, t8974 = 0, i01_outer, t8976 = 0, i00_inner, t8969 = 0, i01_inner, t8978 = 0, i02 = t7, t8980 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L4 16
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 573.653992

{ comp02[t5, t6, t7] -> comp02[0, t8972 = 0, i00_outer, t8974 = 0, i01_outer, t8976 = 0, i00_inner, t8969 = 0, i01_inner, t8978 = 0, i02 = t7, t8980 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_outer < 256 | 0
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 1067.209961

{ comp02[t5, t6, t7] -> comp02[0, t9863 = 0, i00_outer, t9865 = 0, i01_outer, t9867 = 0, i00_inner, t9860 = 0, i01_inner, t9869 = 0, i02 = t7, t9871 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_outer < 128 | 0
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 1888.369995

{ comp02[t5, t6, t7] -> comp02[0, t9863 = 0, i00_outer, t9865 = 0, i01_outer, t9867 = 0, i00_inner, t9860 = 0, i01_inner, t9869 = 0, i02 = t7, t9871 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_outer < 64 | 0
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 574.010010

{ comp02[t5, t6, t7] -> comp02[0, t9863 = 0, i00_outer, t9865 = 0, i01_outer, t9867 = 0, i00_inner, t9860 = 0, i01_inner, t9869 = 0, i02 = t7, t9871 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 473.074005

{ comp02[t5, t6, t7] -> comp02[0, t11147 = 0, i00_outer, t11149 = 0, i01_outer, t11151 = 0, i00_inner, t11144 = 0, i01_inner, t11153 = 0, i02 = t7, t11155 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 605.020996

{ comp02[t5, t6, t7] -> comp02[0, t11212 = 0, i00_outer, t11214 = 0, i01_outer, t11216 = 0, i02_outer, t11218 = 0, i00_inner, t11220 = 0, i01_inner, t11209 = 0, i02_inner, t11222 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      parallel (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 589.242981

{ comp02[t5, t6, t7] -> comp02[0, t11295 = 0, i00_outer, t11297 = 0, i01_outer, t11299 = 0, i02_outer, t11301 = 0, i00_inner, t11303 = 0, i01_inner, t11292 = 0, i02_inner, t11305 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 28) {
      parallel (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 568.969971

{ comp02[t5, t6, t7] -> comp02[0, t11378 = 0, i00_outer, t11380 = 0, i01_outer, t11382 = 0, i02_outer, t11384 = 0, i00_inner, t11386 = 0, i01_inner, t11375 = 0, i02_inner, t11388 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 468.190002

{ comp02[t5, t6, t7] -> comp02[0, t11448 = 0, i00_outer, t11450 = 0, i01_outer, t11452 = 0, i00_inner, t11445 = 0, i01_inner, t11454 = 0, i02 = t7, t11456 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 611.138000

{ comp02[t5, t6, t7] -> comp02[0, t11513 = 0, i00_outer, t11515 = 0, i01_outer, t11517 = 0, i02_outer, t11519 = 0, i00_inner, t11521 = 0, i01_inner, t11510 = 0, i02_inner, t11523 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 590.770996

{ comp02[t5, t6, t7] -> comp02[0, t11596 = 0, i00_outer, t11598 = 0, i01_outer, t11600 = 0, i02_outer, t11602 = 0, i00_inner, t11604 = 0, i01_inner, t11593 = 0, i02_inner, t11606 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 585.062988

{ comp02[t5, t6, t7] -> comp02[0, t11679 = 0, i00_outer, t11681 = 0, i01_outer, t11683 = 0, i02_outer, t11685 = 0, i00_inner, t11687 = 0, i01_inner, t11676 = 0, i02_inner, t11689 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 479.722992

{ comp02[t5, t6, t7] -> comp02[0, t11749 = 0, i00_outer, t11751 = 0, i01_outer, t11753 = 0, i00_inner, t11746 = 0, i01_inner, t11755 = 0, i02 = t7, t11757 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 632.114990

{ comp02[t5, t6, t7] -> comp02[0, t11814 = 0, i00_outer, t11816 = 0, i01_outer, t11818 = 0, i02_outer, t11820 = 0, i00_inner, t11822 = 0, i01_inner, t11811 = 0, i02_inner, t11824 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      parallel (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 645.315002

{ comp02[t5, t6, t7] -> comp02[0, t11897 = 0, i00_outer, t11899 = 0, i01_outer, t11901 = 0, i02_outer, t11903 = 0, i00_inner, t11905 = 0, i01_inner, t11894 = 0, i02_inner, t11907 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 7) {
      parallel (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*32) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 562.594971

{ comp02[t5, t6, t7] -> comp02[0, t11980 = 0, i00_outer, t11982 = 0, i01_outer, t11984 = 0, i02_outer, t11986 = 0, i00_inner, t11988 = 0, i01_inner, t11977 = 0, i02_inner, t11990 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      parallel (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 468.382996

{ comp02[t5, t6, t7] -> comp02[0, t12050 = 0, i00_outer, t12052 = 0, i01_outer, t12054 = 0, i00_inner, t12047 = 0, i01_inner, t12056 = 0, i02 = t7, t12058 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 623.206970

{ comp02[t5, t6, t7] -> comp02[0, t12115 = 0, i00_outer, t12117 = 0, i01_outer, t12119 = 0, i02_outer, t12121 = 0, i00_inner, t12123 = 0, i01_inner, t12112 = 0, i02_inner, t12125 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 596.596985

{ comp02[t5, t6, t7] -> comp02[0, t12198 = 0, i00_outer, t12200 = 0, i01_outer, t12202 = 0, i02_outer, t12204 = 0, i00_inner, t12206 = 0, i01_inner, t12195 = 0, i02_inner, t12208 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 28) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 571.552002

{ comp02[t5, t6, t7] -> comp02[0, t12281 = 0, i00_outer, t12283 = 0, i01_outer, t12285 = 0, i02_outer, t12287 = 0, i00_inner, t12289 = 0, i01_inner, t12278 = 0, i02_inner, t12291 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 460.592010

{ comp02[t5, t6, t7] -> comp02[0, t12351 = 0, i00_outer, t12353 = 0, i01_outer, t12355 = 0, i00_inner, t12348 = 0, i01_inner, t12357 = 0, i02 = t7, t12359 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 659.166992

{ comp02[t5, t6, t7] -> comp02[0, t12416 = 0, i00_outer, t12418 = 0, i01_outer, t12420 = 0, i02_outer, t12422 = 0, i00_inner, t12424 = 0, i01_inner, t12413 = 0, i02_inner, t12426 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 645.750000

{ comp02[t5, t6, t7] -> comp02[0, t12499 = 0, i00_outer, t12501 = 0, i01_outer, t12503 = 0, i02_outer, t12505 = 0, i00_inner, t12507 = 0, i01_inner, t12496 = 0, i02_inner, t12509 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 554.968018

{ comp02[t5, t6, t7] -> comp02[0, t12582 = 0, i00_outer, t12584 = 0, i01_outer, t12586 = 0, i02_outer, t12588 = 0, i00_inner, t12590 = 0, i01_inner, t12579 = 0, i02_inner, t12592 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      parallel (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 485.381012

{ comp02[t5, t6, t7] -> comp02[0, t12652 = 0, i00_outer, t12654 = 0, i01_outer, t12656 = 0, i00_inner, t12649 = 0, i01_inner, t12658 = 0, i02 = t7, t12660 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 685.651978

{ comp02[t5, t6, t7] -> comp02[0, t12717 = 0, i00_outer, t12719 = 0, i01_outer, t12721 = 0, i02_outer, t12723 = 0, i00_inner, t12725 = 0, i01_inner, t12714 = 0, i02_inner, t12727 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 641.507019

{ comp02[t5, t6, t7] -> comp02[0, t12800 = 0, i00_outer, t12802 = 0, i01_outer, t12804 = 0, i02_outer, t12806 = 0, i00_inner, t12808 = 0, i01_inner, t12797 = 0, i02_inner, t12810 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 7) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*64) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 559.080017

{ comp02[t5, t6, t7] -> comp02[0, t12883 = 0, i00_outer, t12885 = 0, i01_outer, t12887 = 0, i02_outer, t12889 = 0, i00_inner, t12891 = 0, i01_inner, t12880 = 0, i02_inner, t12893 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 466.046997

{ comp02[t5, t6, t7] -> comp02[0, t12953 = 0, i00_outer, t12955 = 0, i01_outer, t12957 = 0, i00_inner, t12950 = 0, i01_inner, t12959 = 0, i02 = t7, t12961 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 653.585999

{ comp02[t5, t6, t7] -> comp02[0, t13018 = 0, i00_outer, t13020 = 0, i01_outer, t13022 = 0, i02_outer, t13024 = 0, i00_inner, t13026 = 0, i01_inner, t13015 = 0, i02_inner, t13028 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 838.198975

{ comp02[t5, t6, t7] -> comp02[0, t13101 = 0, i00_outer, t13103 = 0, i01_outer, t13105 = 0, i02_outer, t13107 = 0, i00_inner, t13109 = 0, i01_inner, t13098 = 0, i02_inner, t13111 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*32) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*32) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 575.442017

{ comp02[t5, t6, t7] -> comp02[0, t13184 = 0, i00_outer, t13186 = 0, i01_outer, t13188 = 0, i02_outer, t13190 = 0, i00_inner, t13192 = 0, i01_inner, t13181 = 0, i02_inner, t13194 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 455.428009

{ comp02[t5, t6, t7] -> comp02[0, t13254 = 0, i00_outer, t13256 = 0, i01_outer, t13258 = 0, i00_inner, t13251 = 0, i01_inner, t13260 = 0, i02 = t7, t13262 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 690.573975

{ comp02[t5, t6, t7] -> comp02[0, t13319 = 0, i00_outer, t13321 = 0, i01_outer, t13323 = 0, i02_outer, t13325 = 0, i00_inner, t13327 = 0, i01_inner, t13316 = 0, i02_inner, t13329 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 617.918030

{ comp02[t5, t6, t7] -> comp02[0, t13402 = 0, i00_outer, t13404 = 0, i01_outer, t13406 = 0, i02_outer, t13408 = 0, i00_inner, t13410 = 0, i01_inner, t13399 = 0, i02_inner, t13412 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*64) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*64) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 554.318970

{ comp02[t5, t6, t7] -> comp02[0, t13485 = 0, i00_outer, t13487 = 0, i01_outer, t13489 = 0, i02_outer, t13491 = 0, i00_inner, t13493 = 0, i01_inner, t13482 = 0, i02_inner, t13495 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 1024) {
            buf02[((c9 + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c9) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((c9 + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c9) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 1024 | 0 | P
					comp02
Evaluation : 475.858002

{ comp02[t5, t6, t7] -> comp02[0, t13555 = 0, i00_outer, t13557 = 0, i01_outer, t13559 = 0, i00_inner, t13552 = 0, i01_inner, t13561 = 0, i02 = t7, t13563 = 0] : (t6 - i01_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf02[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						comp02
Evaluation : 728.481995

{ comp02[t5, t6, t7] -> comp02[0, t13620 = 0, i00_outer, t13622 = 0, i01_outer, t13624 = 0, i02_outer, t13626 = 0, i00_inner, t13628 = 0, i01_inner, t13617 = 0, i02_inner, t13630 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf02[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						comp02
Evaluation : 631.468994

{ comp02[t5, t6, t7] -> comp02[0, t13703 = 0, i00_outer, t13705 = 0, i01_outer, t13707 = 0, i02_outer, t13709 = 0, i00_inner, t13711 = 0, i01_inner, t13700 = 0, i02_inner, t13713 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
Tiling3 loop names: i00 i01 i02  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 7) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf02[((((c5*128) + c11) + int32((int64(((c3*128) + c9))*(int64)1024))) + int32((int64(((c1*128) + c7))*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c7))*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32((int64(((c3*128) + c9))*(int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)1)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c11) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c11)) + (int64)2)) + int32(((int64(((c3*128) + c9))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c7))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 128 | 0
						comp02
Evaluation : 551.997986

{ comp02[t5, t6, t7] -> comp02[0, t13786 = 0, i00_outer, t13788 = 0, i01_outer, t13790 = 0, i02_outer, t13792 = 0, i00_inner, t13794 = 0, i01_inner, t13783 = 0, i02_inner, t13796 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 28) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 1099.359985

{ comp02[t5, t6, t7] -> comp02[0, t13856 = 0, i00 = t5, t13858 = 0, i01_outer, t13860 = 0, i02_outer, t13862 = 0, i01_inner, t13853 = 0, i02_inner, t13864 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 28) {
      parallel (c5, 0, 16) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 1161.959961

{ comp02[t5, t6, t7] -> comp02[0, t13908 = 0, i00 = t5, t13910 = 0, i01_outer, t13912 = 0, i02_outer, t13914 = 0, i01_inner, t13905 = 0, i02_inner, t13916 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 28) {
      parallel (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 1069.170044

{ comp02[t5, t6, t7] -> comp02[0, t13960 = 0, i00 = t5, t13962 = 0, i01_outer, t13964 = 0, i02_outer, t13966 = 0, i01_inner, t13957 = 0, i02_inner, t13968 = 0] : (t6 - i01_inner) mod 32 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t6 <= 32i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 1056.290039

{ comp02[t5, t6, t7] -> comp02[0, t14012 = 0, i00 = t5, t14014 = 0, i01_outer, t14016 = 0, i02_outer, t14018 = 0, i01_inner, t14009 = 0, i02_inner, t14020 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 14) {
      parallel (c5, 0, 16) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 978.174988

{ comp02[t5, t6, t7] -> comp02[0, t14064 = 0, i00 = t5, t14066 = 0, i01_outer, t14068 = 0, i02_outer, t14070 = 0, i01_inner, t14061 = 0, i02_inner, t14072 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 14) {
      parallel (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 918.663025

{ comp02[t5, t6, t7] -> comp02[0, t14116 = 0, i00 = t5, t14118 = 0, i01_outer, t14120 = 0, i02_outer, t14122 = 0, i01_inner, t14113 = 0, i02_inner, t14124 = 0] : (t6 - i01_inner) mod 64 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t6 <= 64i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 7) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            buf02[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*32) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 32
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 32 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					comp02
Evaluation : 1074.119995

{ comp02[t5, t6, t7] -> comp02[0, t14168 = 0, i00 = t5, t14170 = 0, i01_outer, t14172 = 0, i02_outer, t14174 = 0, i01_inner, t14165 = 0, i02_inner, t14176 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -31 + t7 <= 32i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 7) {
      parallel (c5, 0, 16) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            buf02[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*64) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 16 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					comp02
Evaluation : 901.195007

{ comp02[t5, t6, t7] -> comp02[0, t14220 = 0, i00 = t5, t14222 = 0, i01_outer, t14224 = 0, i02_outer, t14226 = 0, i01_inner, t14217 = 0, i02_inner, t14228 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -63 + t7 <= 64i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>
 Tiling 2 loop names: i00 i01 i02  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 768) {
    for (c3, 0, 7) {
      parallel (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            buf02[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)917504)))] = ((((((buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32((int64(c1)*(int64)921348)))] + (buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) + buf00[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c5*128) + c9)) + (int64)2)) + int32(((int64(((c3*128) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(c1)*(int64)921348) + (int64)921348)))])
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 128
0- for 0 <= i00 < 768 | 0
	1- for 0 <= i01_outer < 7 | 0
		2- for 0 <= i02_outer < 8 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 128 | 0
					comp02
Evaluation : 840.767029

{ comp02[t5, t6, t7] -> comp02[0, t14272 = 0, i00 = t5, t14274 = 0, i01_outer, t14276 = 0, i02_outer, t14278 = 0, i01_inner, t14269 = 0, i02_inner, t14280 = 0] : (t6 - i01_inner) mod 128 = 0 and (-t7 + i02_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t6 <= 128i01_outer <= t6 and -127 + t7 <= 128i02_outer <= t7 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 127 }




input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

original list
473.074005+605.020996+589.242981+568.969971+468.190002+611.138000+590.770996+585.062988+479.722992+632.114990+645.315002+562.594971+468.382996+623.206970+596.596985+571.552002+460.592010+659.166992+645.750000+554.968018+485.381012+685.651978+641.507019+559.080017+466.046997+653.585999+838.198975+575.442017+455.428009+690.573975+617.918030+554.318970+475.858002+728.481995+631.468994+551.997986+1099.359985+1161.959961+1069.170044+1056.290039+978.174988+918.663025+1074.119995+901.195007+840.767029+83272.296875+
remaining list
455.428009+460.592010+466.046997+468.190002+
Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 256 | 0 | P
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 489.886993

{ comp02[t5, t6, t7] -> comp02[0, t13254 = 0, i00_outer, t13256 = 0, i01_outer, t13258 = 0, i00_inner, t13251 = 0, i01_inner, t13260 = 0, i02 = t7, t13262 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 128 | 0 | P
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 533.945007

{ comp02[t5, t6, t7] -> comp02[0, t13254 = 0, i00_outer, t13256 = 0, i01_outer, t13258 = 0, i00_inner, t13251 = 0, i01_inner, t13260 = 0, i02 = t7, t13262 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 14) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 64 | 0 | P
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 458.145996

{ comp02[t5, t6, t7] -> comp02[0, t13254 = 0, i00_outer, t13256 = 0, i01_outer, t13258 = 0, i00_inner, t13251 = 0, i01_inner, t13260 = 0, i02 = t7, t13262 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64
Unrolling L4 4
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 256 | 0 | P
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 483.821991

{ comp02[t5, t6, t7] -> comp02[0, t12351 = 0, i00_outer, t12353 = 0, i01_outer, t12355 = 0, i00_inner, t12348 = 0, i01_inner, t12357 = 0, i02 = t7, t12359 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64
Unrolling L4 8
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 128 | 0 | P
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 582.060974

{ comp02[t5, t6, t7] -> comp02[0, t12351 = 0, i00_outer, t12353 = 0, i01_outer, t12355 = 0, i00_inner, t12348 = 0, i01_inner, t12357 = 0, i02 = t7, t12359 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 12) {
    for (c3, 0, 14) {
      parallel (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*64) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*64) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*64) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64
Unrolling L4 16
0- for 0 <= i00_outer < 12 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 64 | 0 | P
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 462.408997

{ comp02[t5, t6, t7] -> comp02[0, t12351 = 0, i00_outer, t12353 = 0, i01_outer, t12355 = 0, i00_inner, t12348 = 0, i01_inner, t12357 = 0, i02 = t7, t12359 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 64 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -63 + t5 <= 64i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32
Unrolling L4 4
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 256 | 0 | P
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 489.194000

{ comp02[t5, t6, t7] -> comp02[0, t12953 = 0, i00_outer, t12955 = 0, i01_outer, t12957 = 0, i00_inner, t12950 = 0, i01_inner, t12959 = 0, i02 = t7, t12961 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32
Unrolling L4 8
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 128 | 0 | P
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 559.934021

{ comp02[t5, t6, t7] -> comp02[0, t12953 = 0, i00_outer, t12955 = 0, i01_outer, t12957 = 0, i00_inner, t12950 = 0, i01_inner, t12959 = 0, i02 = t7, t12961 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 6) {
    for (c3, 0, 28) {
      parallel (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(((c1*128) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*128) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*32) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*128) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32
Unrolling L4 16
0- for 0 <= i00_outer < 6 | 0
	1- for 0 <= i01_outer < 28 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_outer < 64 | 0 | P
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 473.036011

{ comp02[t5, t6, t7] -> comp02[0, t12953 = 0, i00_outer, t12955 = 0, i01_outer, t12957 = 0, i00_inner, t12950 = 0, i01_inner, t12959 = 0, i02 = t7, t12961 = 0] : (t6 - i01_inner) mod 32 = 0 and (t5 - i00_inner) mod 128 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -127 + t5 <= 128i00_outer <= t5 and -31 + t6 <= 32i01_outer <= t6 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*4) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*4) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64
Unrolling L4 4
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 256 | 0 | P
					5- for 0 <= i02_inner < 4 | 1
						comp02
Evaluation : 523.770996

{ comp02[t5, t6, t7] -> comp02[0, t11448 = 0, i00_outer, t11450 = 0, i01_outer, t11452 = 0, i00_inner, t11445 = 0, i01_inner, t11454 = 0, i02 = t7, t11456 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*8) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*8) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64
Unrolling L4 8
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 128 | 0 | P
					5- for 0 <= i02_inner < 8 | 1
						comp02
Evaluation : 587.262024

{ comp02[t5, t6, t7] -> comp02[0, t11448 = 0, i00_outer, t11450 = 0, i01_outer, t11452 = 0, i00_inner, t11445 = 0, i01_inner, t11454 = 0, i02 = t7, t11456 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 24) {
    for (c3, 0, 14) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(((c1*32) + c5))*(int64)917504)))] = ((((((buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32((int64(((c1*32) + c5))*(int64)921348)))] + (buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)2052))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) + buf00[((((c9*16) + c11) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(((c9*16) + c11)) + (int64)2)) + int32(((int64(((c3*64) + c7))*(int64)1026) + (int64)1026))) + int32(((int64(((c1*32) + c5))*(int64)921348) + (int64)921348)))])
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64
Unrolling L4 16
0- for 0 <= i00_outer < 24 | 0
	1- for 0 <= i01_outer < 14 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_outer < 64 | 0 | P
					5- for 0 <= i02_inner < 16 | 1
						comp02
Evaluation : 492.263000

{ comp02[t5, t6, t7] -> comp02[0, t11448 = 0, i00_outer, t11450 = 0, i01_outer, t11452 = 0, i00_inner, t11445 = 0, i01_inner, t11454 = 0, i02 = t7, t11456 = 0] : (t6 - i01_inner) mod 64 = 0 and (t5 - i00_inner) mod 32 = 0 and 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 and -31 + t5 <= 32i00_outer <= t5 and -63 + t6 <= 64i01_outer <= t6 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  parallel (c1, 0, 896) {
    for (c3, 0, 768) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
0- for 0 <= i01 < 896 | 0 | P
	1- for 0 <= i00 < 768 | 0
		2- for 0 <= i02 < 1024 | 0
			comp02
Evaluation : 612.424011

{ comp02[t5, t6, t7] -> comp02[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 896) {
    parallel (c3, 0, 768) {
      for (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
0- for 0 <= i01 < 896 | 0
	1- for 0 <= i00 < 768 | 0 | P
		2- for 0 <= i02 < 1024 | 0
			comp02
Evaluation : 796.711975

{ comp02[t5, t6, t7] -> comp02[0, t8 = 0, i01 = t6, t9 = 0, i00 = t5, t10 = 0, i02 = t7, t11 = 0] : 0 <= t5 <= 767 and 0 <= t6 <= 895 and 0 <= t7 <= 1023 }


input00:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 2 ,0 1 0 1 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 0 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 2 ,0 0 1 1 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 0 ,
input00:1 0 0 1 ,0 1 0 1 ,0 0 1 2 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
produce  {
  allocate _input00_b0[int32 * 1024 * 896 * 768]
  allocate _comp02_b1[int32 * 1024 * 896 * 768]
  for (c1, 0, 896) {
    for (c3, 0, 768) {
      parallel (c5, 0, 1024) {
        buf02[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)917504)))] = ((((((buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32((int64(c3)*(int64)921348)))] + (buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]*6)) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)1842696)))]) + buf00[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1026) + (int64)2052))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) + buf00[((c5 + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))]) - buf00[((int32((int64(c5) + (int64)2)) + int32(((int64(c1)*(int64)1026) + (int64)1026))) + int32(((int64(c3)*(int64)921348) + (int64)921348)))])
      }
    }
  }
}
