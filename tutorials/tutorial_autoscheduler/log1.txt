
Generated Halide IR:
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
let buf_output = _halide_buffer_get_host(buf_output.buffer)
produce  {
  allocate _src_b0[int32 * 1024 * 1024]
  allocate _conv_b1[int32 * 1022 * 1022 * 200]
  for (c1, 0, 200) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        buf_output[(c5 + int32((int64(c3)*(int64)1024)))] = (((((((buf_output[(int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024)))] + buf_output[(c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024)))]) + buf_output[(int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024)))]) + buf_output[(c5 + int32(((int64(c3)*(int64)1024) + (int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024)))])
      }
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
let buf_output = _halide_buffer_get_host(buf_output.buffer)
produce  {
  allocate _src_b0[int32 * 1024 * 1024]
  allocate _conv_b1[int32 * 1022 * 1022 * 200]
  for (c1, 0, 200) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        buf_output[(c5 + int32((int64(c3)*(int64)1024)))] = (((((((buf_output[(int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024)))] + buf_output[(c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024)))]) + buf_output[(int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024)))]) + buf_output[(c5 + int32(((int64(c3)*(int64)1024) + (int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024)))])
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
let buf_output = _halide_buffer_get_host(buf_output.buffer)
produce  {
  allocate _src_b0[int32 * 1024 * 1024]
  allocate _conv_b1[int32 * 1022 * 1022 * 200]
  for (c1, 0, 200) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        buf_output[(c5 + int32((int64(c3)*(int64)1024)))] = (((((((buf_output[(int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024)))] + buf_output[(c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024)))]) + buf_output[(int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024)))]) + buf_output[(c5 + int32(((int64(c3)*(int64)1024) + (int64)1024)))]) + buf_output[(int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024)))])
      }
    }
  }
}
