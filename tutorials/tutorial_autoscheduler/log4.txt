Saved variable root of type int32
Saved variable n of type int32
Saved variable fout of type int32
Saved variable y of type int32
Saved variable x of type int32
Saved variable fin of type int32
Saved variable k_y of type int32
Saved variable k_x of type int32
Saved variable y_pad of type int32
Saved variable x_pad of type int32
Saved variable t0 of type int32
[computation function]
|   Constructing an unscheduled computation.
|   Creating computation bias
|   Constructed iteration domain: {bias[fout] : 0<=fout<2}
|   [init_computation function]
|   |   Constructing the computation: {bias[fout] : 0<=fout<2}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { bias[fout] -> bias[0, 0, fout' = fout, 0] : 0 <= fout <= 1 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t1
|   |   |   The schedule after renaming:  { bias[t1] -> bias[0, 0, fout = t1, 0] : 0 <= t1 <= 1 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into fout
|   |   |   The schedule after renaming:  { bias[t1] -> bias[0, 0, fout = t1, 0] : 0 <= t1 <= 1 }
|   |   Searching computation bias
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { bias[fout] -> _bias_b0[fout' = fout] }
|   |   [set_access function]
|   |   |   Setting access { bias[fout] -> _bias_b0[fout' = fout] } for computation bias
|   |   |   Searching computation bias
|   |   |   Computation found.
|   |   |   Searching computation bias
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "bias" :
Iteration domain of the computation "bias" : Dumping the schedule of the computation bias : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 0
Halide statement: NULL


Saved variable t2 of type int32
[computation function]
|   Constructing an unscheduled computation.
|   Creating computation src
|   Constructed iteration domain: {src[n, fin, y_pad, x_pad] : 0<=n<8 and 0<=fin<3 and 0<=y_pad<1024 and 0<=x_pad<1024}
|   [init_computation function]
|   |   Constructing the computation: {src[n, fin, y_pad, x_pad] : 0<=n<8 and 0<=fin<3 and 0<=y_pad<1024 and 0<=x_pad<1024}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { src[n, fin, y_pad, x_pad] -> src[0, 0, n' = n, 0, fin' = fin, 0, y_pad' = y_pad, 0, x_pad' = x_pad, 0] : 0 <= n <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t3
|   |   |   The schedule after renaming:  { src[t3, fin, y_pad, x_pad] -> src[0, 0, n = t3, 0, fin' = fin, 0, y_pad' = y_pad, 0, x_pad' = x_pad, 0] : 0 <= t3 <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t4
|   |   |   The schedule after renaming:  { src[t3, t4, y_pad, x_pad] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad' = y_pad, 0, x_pad' = x_pad, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t5
|   |   |   The schedule after renaming:  { src[t3, t4, t5, x_pad] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad' = x_pad, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= x_pad <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t6
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fin
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y_pad
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x_pad
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   Searching computation src
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { src[n, fin, y_pad, x_pad] -> _src_b1[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] }
|   |   [set_access function]
|   |   |   Setting access { src[n, fin, y_pad, x_pad] -> _src_b1[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] } for computation src
|   |   |   Searching computation src
|   |   |   Computation found.
|   |   |   Searching computation src
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "src" :
Iteration domain of the computation "src" : Dumping the schedule of the computation src : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 0
Halide statement: NULL


Saved variable t7 of type int32
[computation function]
|   Constructing an unscheduled computation.
|   Creating computation weights
|   Constructed iteration domain: {weights[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   [init_computation function]
|   |   Constructing the computation: {weights[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { weights[n, fout, y, x] -> weights[0, 0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t8
|   |   |   The schedule after renaming:  { weights[t8, fout, y, x] -> weights[0, 0, n = t8, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= t8 <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t9
|   |   |   The schedule after renaming:  { weights[t8, t9, y, x] -> weights[0, 0, n = t8, 0, fout = t9, 0, y' = y, 0, x' = x, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t10
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, x] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x' = x, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t11
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fout
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   Searching computation weights
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { weights[n, fout, y, x] -> _weights_b2[n' = n, fout' = fout, y' = y, x' = x] }
|   |   [set_access function]
|   |   |   Setting access { weights[n, fout, y, x] -> _weights_b2[n' = n, fout' = fout, y' = y, x' = x] } for computation weights
|   |   |   Searching computation weights
|   |   |   Computation found.
|   |   |   Searching computation weights
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "weights" :
Iteration domain of the computation "weights" : Dumping the schedule of the computation weights : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 0
Halide statement: NULL


Saved variable t12 of type int32
[computation function]
|   Constructing a scheduled computation.
|   Creating computation conv_init
|   Constructed iteration domain: {conv_init[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   [init_computation function]
|   |   Constructing the computation: {conv_init[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { conv_init[n, fout, y, x] -> conv_init[0, 0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: bias(fout)|   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: bias(fout)
|   |   |   |   Looking for non-affine accesses in an o_access.
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fout
|   |   |   |   |   [access_is_affine function]
|   |   |   The new expression is: bias(fout)|   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t13
|   |   |   The schedule after renaming:  { conv_init[t13, fout, y, x] -> conv_init[0, 0, n = t13, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= t13 <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t14
|   |   |   The schedule after renaming:  { conv_init[t13, t14, y, x] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y' = y, 0, x' = x, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t15
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, x] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x' = x, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t16
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fout
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   Searching computation conv_init
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { conv_init[n, fout, y, x] -> _conv_init_b3[n' = n, fout' = fout, y' = y, x' = x] }
|   |   [set_access function]
|   |   |   Setting access { conv_init[n, fout, y, x] -> _conv_init_b3[n' = n, fout' = fout, y' = y, x' = x] } for computation conv_init
|   |   |   Searching computation conv_init
|   |   |   Computation found.
|   |   |   Searching computation conv_init
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "conv_init" :
Iteration domain of the computation "conv_init" : Dumping the schedule of the computation conv_init : Expression of the computation : bias(fout)
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 1
Halide statement: NULL


Saved variable t17 of type int32
[computation function]
|   Constructing a scheduled computation.
|   Creating computation conv
|   Constructed iteration domain: {conv[n, fout, y, x, fin, k_y, k_x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024 and 0<=fin<3 and 0<=k_y<3 and 0<=k_x<3}
|   [init_computation function]
|   |   Constructing the computation: {conv[n, fout, y, x, fin, k_y, k_x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024 and 0<=fin<3 and 0<=k_y<3 and 0<=k_x<3}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { conv[n, fout, y, x, fin, k_y, k_x] -> conv[0, 0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t18
|   |   |   The schedule after renaming:  { conv[t18, fout, y, x, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t19
|   |   |   The schedule after renaming:  { conv[t18, t19, y, x, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y' = y, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t20
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, x, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t21
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 4
|   |   |   Setting the name of the domain of the schedule dimension 4 into t22
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 5
|   |   |   Setting the name of the domain of the schedule dimension 5 into t23
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 6
|   |   |   Setting the name of the domain of the schedule dimension 6 into t24
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fout
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 4
|   |   |   Setting the name of loop level 4 into fin
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 5
|   |   |   Setting the name of loop level 5 into k_y
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 6
|   |   |   Setting the name of loop level 6 into k_x
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Searching computation conv
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { conv[n, fout, y, x, fin, k_y, k_x] -> _conv_b4[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   [set_access function]
|   |   |   Setting access { conv[n, fout, y, x, fin, k_y, k_x] -> _conv_b4[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] } for computation conv
|   |   |   Searching computation conv
|   |   |   Computation found.
|   |   |   Searching computation conv
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "conv" :
Iteration domain of the computation "conv" : Dumping the schedule of the computation conv : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 1
Halide statement: NULL


[set_expression function]
|   The original expression is: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))|   
|   Traversing the expression to replace non-affine accesses by a constant definition.
|   [traverse_expr_and_replace_non_affine_accesses function]
|   |   Input expression: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))
|   |   Extracting access from e_op.
|   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   Input expression: conv(n, fout, y, x, fin, k_y, k_x)
|   |   |   Looking for non-affine accesses in an o_access.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: n
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: fout
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: y
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: x
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: fin
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: k_y
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: k_x
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   Input expression: (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x))
|   |   |   Extracting access from e_op.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: src(n, fin, (y + k_y), (x + k_x))
|   |   |   |   Looking for non-affine accesses in an o_access.
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: n
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fin
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: (y + k_y)
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: y
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: k_y
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: (x + k_x)
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: x
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: k_x
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: weights(fout, fin, k_y, k_x)
|   |   |   |   Looking for non-affine accesses in an o_access.
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fout
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fin
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: k_y
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: k_x
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   The new expression is: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))|   
[then function]
|   [after function]
|   |   [get_loop_level_numbers_from_dimension_names function]
|   |   |   Searching for the dimension x
|   |   |   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Corresponding loop level is 3
|   |   |   Checking the validity of loop level 3
|   |   The loop level that corresponds to x is 3
|   |   [after function]
|   |   |   Scheduling conv to be executed after conv_init at level 3
|   |   |   sched_graph[conv_init, conv] = 3
[store_in function]
|   Binding. The following access function is set:  { bias[fout] -> buf_bias[fout' = fout] }
|   [set_access function]
|   |   Setting access { bias[fout] -> buf_bias[fout' = fout] } for computation bias
|   |   Searching computation bias
|   |   Computation found.
|   |   Searching computation bias
|   |   Computation found.
[store_in function]
|   Binding. The following access function is set:  { src[n, fin, y_pad, x_pad] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] }
|   [set_access function]
|   |   Setting access { src[n, fin, y_pad, x_pad] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] } for computation src
|   |   Searching computation src
|   |   Computation found.
|   |   Searching computation src
|   |   Computation found.
[store_in function]
|   Binding. The following access function is set:  { weights[n, fout, y, x] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] }
|   [set_access function]
|   |   Setting access { weights[n, fout, y, x] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] } for computation weights
|   |   Searching computation weights
|   |   Computation found.
|   |   Searching computation weights
|   |   Computation found.
[store_in function]
|   Binding. The following access function is set:  { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] }
|   [set_access function]
|   |   Setting access { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] } for computation conv_init
|   |   Searching computation conv_init
|   |   Computation found.
|   |   Searching computation conv_init
|   |   Computation found.
[store_in function]
|   [get_iteration_domain_dimension_names function]
|   Parsing following access statement:  [] -> {conv[n,fout,y,x,fin,k_y,k_x] -> buf_output[n, fout, y, x]}
|   Binding. The following access function is set:  { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   [set_access function]
|   |   Setting access { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] } for computation conv
|   |   Searching computation conv
|   |   Computation found.
|   |   Searching computation conv
|   |   Computation found.
[align_schedules function]
|   [get_max_schedules_range_dim function]
|   [isl_map_align_range_dims function]
|   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0] : 0 <= t1 <= 1 }
|   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] : 0 <= t1 <= 1 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, 0, 0, 0, 0, 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, 0, 0, 0, 0, 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, 0, 0, 0, 0, 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   [name_unnamed_time_space_dimensions function]
End of function
[gen_ordering_schedules function]
|   Number of schedule graph roots is 1
|   The roots are:
|    * conv_init@0x7ffd6c4369a0
|   Displaying schedule graph
|   conv_init@0x7ffd6c4369a0=[3]=>conv@0x7ffd6c436e10
|   Finished displaying schedule graph
|   [is_sched_graph_tree function]
|   this->is_sched_graph_tree(): true.
|   [after_low_level function]
|   |   Setting the schedule of conv after conv_init at dimension 9
|   |   Setting the schedule of conv to be equal to the schedule of conv_init at all the dimensions before dimension 9
|   |   [align_schedules function]
|   |   |   [get_max_schedules_range_dim function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   End of function
|   |   Preparing to adjust the schedule of the computation conv
|   |   Original schedule:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Dimension level in which ordering dimensions will be inserted : 9
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 1
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 1
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 1
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n', o3, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 3
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 3
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 3
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 5
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 5
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 5
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 7
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 7
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 7
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 9
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 9
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 10
|   |   |   Setting the constraint for dimension 9
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Schedule adjusted:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
[performe_full_dependency_analysis function]
|   [align_schedules function]
|   |   [get_max_schedules_range_dim function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [name_unnamed_time_space_dimensions function]
|   End of function
|   [gen_ordering_schedules function]
|   |   Number of schedule graph roots is 1
|   |   The roots are:
|   |    * conv_init@0x7ffd6c4369a0
|   |   Displaying schedule graph
|   |   conv_init@0x7ffd6c4369a0=[3]=>conv@0x7ffd6c436e10
|   |   Finished displaying schedule graph
|   |   [is_sched_graph_tree function]
|   |   this->is_sched_graph_tree(): true.
|   |   [after_low_level function]
|   |   |   Setting the schedule of conv after conv_init at dimension 9
|   |   |   Setting the schedule of conv to be equal to the schedule of conv_init at all the dimensions before dimension 9
|   |   |   [align_schedules function]
|   |   |   |   [get_max_schedules_range_dim function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   End of function
|   |   |   Preparing to adjust the schedule of the computation conv
|   |   |   Original schedule:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Dimension level in which ordering dimensions will be inserted : 9
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 1
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 1
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 1
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n', o3, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 3
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 3
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 3
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 5
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 5
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 5
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 7
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 7
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 7
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 9
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 9
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 10
|   |   |   |   Setting the constraint for dimension 9
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Schedule adjusted:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   [calculate_dep_flow function]
|   |    generating depandencies graph
|   |   [compute_dep_graph function]
|   |   |   Computing the dependences involving the computation bias.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Computing the dependences involving the computation src.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Computing the dependences involving the computation weights.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Computing the dependences involving the computation conv_init.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   Searching computation bias
|   |   |   |   |   Computation found.
|   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   Domain: { conv_init[n, fout, y, x] }
|   |   |   |   |   |   Range: { bias[fout] }
|   |   |   |   |   |   Transformation map: { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   |   Transformation map after adding equality constraints: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   |   Transformation map before adding constraints: { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   Looking for a dimension named fout in the domain of  { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   After adding a constraint: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   |   Transformation function after adding constraints: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Accesses after filtering.
|   |   |   { bias[fout] -> conv_init[n, fout' = fout, y, x] }
|   |   |   Computing the dependences involving the computation conv.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   Searching computation conv
|   |   |   |   |   |   Computation found.
|   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   Range: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   Looking for a dimension named n in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 0
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   Looking for a dimension named fout in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   Looking for a dimension named y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 2
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   Looking for a dimension named x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 3
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 4
|   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 5
|   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 6
|   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   |   Searching computation src
|   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   |   Range: { src[n, fin, y_pad, x_pad] }
|   |   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   |   Looking for a dimension named n in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 0
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   |   Looking for a dimension named y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 2
|   |   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   |   Looking for a dimension named x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 3
|   |   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   |   Searching computation weights
|   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   |   Range: { weights[n, fout, y, x] }
|   |   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   |   Looking for a dimension named fout in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout', y', x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout', y', x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y', x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y', x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Accesses after filtering.
|   |   |   { src[n, fin, y_pad, x_pad] -> conv[n' = n, fout, y, x, fin' = fin, k_y = y_pad - y, k_x = x_pad - x]; weights[n, fout, y, x] -> conv[n', fout' = n, y', x', fin = fout, k_y = y, k_x = x]; conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   Dep graph: 
|   |   |   { src[n, fin, y_pad, x_pad] -> conv[n' = n, fout, y, x, fin' = fin, k_y = y_pad - y, k_x = x_pad - x]; weights[n, fout, y, x] -> conv[n', fout' = n, y', x', fin = fout, k_y = y, k_x = x]; conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x]; bias[fout] -> conv_init[n, fout' = fout, y, x] }
|   |   End of function
|   |    the referencing union map is for dependecy analysis: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x]; conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x]; conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x]; conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |    using to generate time stamp tmp map [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15]->[t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15]
|   |    - > computation's schedule  : { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |    - > computation's schedule to time stamp op result is : { bias[t1] -> [0, 0, t1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] : 0 <= t1 <= 1 }
|   |    - > computation's schedule  : { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |    - > computation's schedule to time stamp op result is : { src[t3, t4, t5, t6] -> [0, 0, t3, 0, t4, 0, t5, 0, t6, 0, 0, 0, 0, 0, 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |    - > computation's schedule  : { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |    - > computation's schedule to time stamp op result is : { weights[t8, t9, t10, t11] -> [0, 0, t8, 0, t9, 0, t10, 0, t11, 0, 0, 0, 0, 0, 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |    - > computation's schedule  : { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |    - > computation's schedule to time stamp op result is : { conv_init[t13, t14, t15, t16] -> [0, 0, t13, 0, t14, 0, t15, 0, t16, 0, 0, 0, 0, 0, 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |    - > computation's schedule  : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |    - > computation's schedule to time stamp op result is : { conv[t18, t19, t20, t21, t22, t23, t24] -> [0, 0, t18, 0, t19, 0, t20, 0, t21, 10, t22, 0, t23, 0, t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   the overall function schedule is : { conv_init[t13, t14, t15, t16] -> [0, 0, t13, 0, t14, 0, t15, 0, t16, 0, 0, 0, 0, 0, 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> [0, 0, t18, 0, t19, 0, t20, 0, t21, 10, t22, 0, t23, 0, t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   the write access for computations is : { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023; conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |    The read access for computations : { conv[n, fout, y, x, fin, k_y, k_x] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv[n, fout, y, x, fin, k_y, k_x] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv_init[n, fout, y, x] -> buf_bias[fout' = fout] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |    read after write True dependencies are in the form { last_write_access -> the read statement } : { conv_init[t13, t14, t15, t16] -> [conv[t18 = t13, t19 = t14, t20 = t15, t21 = t16, t22 = 0, t23 = 0, t24 = 0] -> buf_output[t13, t14, t15, t16]] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = t23, t24' = 1 + t24] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 1; conv[t18, t19, t20, t21, t22, t23, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = 1 + t23, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 1; conv[t18, t19, t20, t21, t22, t23 = 2, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = 1 + t22, t23' = 0, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 1 }
|   |    live-in : the computations / statement with these read access have not been written in this function (outside value)  : { conv[t18, t19, t20, t21, t22, t23, t24] -> buf_weights[n = t19, fout = t22, y = t23, x = t24] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2; conv_init[t13, t14, t15, t16] -> buf_bias[fout = t14] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> buf_src[n = t18, fin = t22, y_pad = t20 + t23, x_pad = t21 + t24] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |    write after write dependencies are { last_previous_write -> new write stmt } : { conv_init[t13, t14, t15, t16] -> [conv[t18 = t13, t19 = t14, t20 = t15, t21 = t16, t22 = 0, t23 = 0, t24 = 0] -> buf_output[t13, t14, t15, t16]] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = t23, t24' = 1 + t24] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 1; conv[t18, t19, t20, t21, t22, t23, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = 1 + t23, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 1; conv[t18, t19, t20, t21, t22, t23 = 2, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = 1 + t22, t23' = 0, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 1 }
|   |    live out last access are : { conv[n, fout, y, x, fin = 2, k_y = 2, k_x = 2] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |    write after read anti_dependencies are in the form { last_previous_read -> new write stmt } : {  }
[gen_time_space_domain function]
|   [gen_ordering_schedules function]
|   |   Number of schedule graph roots is 1
|   |   The roots are:
|   |    * conv_init@0x7ffd6c4369a0
|   |   Displaying schedule graph
|   |   conv_init@0x7ffd6c4369a0=[3]=>conv@0x7ffd6c436e10
|   |   Finished displaying schedule graph
|   |   [is_sched_graph_tree function]
|   |   this->is_sched_graph_tree(): true.
|   |   [after_low_level function]
|   |   |   Setting the schedule of conv after conv_init at dimension 9
|   |   |   Setting the schedule of conv to be equal to the schedule of conv_init at all the dimensions before dimension 9
|   |   |   [align_schedules function]
|   |   |   |   [get_max_schedules_range_dim function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   End of function
|   |   |   Preparing to adjust the schedule of the computation conv
|   |   |   Original schedule:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Dimension level in which ordering dimensions will be inserted : 9
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 1
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 1
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 1
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n', o3, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 3
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 3
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 3
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 5
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 5
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 5
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 7
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 7
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 7
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 9
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 9
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 10
|   |   |   |   Setting the constraint for dimension 9
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Schedule adjusted:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   [align_schedules function]
|   |   [get_max_schedules_range_dim function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [name_unnamed_time_space_dimensions function]
|   End of function
|   [gen_time_space_domain function]
|   |   Iteration domain: { bias[fout] : 0 <= fout <= 1 }
|   |   [intersect_set_with_context function]
|   |   Iteration domain Intersect context: { bias[fout] : 0 <= fout <= 1 }
|   |   Schedule: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   Generated time-space domain: { bias[0, 0, fout, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= fout <= 1 }
|   [gen_time_space_domain function]
|   |   Iteration domain: { src[n, fin, y_pad, x_pad] : 0 <= n <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   [intersect_set_with_context function]
|   |   Iteration domain Intersect context: { src[n, fin, y_pad, x_pad] : 0 <= n <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   Schedule: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   Generated time-space domain: { src[0, 0, n, 0, fin, 0, y_pad, 0, x_pad, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= n <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   [gen_time_space_domain function]
|   |   Iteration domain: { weights[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [intersect_set_with_context function]
|   |   Iteration domain Intersect context: { weights[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   Schedule: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   Generated time-space domain: { weights[0, 0, n, 0, fout, 0, y, 0, x, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   [gen_time_space_domain function]
|   |   Iteration domain: { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [intersect_set_with_context function]
|   |   Iteration domain Intersect context: { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   Schedule: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   Generated time-space domain: { conv_init[0, 0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   [gen_time_space_domain function]
|   |   Iteration domain: { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [intersect_set_with_context function]
|   |   Iteration domain Intersect context: { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   Schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Generated time-space domain: { conv[0, 0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
[gen_isl_ast function]
|   [get_trimmed_time_processor_domain function]
|   [get_aligned_identity_schedules function]
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   [get_max_identity_schedules_range_dim function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   Identity schedule for time space domain:  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   After alignment, map =  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   Identity schedule for time space domain:  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   After alignment, map =  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   End of function
|   [rename_computations function]
|   |   Searching computation bias
|   |   Computation found.
|   |   Searching computation src
|   |   Computation found.
|   |   Searching computation weights
|   |   Computation found.
|   |   Searching computation conv_init
|   |   Computation found.
|   |   Searching computation conv
|   |   Computation found.
|   |   After renaming the computations.
|   |   

Function "conv"

Function arguments (tiramisu buffers):
Buffer "buf_output", Number of dimensions: 4
Dimension sizes: 8    2    1024    1024    
Elements type: int32
Function field: Not NULL
Argument type: output


Buffer "buf_bias", Number of dimensions: 1
Dimension sizes: 2    
Elements type: int32
Function field: Not NULL
Argument type: input


Buffer "buf_src", Number of dimensions: 4
Dimension sizes: 8    3    1024    1024    
Elements type: int32
Function field: Not NULL
Argument type: input


Buffer "buf_weights", Number of dimensions: 4
Dimension sizes: 2    3    3    3    
Elements type: int32
Function field: Not NULL
Argument type: input



Body 

Dumping the computation "bias" :
Iteration domain of the computation "bias" : Dumping the schedule of the computation bias : Expression of the computation : 
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 0
Halide statement: NULL


Dumping the computation "src" :
Iteration domain of the computation "src" : Dumping the schedule of the computation src : Expression of the computation : 
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 0
Halide statement: NULL


Dumping the computation "weights" :
Iteration domain of the computation "weights" : Dumping the schedule of the computation weights : Expression of the computation : 
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 0
Halide statement: NULL


Dumping the computation "conv_init" :
Iteration domain of the computation "conv_init" : Dumping the schedule of the computation conv_init : Expression of the computation : bias(fout)
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 1
Halide statement: NULL


Dumping the computation "conv" :
Iteration domain of the computation "conv" : Dumping the schedule of the computation conv : Expression of the computation : (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 1
Halide statement: NULL


Buffers
Buffer name: _bias_b0
Buffer "_bias_b0", Number of dimensions: 1
Dimension sizes: (2 - 0)    
Elements type: int32
Function field: Not NULL
Argument type: temporary


Buffer name: _conv_b4
Buffer "_conv_b4", Number of dimensions: 7
Dimension sizes: (8 - 0)    (2 - 0)    (1024 - 0)    (1024 - 0)    (3 - 0)    (3 - 0)    (3 - 0)    
Elements type: int32
Function field: Not NULL
Argument type: temporary


Buffer name: _conv_init_b3
Buffer "_conv_init_b3", Number of dimensions: 4
Dimension sizes: (8 - 0)    (2 - 0)    (1024 - 0)    (1024 - 0)    
Elements type: int32
Function field: Not NULL
Argument type: temporary


Buffer name: _src_b1
Buffer "_src_b1", Number of dimensions: 4
Dimension sizes: (8 - 0)    (3 - 0)    (1024 - 0)    (1024 - 0)    
Elements type: int32
Function field: Not NULL
Argument type: temporary


Buffer name: _weights_b2
Buffer "_weights_b2", Number of dimensions: 4
Dimension sizes: (8 - 0)    (2 - 0)    (1024 - 0)    (1024 - 0)    
Elements type: int32
Function field: Not NULL
Argument type: temporary


Buffer name: buf_bias
Buffer "buf_bias", Number of dimensions: 1
Dimension sizes: 2    
Elements type: int32
Function field: Not NULL
Argument type: input


Buffer name: buf_output
Buffer "buf_output", Number of dimensions: 4
Dimension sizes: 8    2    1024    1024    
Elements type: int32
Function field: Not NULL
Argument type: output


Buffer name: buf_src
Buffer "buf_src", Number of dimensions: 4
Dimension sizes: 8    3    1024    1024    
Elements type: int32
Function field: Not NULL
Argument type: input


Buffer name: buf_weights
Buffer "buf_weights", Number of dimensions: 4
Dimension sizes: 2    3    3    3    
Elements type: int32
Function field: Not NULL
Argument type: input





|   [get_trimmed_time_processor_domain function]
|   [get_aligned_identity_schedules function]
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   [get_max_identity_schedules_range_dim function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   Identity schedule for time space domain:  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   After alignment, map =  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   Identity schedule for time space domain:  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   After alignment, map =  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   End of function
|   Schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2; conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   Iteration domain: { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023; conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [get_trimmed_time_processor_domain function]
Trimmed Time-Processor domain: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [get_aligned_identity_schedules function]
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   [get_max_identity_schedules_range_dim function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   |   [gen_identity_schedule_for_time_space_domain function]
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   Identity schedule for time space domain:  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   After alignment, map =  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [gen_identity_schedule_for_time_space_domain function]
|   |   Identity schedule for time space domain:  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   After alignment, map =  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   End of function
Trimmed Time-Processor aligned identity schedule: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Identity schedule intersect trimmed Time-Processor domain: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37' = 0, 0, t38' = 0, 0, t39' = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   

|   [stmt_code_generator function]
|   |   Searching computation conv_init
|   |   Computation found.
|   |   [filter_computations_by_domain function]
|   |   |   Filtering computations by ISL AST domain.
|   |   |   ISL AST node domain: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Checking computation conv_init
|   |   |   Domain of the computation  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Domain of the computation in time-space domain  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Intersecting the set: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   With the set: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Intersection { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   This computation is accepted by the filter (intersection non-empty).
|   |   Computation: conv_init
|   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   Getting the access of the computation conv_init adapted to time-space.
|   |   |   Original access: { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   Original schedule: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   Trimmed schedule to apply: { conv_init[t13, t14, t15, t16] -> conv_init[0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   Transformed access: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [get_rhs_accesses function]
|   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   Extracting access from o_access.
|   |   |   |   Searching computation bias
|   |   |   |   Computation found.
|   |   |   |   Obtained accessed computation.
|   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   Domain: { conv_init[n, fout, y, x] }
|   |   |   |   |   Range: { bias[fout] }
|   |   |   |   |   Transformation map: { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   Transformation map after adding equality constraints: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   Transformation map before adding constraints: { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   Looking for a dimension named fout in the domain of  { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   After adding a constraint: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   Transformation function after adding constraints: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   The access of this computation to buffers (before re-adapting its domain into the domain of the current access) :  { bias[fout] -> buf_bias[fout' = fout] }
|   |   |   |   Applying access function on the range of transformation function: { conv_init[n, fout, y, x] -> buf_bias[fout' = fout] }
|   |   |   |   Apply the schedule on the domain of the access function. Access functions: { conv_init[n, fout, y, x] -> buf_bias[fout' = fout] }
|   |   |   |   Trimmed schedule: { conv_init[t13, t14, t15, t16] -> conv_init[0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   Result:  { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_bias[fout' = fout] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   [traverse_expr_and_extract_accesses function]
|   |   [get_rhs_accesses function]
|   |   [compute_iterators_map function]
|   |   |   Creating an isl_ast_index_expression for the access : { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> conv_init[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   [create_isl_ast_index_expression function]
|   |   |   |   Schedule: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   |   Schedule reversed: { [n, fout, y, x] -> conv_init[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   |   |   Access: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> conv_init[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): conv_init[c1][c3][c5][c7]
|   |   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: conv_init }, { id: c1 }, { id: c3 }, { id: c5 }, { id: c7 } ] }
|   |   |   The iterators map is :
|   |   |   Original index name = n, Transformed index:  { id: c1 }
|   |   |   Original index name = fout, Transformed index:  { id: c3 }
|   |   |   Original index name = y, Transformed index:  { id: c5 }
|   |   |   Original index name = x, Transformed index:  { id: c7 }
|   |   Generated RHS access maps:
|   |   |   Access 0: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Access 1: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_bias[fout' = fout] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   Creating an isl_ast_index_expression for the access (isl_map *): { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [create_isl_ast_index_expression function]
|   |   |   Schedule: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Schedule reversed: { [n, fout, y, x] -> conv_init[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   Access: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): buf_output[c1][c3][c5][c7]
|   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: buf_output }, { id: c1 }, { id: c3 }, { id: c5 }, { id: c7 } ] }
|   |   Creating an isl_ast_index_expression for the access (isl_map *): { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_bias[fout' = fout] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [create_isl_ast_index_expression function]
|   |   |   Schedule: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> [n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   Schedule reversed: { [n, fout, y, x] -> conv_init[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   Access: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_bias[fout' = fout] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): buf_bias[c3]
|   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: buf_bias }, { id: c3 } ] }
|   |   Generated Index expression: buf_output[c1][c3][c5][c7]
|   |   Generated Index expression: buf_bias[c3]
|   |   [stmt_code_generator function]
|   |   


|   [stmt_code_generator function]
|   |   Searching computation conv
|   |   Computation found.
|   |   [filter_computations_by_domain function]
|   |   |   Filtering computations by ISL AST domain.
|   |   |   ISL AST node domain: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Checking computation conv
|   |   |   Domain of the computation  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Domain of the computation in time-space domain  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Intersecting the set: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   With the set: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Intersection { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   This computation is accepted by the filter (intersection non-empty).
|   |   Computation: conv
|   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   Getting the access of the computation conv adapted to time-space.
|   |   |   Original access: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   Original schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Trimmed schedule to apply: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Transformed access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [get_rhs_accesses function]
|   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   Extracting access from e_op.
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   Searching computation conv
|   |   |   |   |   Computation found.
|   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   Range: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   Looking for a dimension named n in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 0
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   Looking for a dimension named fout in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y', x', fin', k_y', k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   Looking for a dimension named y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y', x', fin', k_y', k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 2
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x', fin', k_y', k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   Looking for a dimension named x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x', fin', k_y', k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 3
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin', k_y', k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 4
|   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin', k_y', k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y', k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 5
|   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y', k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 6
|   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   The access of this computation to buffers (before re-adapting its domain into the domain of the current access) :  { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   |   |   Applying access function on the range of transformation function: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   |   |   Apply the schedule on the domain of the access function. Access functions: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   |   |   Trimmed schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   Result:  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   Searching computation src
|   |   |   |   |   |   Computation found.
|   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   Range: { src[n, fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   Looking for a dimension named n in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 0
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin', y_pad, x_pad] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin', y_pad, x_pad] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   Looking for a dimension named y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 2
|   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   Looking for a dimension named x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 3
|   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   The access of this computation to buffers (before re-adapting its domain into the domain of the current access) :  { src[n, fin, y_pad, x_pad] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] }
|   |   |   |   |   |   Applying access function on the range of transformation function: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   Apply the schedule on the domain of the access function. Access functions: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   Trimmed schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   Result:  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   Searching computation weights
|   |   |   |   |   |   Computation found.
|   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   Range: { weights[n, fout, y, x] }
|   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   Looking for a dimension named fout in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout', y', x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout', y', x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y', x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y', x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   The access of this computation to buffers (before re-adapting its domain into the domain of the current access) :  { weights[n, fout, y, x] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   Applying access function on the range of transformation function: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   Apply the schedule on the domain of the access function. Access functions: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   Trimmed schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   Result:  { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [traverse_expr_and_extract_accesses function]
|   |   [get_rhs_accesses function]
|   |   [compute_iterators_map function]
|   |   |   Creating an isl_ast_index_expression for the access : { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   [create_isl_ast_index_expression function]
|   |   |   |   Schedule: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   Schedule reversed: { [n, fout, y, x, fin, k_y, k_x] -> conv[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   |   |   Access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): conv[c1][c3][c5][c7][c9][c11][c13]
|   |   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: conv }, { id: c1 }, { id: c3 }, { id: c5 }, { id: c7 }, { id: c9 }, { id: c11 }, { id: c13 } ] }
|   |   |   The iterators map is :
|   |   |   Original index name = n, Transformed index:  { id: c1 }
|   |   |   Original index name = fout, Transformed index:  { id: c3 }
|   |   |   Original index name = y, Transformed index:  { id: c5 }
|   |   |   Original index name = x, Transformed index:  { id: c7 }
|   |   |   Original index name = fin, Transformed index:  { id: c9 }
|   |   |   Original index name = k_y, Transformed index:  { id: c11 }
|   |   |   Original index name = k_x, Transformed index:  { id: c13 }
|   |   Generated RHS access maps:
|   |   |   Access 0: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Access 1: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Access 2: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Access 3: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   Creating an isl_ast_index_expression for the access (isl_map *): { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [create_isl_ast_index_expression function]
|   |   |   Schedule: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Schedule reversed: { [n, fout, y, x, fin, k_y, k_x] -> conv[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   Access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): buf_output[c1][c3][c5][c7]
|   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: buf_output }, { id: c1 }, { id: c3 }, { id: c5 }, { id: c7 } ] }
|   |   Creating an isl_ast_index_expression for the access (isl_map *): { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [create_isl_ast_index_expression function]
|   |   |   Schedule: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Schedule reversed: { [n, fout, y, x, fin, k_y, k_x] -> conv[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   Access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): buf_output[c1][c3][c5][c7]
|   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: buf_output }, { id: c1 }, { id: c3 }, { id: c5 }, { id: c7 } ] }
|   |   Creating an isl_ast_index_expression for the access (isl_map *): { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [create_isl_ast_index_expression function]
|   |   |   Schedule: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Schedule reversed: { [n, fout, y, x, fin, k_y, k_x] -> conv[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   Access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): buf_src[c1][c9][c5 + c11][c7 + c13]
|   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: buf_src }, { id: c1 }, { id: c9 }, { op: add, args: [ { id: c5 }, { id: c11 } ] }, { op: add, args: [ { id: c7 }, { id: c13 } ] } ] }
|   |   Creating an isl_ast_index_expression for the access (isl_map *): { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [create_isl_ast_index_expression function]
|   |   |   Schedule: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> [n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   Schedule reversed: { [n, fout, y, x, fin, k_y, k_x] -> conv[0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 10, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   iterator_map (the iterator map of an AST leaf after scheduling): |   |   |   |   |   |   Access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   index_aff = isl_pw_multi_aff_from_map(access): |   |   |   |   |   |   space(index_aff): |   |   |   |   |   |   space(iterator_map): |   |   |   |   |   |   isl_pw_multi_aff_pullback_pw_multi_aff(index_aff,iterator_map):|   |   |   |   |   |   isl_ast_build_access_from_pw_multi_aff(build, iterator_map): buf_weights[c3][c9][c11][c13]
|   |   The created isl_ast_expr expression for the index expression is : { op: access, args: [ { id: buf_weights }, { id: c3 }, { id: c9 }, { id: c11 }, { id: c13 } ] }
|   |   Generated Index expression: buf_output[c1][c3][c5][c7]
|   |   Generated Index expression: buf_output[c1][c3][c5][c7]
|   |   Generated Index expression: buf_src[c1][c9][c5 + c11][c7 + c13]
|   |   Generated Index expression: buf_weights[c3][c9][c11][c13]
|   |   [stmt_code_generator function]
|   |   


[gen_halide_stmt function]
|   


C like code:
for (int c1 = 0; c1 <= 7; c1 += 1)
  for (int c3 = 0; c3 <= 1; c3 += 1)
    for (int c5 = 0; c5 <= 1023; c5 += 1)
      for (int c7 = 0; c7 <= 1023; c7 += 1) {
        conv_init(0, c1, 0, c3, 0, c5, 0, c7, 0, 0, 0, 0, 0, 0, 0);
        for (int c9 = 0; c9 <= 2; c9 += 1)
          for (int c11 = 0; c11 <= 2; c11 += 1)
            for (int c13 = 0; c13 <= 2; c13 += 1)
              conv(0, c1, 0, c3, 0, c5, 0, c7, 10, c9, 0, c11, 0, c13, 0);
      }



|   [halide_stmt_from_isl_node function]
|   |   Generating code for Halide::For
|   |   Creating for loop init expression.
|   |   init expression: 0
|   |   Upper bound expression: 8
|   |   [halide_stmt_from_isl_node function]
|   |   |   Generating code for Halide::For
|   |   |   Creating for loop init expression.
|   |   |   init expression: 0
|   |   |   Upper bound expression: 2
|   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   Generating code for Halide::For
|   |   |   |   Creating for loop init expression.
|   |   |   |   init expression: 0
|   |   |   |   Upper bound expression: 1024
|   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   Generating code for Halide::For
|   |   |   |   |   Creating for loop init expression.
|   |   |   |   |   init expression: 0
|   |   |   |   |   Upper bound expression: 1024
|   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   Generating code for a block
|   |   |   |   |   |   Generating block.
|   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   Generating code for Halide::For
|   |   |   |   |   |   |   Creating for loop init expression.
|   |   |   |   |   |   |   init expression: 0
|   |   |   |   |   |   |   Upper bound expression: 3
|   |   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   |   Generating code for Halide::For
|   |   |   |   |   |   |   |   Creating for loop init expression.
|   |   |   |   |   |   |   |   init expression: 0
|   |   |   |   |   |   |   |   Upper bound expression: 3
|   |   |   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   |   |   Generating code for Halide::For
|   |   |   |   |   |   |   |   |   Creating for loop init expression.
|   |   |   |   |   |   |   |   |   init expression: 0
|   |   |   |   |   |   |   |   |   Upper bound expression: 3
|   |   |   |   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   |   |   |   Generating code for user node
|   |   |   |   |   |   |   |   |   |   Computation name: conv
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 0
|   |   |   |   |   |   |   |   |   |   |   Dimension 0 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 0
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 0 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 0 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 0 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 0 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 0
|   |   |   |   |   |   |   |   |   |   |   Dimension 0 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 1
|   |   |   |   |   |   |   |   |   |   |   Dimension 1 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 1
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 1 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 1 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 1 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 1 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 1
|   |   |   |   |   |   |   |   |   |   |   Dimension 1 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 2
|   |   |   |   |   |   |   |   |   |   |   Dimension 2 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 2
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 2 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 2 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 2 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 2 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 2
|   |   |   |   |   |   |   |   |   |   |   Dimension 2 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 3
|   |   |   |   |   |   |   |   |   |   |   Dimension 3 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 3
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 3 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 3 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 3 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 3 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 3
|   |   |   |   |   |   |   |   |   |   |   Dimension 3 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 4
|   |   |   |   |   |   |   |   |   |   |   Dimension 4 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 4
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 4 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 4 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 4 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 4 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 4
|   |   |   |   |   |   |   |   |   |   |   Dimension 4 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 5
|   |   |   |   |   |   |   |   |   |   |   Dimension 5 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 5
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 5 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 5 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 5 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 5 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 5
|   |   |   |   |   |   |   |   |   |   |   Dimension 5 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be parallelized at the loop level 6
|   |   |   |   |   |   |   |   |   |   |   Dimension 6 should not be mapped to CPU thread.
|   |   |   |   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be vectorized at the loop level 6
|   |   |   |   |   |   |   |   |   |   |   |   Dimension 6 should not be vectorized.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 6 should not be mapped to GPU block.
|   |   |   |   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 6 should not be mapped to GPU thread.
|   |   |   |   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   |   |   |   Dimension 6 should not be unrolled.
|   |   |   |   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   |   |   |   Checking if the computation conv should be distributed at the loop level 6
|   |   |   |   |   |   |   |   |   |   |   Dimension 6 should not be distributed.
|   |   |   |   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   |   |   |   The computation that corresponds to this node: 
Dumping the computation "conv" :
Iteration domain of the computation "conv" : Dumping the schedule of the computation conv : Expression of the computation : (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 1
Access expression: buf_output[c1][c3][c5][c7]
Access expression: buf_output[c1][c3][c5][c7]
Access expression: buf_src[c1][c9][c5 + c11][c7 + c13]
Access expression: buf_weights[c3][c9][c11][c13]
Halide statement: NULL


|   |   |   |   |   |   |   |   |   |   [create_halide_assignment function]
|   |   |   |   |   |   |   |   |   |   |   Generating stmt for assignment.
|   |   |   |   |   |   |   |   |   |   |   This is not a let statement.
|   |   |   |   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   |   |   |   Getting the access of the computation conv adapted to time-space.
|   |   |   |   |   |   |   |   |   |   |   |   Original access: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   |   |   |   |   |   |   |   |   |   Original schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   Transformed access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   |   |   |   |   |   |   |   Buffer name extracted from the access relation:  buf_output
|   |   |   |   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   |   |   |   Getting the access of the computation conv adapted to time-space.
|   |   |   |   |   |   |   |   |   |   |   |   Original access: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   |   |   |   |   |   |   |   |   |   Original schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   Transformed access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   |   |   |   |   |   |   |   A Tiramisu buffer that corresponds to the buffer indicated in the access relation was found.
|   |   |   |   |   |   |   |   |   |   |   Buffer "buf_output", Number of dimensions: 4
Dimension sizes: 8    2    1024    1024    
Elements type: int32
Function field: Not NULL
Argument type: output



|   |   |   |   |   |   |   |   |   |   |   Linearizing access of the LHS index expression.
|   |   |   |   |   |   |   |   |   |   |   [linearize_access function]
|   |   |   |   |   |   |   |   |   |   |   After linearization: ((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))

|   |   |   |   |   |   |   |   |   |   |   Index expressions of this statement are (the first is the LHS and the others are the RHS) :
|   |   |   |   |   |   |   |   |   |   |   List of index expressions.
|   |   |   |   |   |   |   |   |   |   |     buf_output[c1][c3][c5][c7]
|   |   |   |   |   |   |   |   |   |   |     buf_output[c1][c3][c5][c7]
|   |   |   |   |   |   |   |   |   |   |     buf_src[c1][c9][c5 + c11][c7 + c13]
|   |   |   |   |   |   |   |   |   |   |     buf_weights[c3][c9][c11][c13]
|   |   |   |   |   |   |   |   |   |   |   Erasing the LHS index expression from the vector of index expressions (the LHS index has just been linearized).
|   |   |   |   |   |   |   |   |   |   |   Halide buffer object created.  This object will be passed to the Halide function that creates an assignment to a buffer.
|   |   |   |   |   |   |   |   |   |   |   Calling the Halide::Internal::Store::make function which creates the store statement.
|   |   |   |   |   |   |   |   |   |   |   The RHS index expressions are first transformed to Halide expressions then passed to the make function.
|   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   Input expression: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))
|   |   |   |   |   |   |   |   |   |   |   |   Replacing iterators in an e_op.
|   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: conv(n, fout, y, x, fin, k_y, k_x)
|   |   |   |   |   |   |   |   |   |   |   |   |   Replacing the occurrences of original iterators in an o_access or o_address_of.
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: n
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c1
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c1 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c1) 
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: fout
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c3
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c3 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c3) 
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: y
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c5
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c5 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c5) 
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: x
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c7
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c7 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c7) 
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: fin
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c9
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c9 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c9) 
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: k_y
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c11
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c11 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c11) 
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: k_x
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c13
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Saved variable c13 of type int32
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c13) 
|   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: conv(cast(c1) , cast(c3) , cast(c5) , cast(c7) , cast(c9) , cast(c11) , cast(c13) )
|   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x))
|   |   |   |   |   |   |   |   |   |   |   |   |   Replacing iterators in an e_op.
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: src(n, fin, (y + k_y), (x + k_x))
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Replacing the occurrences of original iterators in an o_access or o_address_of.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: n
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c1
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c1) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: fin
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c9
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c9) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: (y + k_y)
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Replacing iterators in an e_op.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: y
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c5
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c5) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: k_y
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c11
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c11) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: (cast(c5)  + cast(c11) )
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: (x + k_x)
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Replacing iterators in an e_op.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: x
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c7
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c7) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: k_x
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c13
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c13) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: (cast(c7)  + cast(c13) )
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: src(cast(c1) , cast(c9) , (cast(c5)  + cast(c11) ), (cast(c7)  + cast(c13) ))
|   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: weights(fout, fin, k_y, k_x)
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Replacing the occurrences of original iterators in an o_access or o_address_of.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: fout
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c3
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c3) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: fin
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c9
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c9) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: k_y
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c11
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c11) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression: k_x
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Input expression:  c13
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: cast(c13) 
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: weights(cast(c3) , cast(c9) , cast(c11) , cast(c13) )
|   |   |   |   |   |   |   |   |   |   |   |   |   Output expression: (src(cast(c1) , cast(c9) , (cast(c5)  + cast(c11) ), (cast(c7)  + cast(c13) )) * weights(cast(c3) , cast(c9) , cast(c11) , cast(c13) ))
|   |   |   |   |   |   |   |   |   |   |   |   Output expression: (conv(cast(c1) , cast(c3) , cast(c5) , cast(c7) , cast(c9) , cast(c11) , cast(c13) ) + (src(cast(c1) , cast(c9) , (cast(c5)  + cast(c11) ), (cast(c7)  + cast(c13) )) * weights(cast(c3) , cast(c9) , cast(c11) , cast(c13) )))
|   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   Input Tiramisu expression: (conv(cast(c1) , cast(c3) , cast(c5) , cast(c7) , cast(c9) , cast(c11) , cast(c13) ) + (src(cast(c1) , cast(c9) , (cast(c5)  + cast(c11) ), (cast(c7)  + cast(c13) )) * weights(cast(c3) , cast(c9) , cast(c11) , cast(c13) )))
|   |   |   |   |   |   |   |   |   |   |   |   The input function is conv
|   |   |   |   |   |   |   |   |   |   |   |   The input index_expr is not empty.
|   |   |   |   |   |   |   |   |   |   |   |   tiramisu expression of type tiramisu::e_op
|   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   Input Tiramisu expression: conv(cast(c1) , cast(c3) , cast(c5) , cast(c7) , cast(c9) , cast(c11) , cast(c13) )
|   |   |   |   |   |   |   |   |   |   |   |   |   The input function is conv
|   |   |   |   |   |   |   |   |   |   |   |   |   The input index_expr is not empty.
|   |   |   |   |   |   |   |   |   |   |   |   |   tiramisu expression of type tiramisu::e_op
|   |   |   |   |   |   |   |   |   |   |   |   |   op type: o_access or o_address
|   |   |   |   |   |   |   |   |   |   |   |   |   Computation being accessed: conv
|   |   |   |   |   |   |   |   |   |   |   |   |   Searching computation conv
|   |   |   |   |   |   |   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Getting the access of the computation conv adapted to time-space.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Original access: { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Original schedule: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Transformed access: { conv[0, n, 0, fout, 0, y, 0, x, 10, fin, 0, k_y, 0, k_x, 0] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   |   |   |   |   |   |   |   |   |   |   Name of the associated buffer: buf_output
|   |   |   |   |   |   |   |   |   |   |   |   |   Buffer has constant extents.
|   |   |   |   |   |   |   |   |   |   |   |   |   Buffer strides have been computed.
|   |   |   |   |   |   |   |   |   |   |   |   |   index_expr is NOT empty. Retrieving access indices from index_expr (i.e., retrieving indices adapted to the schedule).
|   |   |   |   |   |   |   |   |   |   |   |   |   [linearize_access function]
|   |   |   |   |   |   |   |   |   |   |   |   |   Generated stmt: buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))]
|   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   Input Tiramisu expression: (src(cast(c1) , cast(c9) , (cast(c5)  + cast(c11) ), (cast(c7)  + cast(c13) )) * weights(cast(c3) , cast(c9) , cast(c11) , cast(c13) ))
|   |   |   |   |   |   |   |   |   |   |   |   |   The input function is conv
|   |   |   |   |   |   |   |   |   |   |   |   |   The input index_expr is not empty.
|   |   |   |   |   |   |   |   |   |   |   |   |   tiramisu expression of type tiramisu::e_op
|   |   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input Tiramisu expression: src(cast(c1) , cast(c9) , (cast(c5)  + cast(c11) ), (cast(c7)  + cast(c13) ))
|   |   |   |   |   |   |   |   |   |   |   |   |   |   The input function is conv
|   |   |   |   |   |   |   |   |   |   |   |   |   |   The input index_expr is not empty.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   tiramisu expression of type tiramisu::e_op
|   |   |   |   |   |   |   |   |   |   |   |   |   |   op type: o_access or o_address
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Computation being accessed: src
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Searching computation src
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Getting the access of the computation src adapted to time-space.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Original access: { src[n, fin, y_pad, x_pad] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Original schedule: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { src[t3, t4, t5, t6] -> src[0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Transformed access: { src[0, n, 0, fin, 0, y_pad, 0, x_pad, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] : 0 <= n <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Name of the associated buffer: buf_src
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Buffer has constant extents.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Buffer strides have been computed.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   index_expr is NOT empty. Retrieving access indices from index_expr (i.e., retrieving indices adapted to the schedule).
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [linearize_access function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Generated stmt: buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]
|   |   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Input Tiramisu expression: weights(cast(c3) , cast(c9) , cast(c11) , cast(c13) )
|   |   |   |   |   |   |   |   |   |   |   |   |   |   The input function is conv
|   |   |   |   |   |   |   |   |   |   |   |   |   |   The input index_expr is not empty.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   tiramisu expression of type tiramisu::e_op
|   |   |   |   |   |   |   |   |   |   |   |   |   |   op type: o_access or o_address
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Computation being accessed: weights
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Searching computation weights
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Getting the access of the computation weights adapted to time-space.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Original access: { weights[n, fout, y, x] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Original schedule: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { weights[t8, t9, t10, t11] -> weights[0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   Transformed access: { weights[0, n, 0, fout, 0, y, 0, x, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Name of the associated buffer: buf_weights
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Buffer has constant extents.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Buffer strides have been computed.
|   |   |   |   |   |   |   |   |   |   |   |   |   |   index_expr is NOT empty. Retrieving access indices from index_expr (i.e., retrieving indices adapted to the schedule).
|   |   |   |   |   |   |   |   |   |   |   |   |   |   [linearize_access function]
|   |   |   |   |   |   |   |   |   |   |   |   |   |   Generated stmt: buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]
|   |   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   |   op type: o_mul
|   |   |   |   |   |   |   |   |   |   |   |   |   Generated stmt: (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))])
|   |   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   |   op type: o_add
|   |   |   |   |   |   |   |   |   |   |   |   Generated stmt: (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
|   |   |   |   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   |   |   Halide::Internal::Store::make statement created.
|   |   |   |   |   |   |   |   |   |   |   End of create_halide_stmt. Generated statement is: buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
|   |   |   |   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   |   |   The full list of tagged statements is now:
|   |   |   |   |   |   |   |   |   
|   |   |   |   |   |   |   |   |   Creating the for loop.
|   |   |   |   |   |   |   |   |   For loop created.
|   |   |   |   |   |   |   |   |   for (c13, 0, (3 - 0)) {
  buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
}

|   |   |   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   |   The full list of tagged statements is now:
|   |   |   |   |   |   |   |   
|   |   |   |   |   |   |   |   Creating the for loop.
|   |   |   |   |   |   |   |   For loop created.
|   |   |   |   |   |   |   |   for (c11, 0, (3 - 0)) {
  for (c13, 0, (3 - 0)) {
    buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
  }
}

|   |   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   The full list of tagged statements is now:
|   |   |   |   |   |   |   
|   |   |   |   |   |   |   Creating the for loop.
|   |   |   |   |   |   |   For loop created.
|   |   |   |   |   |   |   for (c9, 0, (3 - 0)) {
  for (c11, 0, (3 - 0)) {
    for (c13, 0, (3 - 0)) {
      buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
    }
  }
}

|   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   Generated block: for (c9, 0, (3 - 0)) {
  for (c11, 0, (3 - 0)) {
    for (c13, 0, (3 - 0)) {
      buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
    }
  }
}
|   |   |   |   |   |   Block defined.
|   |   |   |   |   |   Result is now: for (c9, 0, (3 - 0)) {
  for (c11, 0, (3 - 0)) {
    for (c13, 0, (3 - 0)) {
      buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
    }
  }
}

|   |   |   |   |   |   Generating block.
|   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   |   Generating code for user node
|   |   |   |   |   |   |   Computation name: conv_init
|   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be parallelized at the loop level 0
|   |   |   |   |   |   |   |   Dimension 0 should not be mapped to CPU thread.
|   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be vectorized at the loop level 0
|   |   |   |   |   |   |   |   |   Dimension 0 should not be vectorized.
|   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   Dimension 0 should not be mapped to GPU block.
|   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   Dimension 0 should not be mapped to GPU thread.
|   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   Dimension 0 should not be unrolled.
|   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be distributed at the loop level 0
|   |   |   |   |   |   |   |   Dimension 0 should not be distributed.
|   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be parallelized at the loop level 1
|   |   |   |   |   |   |   |   Dimension 1 should not be mapped to CPU thread.
|   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be vectorized at the loop level 1
|   |   |   |   |   |   |   |   |   Dimension 1 should not be vectorized.
|   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   Dimension 1 should not be mapped to GPU block.
|   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   Dimension 1 should not be mapped to GPU thread.
|   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   Dimension 1 should not be unrolled.
|   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be distributed at the loop level 1
|   |   |   |   |   |   |   |   Dimension 1 should not be distributed.
|   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be parallelized at the loop level 2
|   |   |   |   |   |   |   |   Dimension 2 should not be mapped to CPU thread.
|   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be vectorized at the loop level 2
|   |   |   |   |   |   |   |   |   Dimension 2 should not be vectorized.
|   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   Dimension 2 should not be mapped to GPU block.
|   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   Dimension 2 should not be mapped to GPU thread.
|   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   Dimension 2 should not be unrolled.
|   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be distributed at the loop level 2
|   |   |   |   |   |   |   |   Dimension 2 should not be distributed.
|   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   [should_parallelize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be parallelized at the loop level 3
|   |   |   |   |   |   |   |   Dimension 3 should not be mapped to CPU thread.
|   |   |   |   |   |   |   [should_vectorize function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be vectorized at the loop level 3
|   |   |   |   |   |   |   |   |   Dimension 3 should not be vectorized.
|   |   |   |   |   |   |   [should_map_to_gpu_block function]
|   |   |   |   |   |   |   |   Dimension 3 should not be mapped to GPU block.
|   |   |   |   |   |   |   [should_map_to_gpu_thread function]
|   |   |   |   |   |   |   |   Dimension 3 should not be mapped to GPU thread.
|   |   |   |   |   |   |   [should_unroll function]
|   |   |   |   |   |   |   |   Dimension 3 should not be unrolled.
|   |   |   |   |   |   |   [should_distribute function]
|   |   |   |   |   |   |   |   Checking if the computation conv_init should be distributed at the loop level 3
|   |   |   |   |   |   |   |   Dimension 3 should not be distributed.
|   |   |   |   |   |   |   The full list of tagged statements is now
|   |   |   |   |   |   |   The computation that corresponds to this node: 
Dumping the computation "conv_init" :
Iteration domain of the computation "conv_init" : Dumping the schedule of the computation conv_init : Expression of the computation : bias(fout)
Access relation of the computation : Time-space domain 
Computation to be scheduled ? 1
Access expression: buf_output[c1][c3][c5][c7]
Access expression: buf_bias[c3]
Halide statement: NULL


|   |   |   |   |   |   |   [create_halide_assignment function]
|   |   |   |   |   |   |   |   Generating stmt for assignment.
|   |   |   |   |   |   |   |   This is not a let statement.
|   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   Getting the access of the computation conv_init adapted to time-space.
|   |   |   |   |   |   |   |   |   Original access: { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   |   |   |   Original schedule: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { conv_init[t13, t14, t15, t16] -> conv_init[0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   |   |   |   |   Transformed access: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   |   |   |   |   |   Buffer name extracted from the access relation:  buf_output
|   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   Getting the access of the computation conv_init adapted to time-space.
|   |   |   |   |   |   |   |   |   Original access: { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   |   |   |   Original schedule: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { conv_init[t13, t14, t15, t16] -> conv_init[0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   |   |   |   |   Transformed access: { conv_init[0, n, 0, fout, 0, y, 0, x, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   |   |   |   |   |   A Tiramisu buffer that corresponds to the buffer indicated in the access relation was found.
|   |   |   |   |   |   |   |   Buffer "buf_output", Number of dimensions: 4
Dimension sizes: 8    2    1024    1024    
Elements type: int32
Function field: Not NULL
Argument type: output



|   |   |   |   |   |   |   |   Linearizing access of the LHS index expression.
|   |   |   |   |   |   |   |   [linearize_access function]
|   |   |   |   |   |   |   |   After linearization: ((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))

|   |   |   |   |   |   |   |   Index expressions of this statement are (the first is the LHS and the others are the RHS) :
|   |   |   |   |   |   |   |   List of index expressions.
|   |   |   |   |   |   |   |     buf_output[c1][c3][c5][c7]
|   |   |   |   |   |   |   |     buf_bias[c3]
|   |   |   |   |   |   |   |   Erasing the LHS index expression from the vector of index expressions (the LHS index has just been linearized).
|   |   |   |   |   |   |   |   Halide buffer object created.  This object will be passed to the Halide function that creates an assignment to a buffer.
|   |   |   |   |   |   |   |   Calling the Halide::Internal::Store::make function which creates the store statement.
|   |   |   |   |   |   |   |   The RHS index expressions are first transformed to Halide expressions then passed to the make function.
|   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   Input expression: bias(fout)
|   |   |   |   |   |   |   |   |   Replacing the occurrences of original iterators in an o_access or o_address_of.
|   |   |   |   |   |   |   |   |   [replace_original_indices_with_transformed_indices function]
|   |   |   |   |   |   |   |   |   |   Input expression: fout
|   |   |   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   |   |   Input expression:  c3
|   |   |   |   |   |   |   |   |   |   Output expression: cast(c3) 
|   |   |   |   |   |   |   |   |   Output expression: bias(cast(c3) )
|   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   |   Input Tiramisu expression: bias(cast(c3) )
|   |   |   |   |   |   |   |   |   The input function is conv
|   |   |   |   |   |   |   |   |   The input index_expr is not empty.
|   |   |   |   |   |   |   |   |   tiramisu expression of type tiramisu::e_op
|   |   |   |   |   |   |   |   |   op type: o_access or o_address
|   |   |   |   |   |   |   |   |   Computation being accessed: bias
|   |   |   |   |   |   |   |   |   Searching computation bias
|   |   |   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   |   |   [get_access_relation_adapted_to_time_processor_domain function]
|   |   |   |   |   |   |   |   |   |   Getting the access of the computation bias adapted to time-space.
|   |   |   |   |   |   |   |   |   |   Original access: { bias[fout] -> buf_bias[fout' = fout] }
|   |   |   |   |   |   |   |   |   |   Original schedule: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   |   |   |   |   |   |   Trimmed schedule to apply: { bias[t1] -> bias[0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   |   |   |   |   |   |   Transformed access: { bias[0, fout, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] -> buf_bias[fout' = fout] : 0 <= fout <= 1 }
|   |   |   |   |   |   |   |   |   Name of the associated buffer: buf_bias
|   |   |   |   |   |   |   |   |   Buffer has constant extents.
|   |   |   |   |   |   |   |   |   Buffer strides have been computed.
|   |   |   |   |   |   |   |   |   index_expr is NOT empty. Retrieving access indices from index_expr (i.e., retrieving indices adapted to the schedule).
|   |   |   |   |   |   |   |   |   [linearize_access function]
|   |   |   |   |   |   |   |   |   Generated stmt: buf_bias[(0 + int32((int64(c3)*(int64)1)))]
|   |   |   |   |   |   |   |   [halide_expr_from_tiramisu_expr function]
|   |   |   |   |   |   |   |   Halide::Internal::Store::make statement created.
|   |   |   |   |   |   |   |   End of create_halide_stmt. Generated statement is: buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
|   |   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   |   Generated block: buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
|   |   |   |   |   |   Block defined.
|   |   |   |   |   |   Result is now: buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
for (c9, 0, (3 - 0)) {
  for (c11, 0, (3 - 0)) {
    for (c13, 0, (3 - 0)) {
      buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
    }
  }
}

|   |   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   |   The full list of tagged statements is now:
|   |   |   |   |   
|   |   |   |   |   Creating the for loop.
|   |   |   |   |   For loop created.
|   |   |   |   |   for (c7, 0, (1024 - 0)) {
  buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
  for (c9, 0, (3 - 0)) {
    for (c11, 0, (3 - 0)) {
      for (c13, 0, (3 - 0)) {
        buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
      }
    }
  }
}

|   |   |   |   [halide_stmt_from_isl_node function]
|   |   |   |   The full list of tagged statements is now:
|   |   |   |   
|   |   |   |   Creating the for loop.
|   |   |   |   For loop created.
|   |   |   |   for (c5, 0, (1024 - 0)) {
  for (c7, 0, (1024 - 0)) {
    buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
    for (c9, 0, (3 - 0)) {
      for (c11, 0, (3 - 0)) {
        for (c13, 0, (3 - 0)) {
          buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
        }
      }
    }
  }
}

|   |   |   [halide_stmt_from_isl_node function]
|   |   |   The full list of tagged statements is now:
|   |   |   
|   |   |   Creating the for loop.
|   |   |   For loop created.
|   |   |   for (c3, 0, (2 - 0)) {
  for (c5, 0, (1024 - 0)) {
    for (c7, 0, (1024 - 0)) {
      buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
      for (c9, 0, (3 - 0)) {
        for (c11, 0, (3 - 0)) {
          for (c13, 0, (3 - 0)) {
            buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
          }
        }
      }
    }
  }
}

|   |   [halide_stmt_from_isl_node function]
|   |   The full list of tagged statements is now:
|   |   
|   |   Creating the for loop.
|   |   For loop created.
|   |   for (c1, 0, (8 - 0)) {
  for (c3, 0, (2 - 0)) {
    for (c5, 0, (1024 - 0)) {
      for (c7, 0, (1024 - 0)) {
        buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
        for (c9, 0, (3 - 0)) {
          for (c11, 0, (3 - 0)) {
            for (c13, 0, (3 - 0)) {
              buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
            }
          }
        }
      }
    }
  }
}

|   [halide_stmt_from_isl_node function]
|   The following Halide statement was generated:
for (c1, 0, (8 - 0)) {
  for (c3, 0, (2 - 0)) {
    for (c5, 0, (1024 - 0)) {
      for (c7, 0, (1024 - 0)) {
        buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
        for (c9, 0, (3 - 0)) {
          for (c11, 0, (3 - 0)) {
            for (c13, 0, (3 - 0)) {
              buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
            }
          }
        }
      }
    }
  }
}


|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (2 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 2
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 2
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (2 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (3 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 3
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 3
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (3 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (3 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 3
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 3
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (3 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (3 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 3
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 3
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (3 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (2 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 2
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 2
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (2 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (8 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 8
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 8
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (8 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (2 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 2
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 2
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (2 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (8 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 8
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 8
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (8 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (3 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 3
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 3
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (3 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (8 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 8
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 8
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (8 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (1024 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 1024
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 1024
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (1024 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (2 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 2
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 2
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (2 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   [halide_expr_from_tiramisu_expr function]
|   |   Input Tiramisu expression: (8 - 0)
|   |   The input function is conv
|   |   The input index_expr is empty.
|   |   tiramisu expression of type tiramisu::e_op
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 8
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 8
|   |   [halide_expr_from_tiramisu_expr function]
|   |   [halide_expr_from_tiramisu_expr function]
|   |   |   Input Tiramisu expression: 0
|   |   |   The input function is conv
|   |   |   The input index_expr is empty.
|   |   |   tiramisu expression of type tiramisu::e_val
|   |   |   Generated stmt: 0
|   |   [halide_expr_from_tiramisu_expr function]
|   |   op type: o_sub
|   |   Generated stmt: (8 - 0)
|   [halide_expr_from_tiramisu_expr function]
|   

Generated Halide stmt before lowering:
|   produce  {
  allocate _weights_b2[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _src_b1[int32 * (1024 - 0) * (1024 - 0) * (3 - 0) * (8 - 0)]
  allocate _conv_init_b3[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _conv_b4[int32 * (3 - 0) * (3 - 0) * (3 - 0) * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _bias_b0[int32 * (2 - 0)]
  for (c1, 0, (8 - 0)) {
    for (c3, 0, (2 - 0)) {
      for (c5, 0, (1024 - 0)) {
        for (c7, 0, (1024 - 0)) {
          buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
          for (c9, 0, (3 - 0)) {
            for (c11, 0, (3 - 0)) {
              for (c13, 0, (3 - 0)) {
                buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}

Lower halide pipeline...
produce  {
  allocate _weights_b2[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _src_b1[int32 * (1024 - 0) * (1024 - 0) * (3 - 0) * (8 - 0)]
  allocate _conv_init_b3[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _conv_b4[int32 * (3 - 0) * (3 - 0) * (3 - 0) * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _bias_b0[int32 * (2 - 0)]
  for (c1, 0, (8 - 0)) {
    for (c3, 0, (2 - 0)) {
      for (c5, 0, (1024 - 0)) {
        for (c7, 0, (1024 - 0)) {
          buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
          for (c9, 0, (3 - 0)) {
            for (c11, 0, (3 - 0)) {
              for (c13, 0, (3 - 0)) {
                buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}

Performing sliding window optimization...

Lowering after sliding window:
produce  {
  allocate _weights_b2[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _src_b1[int32 * (1024 - 0) * (1024 - 0) * (3 - 0) * (8 - 0)]
  allocate _conv_init_b3[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _conv_b4[int32 * (3 - 0) * (3 - 0) * (3 - 0) * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _bias_b0[int32 * (2 - 0)]
  for (c1, 0, (8 - 0)) {
    for (c3, 0, (2 - 0)) {
      for (c5, 0, (1024 - 0)) {
        for (c7, 0, (1024 - 0)) {
          buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
          for (c9, 0, (3 - 0)) {
            for (c11, 0, (3 - 0)) {
              for (c13, 0, (3 - 0)) {
                buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Removing code that depends on undef values...

Lowering after removing code that depends on undef values:
produce  {
  allocate _weights_b2[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _src_b1[int32 * (1024 - 0) * (1024 - 0) * (3 - 0) * (8 - 0)]
  allocate _conv_init_b3[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _conv_b4[int32 * (3 - 0) * (3 - 0) * (3 - 0) * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _bias_b0[int32 * (2 - 0)]
  for (c1, 0, (8 - 0)) {
    for (c3, 0, (2 - 0)) {
      for (c5, 0, (1024 - 0)) {
        for (c7, 0, (1024 - 0)) {
          buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
          for (c9, 0, (3 - 0)) {
            for (c11, 0, (3 - 0)) {
              for (c13, 0, (3 - 0)) {
                buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Uniquifying variable names...

Lowering after uniquifying variable names:
produce  {
  allocate _weights_b2[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _src_b1[int32 * (1024 - 0) * (1024 - 0) * (3 - 0) * (8 - 0)]
  allocate _conv_init_b3[int32 * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _conv_b4[int32 * (3 - 0) * (3 - 0) * (3 - 0) * (1024 - 0) * (1024 - 0) * (2 - 0) * (8 - 0)]
  allocate _bias_b0[int32 * (2 - 0)]
  for (c1, 0, (8 - 0)) {
    for (c3, 0, (2 - 0)) {
      for (c5, 0, (1024 - 0)) {
        for (c7, 0, (1024 - 0)) {
          buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[(0 + int32((int64(c3)*(int64)1)))]
          for (c9, 0, (3 - 0)) {
            for (c11, 0, (3 - 0)) {
              for (c13, 0, (3 - 0)) {
                buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[((((0 + int32((int64(c7)*(int64)1))) + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((0 + int32((int64((c7 + c13))*(int64)1))) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[((((0 + int32((int64(c13)*(int64)1))) + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Simplifying...

Lowering after simplification:
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Performing storage folding optimization...

Lowering after storage folding:
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Simplifying...

Lowering after simplification:
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Destructuring tuple-valued realizations...

Lowering after destructuring tuple-valued realizations:
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}





Unpacking buffer arguments...

Lowering after unpacking buffer arguments:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Simplifying...

Lowering after second simplifcation:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}



Generated Halide IR:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}
Reduce prefetch dimension...

Lowering after reduce prefetch dimension:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Unrolling...

Lowering after unrolling:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Vectorizing...

Lowering after vectorizing:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Detecting vector interleavings...

Lowering after rewriting vector interleavings:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Partitioning loops to simplify boundary conditions...

Lowering after partitioning loops:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}


Injecting early frees...

Lowering after injecting early frees:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  allocate _weights_b2[int32 * 1024 * 1024 * 2 * 8]
  allocate _src_b1[int32 * 1024 * 1024 * 3 * 8]
  allocate _conv_init_b3[int32 * 1024 * 1024 * 2 * 8]
  allocate _conv_b4[int32 * 3 * 3 * 3 * 1024 * 1024 * 2 * 8]
  allocate _bias_b0[int32 * 2]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
  free _bias_b0
  free _conv_b4
  free _conv_init_b3
  free _src_b1
  free _weights_b2
}


Simplifying...

Lowering after final simplification:
assert((reinterpret(uint64, buf_weights.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_weights"))
assert((reinterpret(uint64, buf_src.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_src"))
assert((reinterpret(uint64, buf_output.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_output"))
assert((reinterpret(uint64, buf_bias.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf_bias"))
let buf_bias = _halide_buffer_get_host(buf_bias.buffer)
let buf_output = _halide_buffer_get_host(buf_output.buffer)
let buf_src = _halide_buffer_get_host(buf_src.buffer)
let buf_weights = _halide_buffer_get_host(buf_weights.buffer)
produce  {
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 1024) {
        for (c7, 0, 1024) {
          buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = buf_bias[c3]
          for (c9, 0, 3) {
            for (c11, 0, 3) {
              for (c13, 0, 3) {
                buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] = (buf_output[(((c7 + int32((int64(c5)*(int64)1024))) + int32((int64(c3)*(int64)1048576))) + int32((int64(c1)*(int64)2097152)))] + (buf_src[((((c7 + c13) + int32((int64((c5 + c11))*(int64)1024))) + int32((int64(c9)*(int64)1048576))) + int32((int64(c1)*(int64)3145728)))]*buf_weights[(((c13 + int32((int64(c11)*(int64)3))) + int32((int64(c9)*(int64)9))) + int32((int64(c3)*(int64)27)))]))
              }
            }
          }
        }
      }
    }
  }
}

======================step2==================================
Saved variable root of type int32
Saved variable n of type int32
Saved variable fout of type int32
Saved variable y of type int32
Saved variable x of type int32
Saved variable fin of type int32
Saved variable k_y of type int32
Saved variable k_x of type int32
Saved variable y_pad of type int32
Saved variable x_pad of type int32
Saved variable t0 of type int32
[computation function]
|   Constructing an unscheduled computation.
|   Creating computation bias
|   Constructed iteration domain: {bias[fout] : 0<=fout<2}
|   [init_computation function]
|   |   Constructing the computation: {bias[fout] : 0<=fout<2}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { bias[fout] -> bias[0, 0, fout' = fout, 0] : 0 <= fout <= 1 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t1
|   |   |   The schedule after renaming:  { bias[t1] -> bias[0, 0, fout = t1, 0] : 0 <= t1 <= 1 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into fout
|   |   |   The schedule after renaming:  { bias[t1] -> bias[0, 0, fout = t1, 0] : 0 <= t1 <= 1 }
|   |   Searching computation bias
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { bias[fout] -> _bias_b0[fout' = fout] }
|   |   [set_access function]
|   |   |   Setting access { bias[fout] -> _bias_b0[fout' = fout] } for computation bias
|   |   |   Searching computation bias
|   |   |   Computation found.
|   |   |   Searching computation bias
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "bias" :
Iteration domain of the computation "bias" : Dumping the schedule of the computation bias : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 0
Halide statement: NULL


Saved variable t2 of type int32
[computation function]
|   Constructing an unscheduled computation.
|   Creating computation src
|   Constructed iteration domain: {src[n, fin, y_pad, x_pad] : 0<=n<8 and 0<=fin<3 and 0<=y_pad<1024 and 0<=x_pad<1024}
|   [init_computation function]
|   |   Constructing the computation: {src[n, fin, y_pad, x_pad] : 0<=n<8 and 0<=fin<3 and 0<=y_pad<1024 and 0<=x_pad<1024}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { src[n, fin, y_pad, x_pad] -> src[0, 0, n' = n, 0, fin' = fin, 0, y_pad' = y_pad, 0, x_pad' = x_pad, 0] : 0 <= n <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t3
|   |   |   The schedule after renaming:  { src[t3, fin, y_pad, x_pad] -> src[0, 0, n = t3, 0, fin' = fin, 0, y_pad' = y_pad, 0, x_pad' = x_pad, 0] : 0 <= t3 <= 7 and 0 <= fin <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t4
|   |   |   The schedule after renaming:  { src[t3, t4, y_pad, x_pad] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad' = y_pad, 0, x_pad' = x_pad, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= y_pad <= 1023 and 0 <= x_pad <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t5
|   |   |   The schedule after renaming:  { src[t3, t4, t5, x_pad] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad' = x_pad, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= x_pad <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t6
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fin
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y_pad
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x_pad
|   |   |   The schedule after renaming:  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   Searching computation src
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { src[n, fin, y_pad, x_pad] -> _src_b1[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] }
|   |   [set_access function]
|   |   |   Setting access { src[n, fin, y_pad, x_pad] -> _src_b1[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] } for computation src
|   |   |   Searching computation src
|   |   |   Computation found.
|   |   |   Searching computation src
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "src" :
Iteration domain of the computation "src" : Dumping the schedule of the computation src : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 0
Halide statement: NULL


Saved variable t7 of type int32
[computation function]
|   Constructing an unscheduled computation.
|   Creating computation weights
|   Constructed iteration domain: {weights[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   [init_computation function]
|   |   Constructing the computation: {weights[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { weights[n, fout, y, x] -> weights[0, 0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t8
|   |   |   The schedule after renaming:  { weights[t8, fout, y, x] -> weights[0, 0, n = t8, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= t8 <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t9
|   |   |   The schedule after renaming:  { weights[t8, t9, y, x] -> weights[0, 0, n = t8, 0, fout = t9, 0, y' = y, 0, x' = x, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t10
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, x] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x' = x, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t11
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fout
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x
|   |   |   The schedule after renaming:  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   Searching computation weights
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { weights[n, fout, y, x] -> _weights_b2[n' = n, fout' = fout, y' = y, x' = x] }
|   |   [set_access function]
|   |   |   Setting access { weights[n, fout, y, x] -> _weights_b2[n' = n, fout' = fout, y' = y, x' = x] } for computation weights
|   |   |   Searching computation weights
|   |   |   Computation found.
|   |   |   Searching computation weights
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "weights" :
Iteration domain of the computation "weights" : Dumping the schedule of the computation weights : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 0
Halide statement: NULL


Saved variable t12 of type int32
[computation function]
|   Constructing a scheduled computation.
|   Creating computation conv_init
|   Constructed iteration domain: {conv_init[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   [init_computation function]
|   |   Constructing the computation: {conv_init[n, fout, y, x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { conv_init[n, fout, y, x] -> conv_init[0, 0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: bias(fout)|   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: bias(fout)
|   |   |   |   Looking for non-affine accesses in an o_access.
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fout
|   |   |   |   |   [access_is_affine function]
|   |   |   The new expression is: bias(fout)|   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t13
|   |   |   The schedule after renaming:  { conv_init[t13, fout, y, x] -> conv_init[0, 0, n = t13, 0, fout' = fout, 0, y' = y, 0, x' = x, 0] : 0 <= t13 <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t14
|   |   |   The schedule after renaming:  { conv_init[t13, t14, y, x] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y' = y, 0, x' = x, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t15
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, x] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x' = x, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= x <= 1023 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t16
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fout
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x
|   |   |   The schedule after renaming:  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   Searching computation conv_init
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { conv_init[n, fout, y, x] -> _conv_init_b3[n' = n, fout' = fout, y' = y, x' = x] }
|   |   [set_access function]
|   |   |   Setting access { conv_init[n, fout, y, x] -> _conv_init_b3[n' = n, fout' = fout, y' = y, x' = x] } for computation conv_init
|   |   |   Searching computation conv_init
|   |   |   Computation found.
|   |   |   Searching computation conv_init
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "conv_init" :
Iteration domain of the computation "conv_init" : Dumping the schedule of the computation conv_init : Expression of the computation : bias(fout)
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 1
Halide statement: NULL


Saved variable t17 of type int32
[computation function]
|   Constructing a scheduled computation.
|   Creating computation conv
|   Constructed iteration domain: {conv[n, fout, y, x, fin, k_y, k_x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024 and 0<=fin<3 and 0<=k_y<3 and 0<=k_x<3}
|   [init_computation function]
|   |   Constructing the computation: {conv[n, fout, y, x, fin, k_y, k_x] : 0<=n<8 and 0<=fout<2 and 0<=y<1024 and 0<=x<1024 and 0<=fin<3 and 0<=k_y<3 and 0<=k_x<3}
|   |   [name_unnamed_iteration_domain_dimensions function]
|   |   [add_computation function]
|   |   [set_identity_schedule_based_on_iteration_domain function]
|   |   |   [gen_identity_schedule_for_iteration_domain function]
|   |   |   The following identity schedule is generated (setting schedule 0): 
|   |   |   { conv[n, fout, y, x, fin, k_y, k_x] -> conv[0, 0, n' = n, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   |   The identity schedule for the original computation is set.
|   |   [set_expression function]
|   |   |   The original expression is: |   |   |   
|   |   |   Traversing the expression to replace non-affine accesses by a constant definition.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: 
|   |   |   The new expression is: |   |   |   
|   |   [get_iteration_domain_dimension_names function]
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of the domain of the schedule dimension 0 into t18
|   |   |   The schedule after renaming:  { conv[t18, fout, y, x, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout' = fout, 0, y' = y, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of the domain of the schedule dimension 1 into t19
|   |   |   The schedule after renaming:  { conv[t18, t19, y, x, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y' = y, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of the domain of the schedule dimension 2 into t20
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, x, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x' = x, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of the domain of the schedule dimension 3 into t21
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, fin, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin' = fin, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 4
|   |   |   Setting the name of the domain of the schedule dimension 4 into t22
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, k_y, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y' = k_y, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 5
|   |   |   Setting the name of the domain of the schedule dimension 5 into t23
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, k_x] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x' = k_x, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= k_x <= 2 }
|   |   [set_schedule_domain_dim_names function]
|   |   |   Checking the validity of loop level 6
|   |   |   Setting the name of the domain of the schedule dimension 6 into t24
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 0
|   |   |   Setting the name of loop level 0 into n
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 1
|   |   |   Setting the name of loop level 1 into fout
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 2
|   |   |   Setting the name of loop level 2 into y
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 3
|   |   |   Setting the name of loop level 3 into x
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 4
|   |   |   Setting the name of loop level 4 into fin
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 5
|   |   |   Setting the name of loop level 5 into k_y
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [set_loop_level_names function]
|   |   |   Checking the validity of loop level 6
|   |   |   Setting the name of loop level 6 into k_x
|   |   |   The schedule after renaming:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Searching computation conv
|   |   Computation found.
|   [store_in function]
|   |   Binding. The following access function is set:  { conv[n, fout, y, x, fin, k_y, k_x] -> _conv_b4[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   [set_access function]
|   |   |   Setting access { conv[n, fout, y, x, fin, k_y, k_x] -> _conv_b4[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] } for computation conv
|   |   |   Searching computation conv
|   |   |   Computation found.
|   |   |   Searching computation conv
|   |   |   Computation found.
|   Constructed computation: 
Dumping the computation "conv" :
Iteration domain of the computation "conv" : Dumping the schedule of the computation conv : Expression of the computation : 
Access relation of the computation : Time-space domain : NULL.
Computation to be scheduled ? 1
Halide statement: NULL


[set_expression function]
|   The original expression is: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))|   
|   Traversing the expression to replace non-affine accesses by a constant definition.
|   [traverse_expr_and_replace_non_affine_accesses function]
|   |   Input expression: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))
|   |   Extracting access from e_op.
|   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   Input expression: conv(n, fout, y, x, fin, k_y, k_x)
|   |   |   Looking for non-affine accesses in an o_access.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: n
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: fout
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: y
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: x
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: fin
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: k_y
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: k_x
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   |   |   [access_is_affine function]
|   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   Input expression: (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x))
|   |   |   Extracting access from e_op.
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: src(n, fin, (y + k_y), (x + k_x))
|   |   |   |   Looking for non-affine accesses in an o_access.
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: n
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fin
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: (y + k_y)
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: y
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: k_y
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: (x + k_x)
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: x
|   |   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   |   Input expression: k_x
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   |   |   |   [access_is_affine function]
|   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   Input expression: weights(fout, fin, k_y, k_x)
|   |   |   |   Looking for non-affine accesses in an o_access.
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fout
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: fin
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: k_y
|   |   |   |   [traverse_expr_and_replace_non_affine_accesses function]
|   |   |   |   |   Input expression: k_x
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   |   |   |   |   [access_is_affine function]
|   The new expression is: (conv(n, fout, y, x, fin, k_y, k_x) + (src(n, fin, (y + k_y), (x + k_x)) * weights(fout, fin, k_y, k_x)))|   
[then function]
|   [after function]
|   |   [get_loop_level_numbers_from_dimension_names function]
|   |   |   Searching for the dimension x
|   |   |   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Corresponding loop level is 3
|   |   |   Checking the validity of loop level 3
|   |   The loop level that corresponds to x is 3
|   |   [after function]
|   |   |   Scheduling conv to be executed after conv_init at level 3
|   |   |   sched_graph[conv_init, conv] = 3
[store_in function]
|   Binding. The following access function is set:  { bias[fout] -> buf_bias[fout' = fout] }
|   [set_access function]
|   |   Setting access { bias[fout] -> buf_bias[fout' = fout] } for computation bias
|   |   Searching computation bias
|   |   Computation found.
|   |   Searching computation bias
|   |   Computation found.
[store_in function]
|   Binding. The following access function is set:  { src[n, fin, y_pad, x_pad] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] }
|   [set_access function]
|   |   Setting access { src[n, fin, y_pad, x_pad] -> buf_src[n' = n, fin' = fin, y_pad' = y_pad, x_pad' = x_pad] } for computation src
|   |   Searching computation src
|   |   Computation found.
|   |   Searching computation src
|   |   Computation found.
[store_in function]
|   Binding. The following access function is set:  { weights[n, fout, y, x] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] }
|   [set_access function]
|   |   Setting access { weights[n, fout, y, x] -> buf_weights[n' = n, fout' = fout, y' = y, x' = x] } for computation weights
|   |   Searching computation weights
|   |   Computation found.
|   |   Searching computation weights
|   |   Computation found.
[store_in function]
|   Binding. The following access function is set:  { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] }
|   [set_access function]
|   |   Setting access { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] } for computation conv_init
|   |   Searching computation conv_init
|   |   Computation found.
|   |   Searching computation conv_init
|   |   Computation found.
[store_in function]
|   [get_iteration_domain_dimension_names function]
|   Parsing following access statement:  [] -> {conv[n,fout,y,x,fin,k_y,k_x] -> buf_output[n, fout, y, x]}
|   Binding. The following access function is set:  { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] }
|   [set_access function]
|   |   Setting access { conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] } for computation conv
|   |   Searching computation conv
|   |   Computation found.
|   |   Searching computation conv
|   |   Computation found.
[align_schedules function]
|   [get_max_schedules_range_dim function]
|   [isl_map_align_range_dims function]
|   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0] : 0 <= t1 <= 1 }
|   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] : 0 <= t1 <= 1 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, 0, 0, 0, 0, 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, 0, 0, 0, 0, 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, 0, 0, 0, 0, 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   [name_unnamed_time_space_dimensions function]
|   [isl_map_align_range_dims function]
|   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   [name_unnamed_time_space_dimensions function]
End of function
[gen_ordering_schedules function]
|   Number of schedule graph roots is 1
|   The roots are:
|    * conv_init@0x7ffc0c24bc10
|   Displaying schedule graph
|   conv_init@0x7ffc0c24bc10=[3]=>conv@0x7ffc0c24c080
|   Finished displaying schedule graph
|   [is_sched_graph_tree function]
|   this->is_sched_graph_tree(): true.
|   [after_low_level function]
|   |   Setting the schedule of conv after conv_init at dimension 9
|   |   Setting the schedule of conv to be equal to the schedule of conv_init at all the dimensions before dimension 9
|   |   [align_schedules function]
|   |   |   [get_max_schedules_range_dim function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   [isl_map_align_range_dims function]
|   |   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [name_unnamed_time_space_dimensions function]
|   |   End of function
|   |   Preparing to adjust the schedule of the computation conv
|   |   Original schedule:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Dimension level in which ordering dimensions will be inserted : 9
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 1
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 1
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 1
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n', o3, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 3
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 3
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 3
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 5
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 5
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 5
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 7
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 7
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 0
|   |   |   Setting the constraint for dimension 7
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [isl_map_get_static_dim function]
|   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 9
|   |   |   Dimensions found.  Constant = 0
|   |   |   The constant is: 0
|   |   [add_eq_to_schedule_map function]
|   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 0, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Editing the dimension 9
|   |   |   Coefficient of the input dimension 0
|   |   |   Coefficient of the output dimension -1
|   |   |   Coefficient of the constant 10
|   |   |   Setting the constraint for dimension 9
|   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin', o11, k_y', o13, k_x', o15] }
|   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   Schedule adjusted:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
[performe_full_dependency_analysis function]
|   [align_schedules function]
|   |   [get_max_schedules_range_dim function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   [name_unnamed_time_space_dimensions function]
|   |   [isl_map_align_range_dims function]
|   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   [name_unnamed_time_space_dimensions function]
|   End of function
|   [gen_ordering_schedules function]
|   |   Number of schedule graph roots is 1
|   |   The roots are:
|   |    * conv_init@0x7ffc0c24bc10
|   |   Displaying schedule graph
|   |   conv_init@0x7ffc0c24bc10=[3]=>conv@0x7ffc0c24c080
|   |   Finished displaying schedule graph
|   |   [is_sched_graph_tree function]
|   |   this->is_sched_graph_tree(): true.
|   |   [after_low_level function]
|   |   |   Setting the schedule of conv after conv_init at dimension 9
|   |   |   Setting the schedule of conv to be equal to the schedule of conv_init at all the dimensions before dimension 9
|   |   |   [align_schedules function]
|   |   |   |   [get_max_schedules_range_dim function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   |   After alignment, map =  { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   |   After alignment, map =  { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   |   After alignment, map =  { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   |   After alignment, map =  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   |   [isl_map_align_range_dims function]
|   |   |   |   |   Input map: { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   |   After alignment, map =  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   [name_unnamed_time_space_dimensions function]
|   |   |   End of function
|   |   |   Preparing to adjust the schedule of the computation conv
|   |   |   Original schedule:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Dimension level in which ordering dimensions will be inserted : 9
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 1
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 1
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 1
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n', o3, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, 0, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 3
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 3
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 3
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout', o5, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, 0, fout' = fout, i5, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 5
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 5
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 5
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y', o7, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, 0, y' = y, i7, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 7
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 7
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 0
|   |   |   |   Setting the constraint for dimension 7
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x', o9, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, 0, x' = x, i9, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   [isl_map_get_static_dim function]
|   |   |   |   Getting the constant coefficient of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 } at dimension 9
|   |   |   |   Dimensions found.  Constant = 0
|   |   |   |   The constant is: 0
|   |   |   [add_eq_to_schedule_map function]
|   |   |   |   The schedule : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   |   Editing the dimension 9
|   |   |   |   Coefficient of the input dimension 0
|   |   |   |   Coefficient of the output dimension -1
|   |   |   |   Coefficient of the constant 10
|   |   |   |   Setting the constraint for dimension 9
|   |   |   |   The identity schedule is now:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin', o11, k_y', o13, k_x', o15] }
|   |   |   |   The transformation map is:  { conv[i0, i1, n, i3, fout, i5, y, i7, x, i9, fin, i11, k_y, i13, k_x, i15] -> conv[i0, i1, n' = n, i3, fout' = fout, i5, y' = y, i7, x' = x, 10, fin' = fin, i11, k_y' = k_y, i13, k_x' = k_x, i15] }
|   |   |   |   The schedule after being transformed:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   |   Schedule adjusted:  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   [calculate_dep_flow function]
|   |    generating depandencies graph
|   |   [compute_dep_graph function]
|   |   |   Computing the dependences involving the computation bias.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Computing the dependences involving the computation src.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Computing the dependences involving the computation weights.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Computing the dependences involving the computation conv_init.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   Searching computation bias
|   |   |   |   |   Computation found.
|   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   Domain: { conv_init[n, fout, y, x] }
|   |   |   |   |   |   Range: { bias[fout] }
|   |   |   |   |   |   Transformation map: { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   |   Transformation map after adding equality constraints: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   |   Transformation map before adding constraints: { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   Looking for a dimension named fout in the domain of  { conv_init[n, fout, y, x] -> bias[fout'] }
|   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   After adding a constraint: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   |   Transformation function after adding constraints: { conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Accesses after filtering.
|   |   |   { bias[fout] -> conv_init[n, fout' = fout, y, x] }
|   |   |   Computing the dependences involving the computation conv.
|   |   |   Computing the accesses of the computation.
|   |   |   [get_rhs_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   Searching computation conv
|   |   |   |   |   |   Computation found.
|   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   Range: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   Looking for a dimension named n in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n', fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 0
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   Looking for a dimension named fout in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout', y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   Looking for a dimension named y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y', x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 2
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x', fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   Looking for a dimension named x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x', fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 3
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin', k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 4
|   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin', k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y', k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 5
|   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y', k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x'] }
|   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 6
|   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x'] }
|   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   Extracting access from e_op.
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   |   Searching computation src
|   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   |   Range: { src[n, fin, y_pad, x_pad] }
|   |   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   |   Looking for a dimension named n in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n', fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 0
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin', y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   |   Looking for a dimension named y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 2
|   |   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   |   Looking for a dimension named x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 3
|   |   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] }
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   |   |   Extracting access from o_access.
|   |   |   |   |   |   |   Searching computation weights
|   |   |   |   |   |   |   Computation found.
|   |   |   |   |   |   |   Obtained accessed computation.
|   |   |   |   |   |   |   [create_map_from_domain_and_range function]
|   |   |   |   |   |   |   |   Domain: { conv[n, fout, y, x, fin, k_y, k_x] }
|   |   |   |   |   |   |   |   Range: { weights[n, fout, y, x] }
|   |   |   |   |   |   |   |   Transformation map: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   |   Transformation map after adding equality constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = n, fout' = fout, y' = y, x' = x] }
|   |   |   |   |   |   |   Transformation map before adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 0
|   |   |   |   |   |   |   Looking for a dimension named fout in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n', fout', y', x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 1
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout', y', x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 1
|   |   |   |   |   |   |   Looking for a dimension named fin in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout', y', x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 4
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y', x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 2
|   |   |   |   |   |   |   Looking for a dimension named k_y in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y', x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 5
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x'] }
|   |   |   |   |   |   |   Assigning 1 to the coefficient of output dimension 3
|   |   |   |   |   |   |   Looking for a dimension named k_x in the domain of  { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x'] }
|   |   |   |   |   |   |   Dimension found. Assigning -1 to the input coefficient of dimension 6
|   |   |   |   |   |   |   After adding a constraint: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   |   Transformation function after adding constraints: { conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] }
|   |   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   |   [traverse_expr_and_extract_accesses function]
|   |   |   [get_rhs_accesses function]
|   |   |   Vector of accesses computed.
|   |   |   Accesses after filtering.
|   |   |   { src[n, fin, y_pad, x_pad] -> conv[n' = n, fout, y, x, fin' = fin, k_y = y_pad - y, k_x = x_pad - x]; weights[n, fout, y, x] -> conv[n', fout' = n, y', x', fin = fout, k_y = y, k_x = x]; conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x] }
|   |   |   Dep graph: 
|   |   |   { src[n, fin, y_pad, x_pad] -> conv[n' = n, fout, y, x, fin' = fin, k_y = y_pad - y, k_x = x_pad - x]; weights[n, fout, y, x] -> conv[n', fout' = n, y', x', fin = fout, k_y = y, k_x = x]; conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x]; bias[fout] -> conv_init[n, fout' = fout, y, x] }
|   |   End of function
|   |    the referencing union map is for dependecy analysis: { conv[n, fout, y, x, fin, k_y, k_x] -> src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x]; conv[n, fout, y, x, fin, k_y, k_x] -> weights[n' = fout, fout' = fin, y' = k_y, x' = k_x]; conv[n, fout, y, x, fin, k_y, k_x] -> conv[n' = n, fout' = fout, y' = y, x' = x, fin' = fin, k_y' = k_y, k_x' = k_x]; conv_init[n, fout, y, x] -> bias[fout' = fout] }
|   |    using to generate time stamp tmp map [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15]->[t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15]
|   |    - > computation's schedule  : { bias[t1] -> bias[0, 0, fout = t1, 0, t25 = 0, 0, t26 = 0, 0, t27 = 0, 0, t28 = 0, 0, t29 = 0, 0, t30 = 0, 0] : 0 <= t1 <= 1 }
|   |    - > computation's schedule to time stamp op result is : { bias[t1] -> [0, 0, t1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] : 0 <= t1 <= 1 }
|   |    - > computation's schedule  : { src[t3, t4, t5, t6] -> src[0, 0, n = t3, 0, fin = t4, 0, y_pad = t5, 0, x_pad = t6, 0, t31 = 0, 0, t32 = 0, 0, t33 = 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |    - > computation's schedule to time stamp op result is : { src[t3, t4, t5, t6] -> [0, 0, t3, 0, t4, 0, t5, 0, t6, 0, 0, 0, 0, 0, 0, 0] : 0 <= t3 <= 7 and 0 <= t4 <= 2 and 0 <= t5 <= 1023 and 0 <= t6 <= 1023 }
|   |    - > computation's schedule  : { weights[t8, t9, t10, t11] -> weights[0, 0, n = t8, 0, fout = t9, 0, y = t10, 0, x = t11, 0, t34 = 0, 0, t35 = 0, 0, t36 = 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |    - > computation's schedule to time stamp op result is : { weights[t8, t9, t10, t11] -> [0, 0, t8, 0, t9, 0, t10, 0, t11, 0, 0, 0, 0, 0, 0, 0] : 0 <= t8 <= 7 and 0 <= t9 <= 1 and 0 <= t10 <= 1023 and 0 <= t11 <= 1023 }
|   |    - > computation's schedule  : { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |    - > computation's schedule to time stamp op result is : { conv_init[t13, t14, t15, t16] -> [0, 0, t13, 0, t14, 0, t15, 0, t16, 0, 0, 0, 0, 0, 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   |    - > computation's schedule  : { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |    - > computation's schedule to time stamp op result is : { conv[t18, t19, t20, t21, t22, t23, t24] -> [0, 0, t18, 0, t19, 0, t20, 0, t21, 10, t22, 0, t23, 0, t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   the overall function schedule is : { conv_init[t13, t14, t15, t16] -> [0, 0, t13, 0, t14, 0, t15, 0, t16, 0, 0, 0, 0, 0, 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> [0, 0, t18, 0, t19, 0, t20, 0, t21, 10, t22, 0, t23, 0, t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |   the write access for computations is : { conv_init[n, fout, y, x] -> buf_output[n' = n, fout' = fout, y' = y, x' = x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023; conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   |    The read access for computations : { conv[n, fout, y, x, fin, k_y, k_x] -> buf_weights[n' = fout, fout' = fin, y' = k_y, x' = k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv[n, fout, y, x, fin, k_y, k_x] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv[n, fout, y, x, fin, k_y, k_x] -> buf_src[n' = n, fin' = fin, y_pad = y + k_y, x_pad = x + k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2; conv_init[n, fout, y, x] -> buf_bias[fout' = fout] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |    read after write True dependencies are in the form { last_write_access -> the read statement } : { conv_init[t13, t14, t15, t16] -> [conv[t18 = t13, t19 = t14, t20 = t15, t21 = t16, t22 = 0, t23 = 0, t24 = 0] -> buf_output[t13, t14, t15, t16]] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = t23, t24' = 1 + t24] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 1; conv[t18, t19, t20, t21, t22, t23, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = 1 + t23, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 1; conv[t18, t19, t20, t21, t22, t23 = 2, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = 1 + t22, t23' = 0, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 1 }
|   |    live-in : the computations / statement with these read access have not been written in this function (outside value)  : { conv[t18, t19, t20, t21, t22, t23, t24] -> buf_weights[n = t19, fout = t22, y = t23, x = t24] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2; conv_init[t13, t14, t15, t16] -> buf_bias[fout = t14] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> buf_src[n = t18, fin = t22, y_pad = t20 + t23, x_pad = t21 + t24] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   |    write after write dependencies are { last_previous_write -> new write stmt } : { conv_init[t13, t14, t15, t16] -> [conv[t18 = t13, t19 = t14, t20 = t15, t21 = t16, t22 = 0, t23 = 0, t24 = 0] -> buf_output[t13, t14, t15, t16]] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023; conv[t18, t19, t20, t21, t22, t23, t24] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = t23, t24' = 1 + t24] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 1; conv[t18, t19, t20, t21, t22, t23, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = t22, t23' = 1 + t23, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 1; conv[t18, t19, t20, t21, t22, t23 = 2, t24 = 2] -> [conv[t18' = t18, t19' = t19, t20' = t20, t21' = t21, t22' = 1 + t22, t23' = 0, t24' = 0] -> buf_output[t18, t19, t20, t21]] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 1 }
|   |    live out last access are : { conv[n, fout, y, x, fin = 2, k_y = 2, k_x = 2] -> buf_output[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   |    write after read anti_dependencies are in the form { last_previous_read -> new write stmt } : {  }
[get_bound function]
|   Getting the lower bound on the dimension 0 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 0 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  7
|   |   Extracted bound:7
|   The upper bound is : 7
[get_bound function]
|   Getting the lower bound on the dimension 1 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 1 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  1
|   |   |   Extracted bound:1
|   |   Extracted bound:1
|   The upper bound is : 1
[get_bound function]
|   Getting the lower bound on the dimension 2 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 2 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 3 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  conv_init(n, fout, y, x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 3 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  conv_init(n, fout, y, x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  1023
|   |   |   |   |   Extracted bound:1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 0 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 0 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  7
|   |   Extracted bound:7
|   The upper bound is : 7
[get_bound function]
|   Getting the lower bound on the dimension 1 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 1 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  1
|   |   |   Extracted bound:1
|   |   Extracted bound:1
|   The upper bound is : 1
[get_bound function]
|   Getting the lower bound on the dimension 2 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 2 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 3 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  conv_init(n, fout, y, x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 3 of the set  { conv_init[n, fout, y, x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        conv_init(n, fout, y, x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      conv_init(n, fout, y, x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    conv_init(n, fout, y, x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  conv_init(n, fout, y, x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  1023
|   |   |   |   |   Extracted bound:1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension fout
|   Searching in the range of  { conv_init[t13, t14, t15, t16] -> conv_init[0, 0, n = t13, 0, fout = t14, 0, y = t15, 0, x = t16, 0, t37 = 0, 0, t38 = 0, 0, t39 = 0, 0] : 0 <= t13 <= 7 and 0 <= t14 <= 1 and 0 <= t15 <= 1023 and 0 <= t16 <= 1023 }
|   Corresponding loop level is 1
|   Checking the validity of loop level 1
[get_bound function]
|   Getting the lower bound on the dimension 0 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 0 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  7
|   |   Extracted bound:7
|   The upper bound is : 7
[get_bound function]
|   Getting the lower bound on the dimension 1 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 1 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  1
|   |   |   Extracted bound:1
|   |   Extracted bound:1
|   The upper bound is : 1
[get_bound function]
|   Getting the lower bound on the dimension 2 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 2 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 3 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 3 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  1023
|   |   |   |   |   Extracted bound:1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 4 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 4
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 3
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   Input expression:  0
|   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 4 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 4
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 3
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   Input expression:  2
|   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   Extracted bound:2
|   |   |   |   Extracted bound:2
|   |   |   Extracted bound:2
|   |   Extracted bound:2
|   The upper bound is : 2
[get_bound function]
|   Getting the lower bound on the dimension 5 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 5
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 4
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   Input expression:  0
|   |   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 5 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 5
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 4
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   Input expression:  2
|   |   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   Extracted bound:2
|   |   |   |   Extracted bound:2
|   |   |   Extracted bound:2
|   |   Extracted bound:2
|   The upper bound is : 2
[get_bound function]
|   Getting the lower bound on the dimension 6 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 6
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 5
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 4
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   |   
for (int k_x = 0; k_x <= 2; k_x += 1)
  conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   |   Upper bound at this level is: k_x <= 2
|   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   Input expression:  0
|   |   |   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 6 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 6
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 5
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 4
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   |   
for (int k_x = 0; k_x <= 2; k_x += 1)
  conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   |   Upper bound at this level is: k_x <= 2
|   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   Input expression:  2
|   |   |   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   Extracted bound:2
|   |   |   |   Extracted bound:2
|   |   |   Extracted bound:2
|   |   Extracted bound:2
|   The upper bound is : 2
[get_bound function]
|   Getting the lower bound on the dimension 0 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 0 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 0
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   Input expression:  7
|   |   Extracted bound:7
|   The upper bound is : 7
[get_bound function]
|   Getting the lower bound on the dimension 1 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 1 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 1
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 0
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   Input expression:  1
|   |   |   Extracted bound:1
|   |   Extracted bound:1
|   The upper bound is : 1
[get_bound function]
|   Getting the lower bound on the dimension 2 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 2 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 2
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 1
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   Input expression:  1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 3 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 3 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 3
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 2
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   Input expression:  1023
|   |   |   |   |   Extracted bound:1023
|   |   |   |   Extracted bound:1023
|   |   |   Extracted bound:1023
|   |   Extracted bound:1023
|   The upper bound is : 1023
[get_bound function]
|   Getting the lower bound on the dimension 4 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 4
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 3
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   Input expression:  0
|   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 4 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 4
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 3
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   Input expression:  2
|   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   Extracted bound:2
|   |   |   |   Extracted bound:2
|   |   |   Extracted bound:2
|   |   Extracted bound:2
|   The upper bound is : 2
[get_bound function]
|   Getting the lower bound on the dimension 5 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 5
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 4
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   Input expression:  0
|   |   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 5 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 5
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 4
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   Input expression:  2
|   |   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   Extracted bound:2
|   |   |   |   Extracted bound:2
|   |   |   Extracted bound:2
|   |   Extracted bound:2
|   The upper bound is : 2
[get_bound function]
|   Getting the lower bound on the dimension 6 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 6
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 5
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 4
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   |   
for (int k_x = 0; k_x <= 2; k_x += 1)
  conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   |   Upper bound at this level is: k_x <= 2
|   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   Input expression:  0
|   |   |   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   |   Extracted bound:0
|   |   |   |   |   Extracted bound:0
|   |   |   |   Extracted bound:0
|   |   |   Extracted bound:0
|   |   Extracted bound:0
|   The lower bound is : 0
[get_bound function]
|   Getting the upper bound on the dimension 6 of the set  { conv[n, fout, y, x, fin, k_y, k_x] : 0 <= n <= 7 and 0 <= fout <= 1 and 0 <= y <= 1023 and 0 <= x <= 1023 and 0 <= fin <= 2 and 0 <= k_y <= 2 and 0 <= k_x <= 2 }
|   Setting ISL AST generator options.
|   Generating time-space domain.
|   Setting the iterator names.
|   [extract_bound_expression function]
|   |   Extracting bounds from a loop at depth = 6
|   |   Extracting bounds from the following ISL AST node 
|   |   
for (int n = 0; n <= 7; n += 1)
  for (int fout = 0; fout <= 1; fout += 1)
    for (int y = 0; y <= 1023; y += 1)
      for (int x = 0; x <= 1023; x += 1)
        for (int fin = 0; fin <= 2; fin += 1)
          for (int k_y = 0; k_y <= 2; k_y += 1)
            for (int k_x = 0; k_x <= 2; k_x += 1)
              conv(n, fout, y, x, fin, k_y, k_x);

|   |   Extracting bounds from a for loop.
|   |   Lower bound at this level is: 0
|   |   Upper bound at this level is: n <= 7
|   |   [extract_bound_expression function]
|   |   |   Extracting bounds from a loop at depth = 5
|   |   |   Extracting bounds from the following ISL AST node 
|   |   |   
for (int fout = 0; fout <= 1; fout += 1)
  for (int y = 0; y <= 1023; y += 1)
    for (int x = 0; x <= 1023; x += 1)
      for (int fin = 0; fin <= 2; fin += 1)
        for (int k_y = 0; k_y <= 2; k_y += 1)
          for (int k_x = 0; k_x <= 2; k_x += 1)
            conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   Extracting bounds from a for loop.
|   |   |   Lower bound at this level is: 0
|   |   |   Upper bound at this level is: fout <= 1
|   |   |   [extract_bound_expression function]
|   |   |   |   Extracting bounds from a loop at depth = 4
|   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   
for (int y = 0; y <= 1023; y += 1)
  for (int x = 0; x <= 1023; x += 1)
    for (int fin = 0; fin <= 2; fin += 1)
      for (int k_y = 0; k_y <= 2; k_y += 1)
        for (int k_x = 0; k_x <= 2; k_x += 1)
          conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   Extracting bounds from a for loop.
|   |   |   |   Lower bound at this level is: 0
|   |   |   |   Upper bound at this level is: y <= 1023
|   |   |   |   [extract_bound_expression function]
|   |   |   |   |   Extracting bounds from a loop at depth = 3
|   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   
for (int x = 0; x <= 1023; x += 1)
  for (int fin = 0; fin <= 2; fin += 1)
    for (int k_y = 0; k_y <= 2; k_y += 1)
      for (int k_x = 0; k_x <= 2; k_x += 1)
        conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   Upper bound at this level is: x <= 1023
|   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   Extracting bounds from a loop at depth = 2
|   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   
for (int fin = 0; fin <= 2; fin += 1)
  for (int k_y = 0; k_y <= 2; k_y += 1)
    for (int k_x = 0; k_x <= 2; k_x += 1)
      conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   Upper bound at this level is: fin <= 2
|   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   Extracting bounds from a loop at depth = 1
|   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   
for (int k_y = 0; k_y <= 2; k_y += 1)
  for (int k_x = 0; k_x <= 2; k_x += 1)
    conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   Upper bound at this level is: k_y <= 2
|   |   |   |   |   |   |   [extract_bound_expression function]
|   |   |   |   |   |   |   |   Extracting bounds from a loop at depth = 0
|   |   |   |   |   |   |   |   Extracting bounds from the following ISL AST node 
|   |   |   |   |   |   |   |   
for (int k_x = 0; k_x <= 2; k_x += 1)
  conv(n, fout, y, x, fin, k_y, k_x);

|   |   |   |   |   |   |   |   Extracting bounds from a for loop.
|   |   |   |   |   |   |   |   Lower bound at this level is: 0
|   |   |   |   |   |   |   |   Upper bound at this level is: k_x <= 2
|   |   |   |   |   |   |   |   [tiramisu_expr_from_isl_ast_expr function]
|   |   |   |   |   |   |   |   |   Input expression:  2
|   |   |   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   |   Extracted bound:2
|   |   |   |   |   Extracted bound:2
|   |   |   |   Extracted bound:2
|   |   |   Extracted bound:2
|   |   Extracted bound:2
|   The upper bound is : 2
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension n
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 0
|   Checking the validity of loop level 0
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension fout
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 1
|   Checking the validity of loop level 1
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension y
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 2
|   Checking the validity of loop level 2
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension x
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 3
|   Checking the validity of loop level 3
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension fin
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 4
|   Checking the validity of loop level 4
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension k_y
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 5
|   Checking the validity of loop level 5
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension k_x
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 6
|   Checking the validity of loop level 6
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension n
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 0
|   Checking the validity of loop level 0
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension fin
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 4
|   Checking the validity of loop level 4
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension y
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 2
|   Checking the validity of loop level 2
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension k_y
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 5
|   Checking the validity of loop level 5
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension x
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 3
|   Checking the validity of loop level 3
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension k_x
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 6
|   Checking the validity of loop level 6
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension fout
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 1
|   Checking the validity of loop level 1
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension fin
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 4
|   Checking the validity of loop level 4
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension k_y
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 5
|   Checking the validity of loop level 5
[get_loop_level_numbers_from_dimension_names function]
|   Searching for the dimension k_x
|   Searching in the range of  { conv[t18, t19, t20, t21, t22, t23, t24] -> conv[0, 0, n = t18, 0, fout = t19, 0, y = t20, 0, x = t21, 10, fin = t22, 0, k_y = t23, 0, k_x = t24, 0] : 0 <= t18 <= 7 and 0 <= t19 <= 1 and 0 <= t20 <= 1023 and 0 <= t21 <= 1023 and 0 <= t22 <= 2 and 0 <= t23 <= 2 and 0 <= t24 <= 2 }
|   Corresponding loop level is 6
|   Checking the validity of loop level 6
