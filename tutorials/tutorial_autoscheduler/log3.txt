
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}
 vars c y x  interchange : c & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 1, 1022) {
    for (c3, 0, 3) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L1
0- for 1 <= y < 1023 | 0
	1- for 0 <= c < 3 | 0
		2- for 1 <= x < 1023 | 0
			blur
Evaluation : 5.309340

{ blur[t5, t6, t7] -> blur[0, t8 = 0, y = t6, t9 = 0, c = t5, t10 = 0, x = t7, t11 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 vars c y x  interchange : c & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 1, 1022) {
    for (c3, 1, 1022) {
      for (c5, 0, 3) {
        output_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))] + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L2
0- for 1 <= x < 1023 | 0
	1- for 1 <= y < 1023 | 0
		2- for 0 <= c < 3 | 0
			blur
Evaluation : 91.293098

{ blur[t5, t6, t7] -> blur[0, t17 = 0, x = t7, t18 = 0, y = t6, t19 = 0, c = t5, t20 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 vars c y x  interchange : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L1  L2
0- for 0 <= c < 3 | 0
	1- for 1 <= x < 1023 | 0
		2- for 1 <= y < 1023 | 0
			blur
Evaluation : 72.276100

{ blur[t5, t6, t7] -> blur[0, t26 = 0, c = t5, t27 = 0, x = t7, t28 = 0, y = t6, t29 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
5.309340+91.293098+72.276100+5.294440+
remaining list
5.294440+5.309340+72.276100+91.293098+
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Parallelize L0
0- for 0 <= c < 3 | 0 | P
	1- for 1 <= y < 1023 | 0
		2- for 1 <= x < 1023 | 0
			blur
Evaluation : 4.250880

{ blur[t5, t6, t7] -> blur[0, 0, c = t5, 0, y = t6, 0, x = t7, 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Parallelize L1
0- for 0 <= c < 3 | 0
	1- for 1 <= y < 1023 | 0 | P
		2- for 1 <= x < 1023 | 0
			blur
Evaluation : 4.271980

{ blur[t5, t6, t7] -> blur[0, 0, c = t5, 0, y = t6, 0, x = t7, 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 1, 1022) {
      parallel (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Parallelize L2
0- for 0 <= c < 3 | 0
	1- for 1 <= y < 1023 | 0
		2- for 1 <= x < 1023 | 0 | P
			blur
Evaluation : 404.700012

{ blur[t5, t6, t7] -> blur[0, 0, c = t5, 0, y = t6, 0, x = t7, 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
4.250880+4.271980+404.700012+5.294440+
remaining list
4.250880+4.271980+5.294440+404.700012+ Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 6.127480

{ blur[t5, t6, t7] -> blur[0, t53 = 0, c = t5, t55 = 0, y_outer, t57 = 0, x_outer, t59 = 0, y_inner, t50 = 0, x_inner, t61 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 5.776050

{ blur[t5, t6, t7] -> blur[0, t105 = 0, c = t5, t107 = 0, y_outer, t109 = 0, x_outer, t111 = 0, y_inner, t102 = 0, x_inner, t113 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 4.826550

{ blur[t5, t6, t7] -> blur[0, t157 = 0, c = t5, t159 = 0, y_outer, t161 = 0, x_outer, t163 = 0, y_inner, t154 = 0, x_inner, t165 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 6.491420

{ blur[t5, t6, t7] -> blur[0, t209 = 0, c = t5, t211 = 0, y_outer, t213 = 0, x_outer, t215 = 0, y_inner, t206 = 0, x_inner, t217 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 5.794530

{ blur[t5, t6, t7] -> blur[0, t261 = 0, c = t5, t263 = 0, y_outer, t265 = 0, x_outer, t267 = 0, y_inner, t258 = 0, x_inner, t269 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 4.912970

{ blur[t5, t6, t7] -> blur[0, t313 = 0, c = t5, t315 = 0, y_outer, t317 = 0, x_outer, t319 = 0, y_inner, t310 = 0, x_inner, t321 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 6.430980

{ blur[t5, t6, t7] -> blur[0, t365 = 0, c = t5, t367 = 0, y_outer, t369 = 0, x_outer, t371 = 0, y_inner, t362 = 0, x_inner, t373 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 5.816580

{ blur[t5, t6, t7] -> blur[0, t417 = 0, c = t5, t419 = 0, y_outer, t421 = 0, x_outer, t423 = 0, y_inner, t414 = 0, x_inner, t425 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 5.686880

{ blur[t5, t6, t7] -> blur[0, t469 = 0, c = t5, t471 = 0, y_outer, t473 = 0, x_outer, t475 = 0, y_inner, t466 = 0, x_inner, t477 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
6.127480+5.776050+4.826550+6.491420+5.794530+4.912970+6.430980+5.816580+5.686880+4.250880+
remaining list
4.250880+4.826550+4.912970+5.686880+ Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0 | P
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 5.671500

{ blur[t5, t6, t7] -> blur[0, t521 = 0, c = t5, t523 = 0, y_outer, t525 = 0, x_outer, t527 = 0, y_inner, t518 = 0, x_inner, t529 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0 | P
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 5.200510

{ blur[t5, t6, t7] -> blur[0, t573 = 0, c = t5, t575 = 0, y_outer, t577 = 0, x_outer, t579 = 0, y_inner, t570 = 0, x_inner, t581 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0 | P
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 4.724980

{ blur[t5, t6, t7] -> blur[0, t625 = 0, c = t5, t627 = 0, y_outer, t629 = 0, x_outer, t631 = 0, y_inner, t622 = 0, x_inner, t633 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0 | P
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 5.939480

{ blur[t5, t6, t7] -> blur[0, t677 = 0, c = t5, t679 = 0, y_outer, t681 = 0, x_outer, t683 = 0, y_inner, t674 = 0, x_inner, t685 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0 | P
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 5.469440

{ blur[t5, t6, t7] -> blur[0, t729 = 0, c = t5, t731 = 0, y_outer, t733 = 0, x_outer, t735 = 0, y_inner, t726 = 0, x_inner, t737 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0 | P
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 4.815460

{ blur[t5, t6, t7] -> blur[0, t781 = 0, c = t5, t783 = 0, y_outer, t785 = 0, x_outer, t787 = 0, y_inner, t778 = 0, x_inner, t789 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0 | P
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 6.329060

{ blur[t5, t6, t7] -> blur[0, t833 = 0, c = t5, t835 = 0, y_outer, t837 = 0, x_outer, t839 = 0, y_inner, t830 = 0, x_inner, t841 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0 | P
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 5.843040

{ blur[t5, t6, t7] -> blur[0, t885 = 0, c = t5, t887 = 0, y_outer, t889 = 0, x_outer, t891 = 0, y_inner, t882 = 0, x_inner, t893 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0 | P
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 5.663040

{ blur[t5, t6, t7] -> blur[0, t937 = 0, c = t5, t939 = 0, y_outer, t941 = 0, x_outer, t943 = 0, y_inner, t934 = 0, x_inner, t945 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
5.671500+5.200510+4.724980+5.939480+5.469440+4.815460+6.329060+5.843040+5.663040+4.271980+
remaining list
4.271980+4.724980+4.815460+5.200510+ Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 16.217501

{ blur[t5, t6, t7] -> blur[0, t989 = 0, c = t5, t991 = 0, y_outer, t993 = 0, x_outer, t995 = 0, y_inner, t986 = 0, x_inner, t997 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 15.041900

{ blur[t5, t6, t7] -> blur[0, t1040 = 0, c = t5, t1042 = 0, y_outer, t1044 = 0, x_outer, t1046 = 0, y_inner, t1037 = 0, x_inner, t1048 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 12.443900

{ blur[t5, t6, t7] -> blur[0, t1091 = 0, c = t5, t1093 = 0, y_outer, t1095 = 0, x_outer, t1097 = 0, y_inner, t1088 = 0, x_inner, t1099 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 17.879601

{ blur[t5, t6, t7] -> blur[0, t1142 = 0, c = t5, t1144 = 0, y_outer, t1146 = 0, x_outer, t1148 = 0, y_inner, t1139 = 0, x_inner, t1150 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 14.797600

{ blur[t5, t6, t7] -> blur[0, t1193 = 0, c = t5, t1195 = 0, y_outer, t1197 = 0, x_outer, t1199 = 0, y_inner, t1190 = 0, x_inner, t1201 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 13.317900

{ blur[t5, t6, t7] -> blur[0, t1244 = 0, c = t5, t1246 = 0, y_outer, t1248 = 0, x_outer, t1250 = 0, y_inner, t1241 = 0, x_inner, t1252 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 31 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 18.476500

{ blur[t5, t6, t7] -> blur[0, t1295 = 0, c = t5, t1297 = 0, y_outer, t1299 = 0, x_outer, t1301 = 0, y_inner, t1292 = 0, x_inner, t1303 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 15 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 16.655399

{ blur[t5, t6, t7] -> blur[0, t1346 = 0, c = t5, t1348 = 0, y_outer, t1350 = 0, x_outer, t1352 = 0, y_inner, t1343 = 0, x_inner, t1354 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 7 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 12.917400

{ blur[t5, t6, t7] -> blur[0, t1397 = 0, c = t5, t1399 = 0, y_outer, t1401 = 0, x_outer, t1403 = 0, y_inner, t1394 = 0, x_inner, t1405 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
16.217501+15.041900+12.443900+17.879601+14.797600+13.317900+18.476500+16.655399+12.917400+5.294440+
remaining list
5.294440+12.443900+12.917400+13.317900+ Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 31 | 0 | P
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 7.972480

{ blur[t5, t6, t7] -> blur[0, t1448 = 0, c = t5, t1450 = 0, y_outer, t1452 = 0, x_outer, t1454 = 0, y_inner, t1445 = 0, x_inner, t1456 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 15 | 0 | P
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 7.589340

{ blur[t5, t6, t7] -> blur[0, t1500 = 0, c = t5, t1502 = 0, y_outer, t1504 = 0, x_outer, t1506 = 0, y_inner, t1497 = 0, x_inner, t1508 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_outer < 7 | 0 | P
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 6.261470

{ blur[t5, t6, t7] -> blur[0, t1552 = 0, c = t5, t1554 = 0, y_outer, t1556 = 0, x_outer, t1558 = 0, y_inner, t1549 = 0, x_inner, t1560 = 0] : (t6 - y_inner) mod 32 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t6 <= 32y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 31 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 31 | 0 | P
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 19.315500

{ blur[t5, t6, t7] -> blur[0, t1604 = 0, c = t5, t1606 = 0, y_outer, t1608 = 0, x_outer, t1610 = 0, y_inner, t1601 = 0, x_inner, t1612 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 15 | 0 | P
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 8.870600

{ blur[t5, t6, t7] -> blur[0, t1656 = 0, c = t5, t1658 = 0, y_outer, t1660 = 0, x_outer, t1662 = 0, y_inner, t1653 = 0, x_inner, t1664 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_outer < 7 | 0 | P
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 6.116510

{ blur[t5, t6, t7] -> blur[0, t1708 = 0, c = t5, t1710 = 0, y_outer, t1712 = 0, x_outer, t1714 = 0, y_inner, t1705 = 0, x_inner, t1716 = 0] : (t6 - y_inner) mod 64 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t6 <= 64y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 63 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*32) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*32) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 31 | 0 | P
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 32 | 0
					blur
Evaluation : 6.713990

{ blur[t5, t6, t7] -> blur[0, t1760 = 0, c = t5, t1762 = 0, y_outer, t1764 = 0, x_outer, t1766 = 0, y_inner, t1757 = 0, x_inner, t1768 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -31 + t7 <= 32x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*64) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*64) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 15 | 0 | P
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 64 | 0
					blur
Evaluation : 17.832600

{ blur[t5, t6, t7] -> blur[0, t1812 = 0, c = t5, t1814 = 0, y_outer, t1816 = 0, x_outer, t1818 = 0, y_inner, t1809 = 0, x_inner, t1820 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -63 + t7 <= 64x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c y x  deapth of outer is:1 test : y & x
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c5*128) + c9) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c5*128) + c9)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_outer < 7 | 0 | P
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= x_inner < 128 | 0
					blur
Evaluation : 5.450610

{ blur[t5, t6, t7] -> blur[0, t1864 = 0, c = t5, t1866 = 0, y_outer, t1868 = 0, x_outer, t1870 = 0, y_inner, t1861 = 0, x_inner, t1872 = 0] : (t6 - y_inner) mod 128 = 0 and (-t7 + x_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t6 <= 128y_outer <= t6 and -127 + t7 <= 128x_outer <= t7 and 0 <= y_inner <= 127 and 0 <= x_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
7.972480+7.589340+6.261470+19.315500+8.870600+6.116510+6.713990+17.832600+5.450610+404.700012+
remaining list
5.450610+6.116510+6.261470+6.713990+
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 1, 1022) {
    for (c3, 0, 3) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L0
0- for 1 <= y < 1023 | 0 | P
	1- for 0 <= c < 3 | 0
		2- for 1 <= x < 1023 | 0
			blur
Evaluation : 5.368470

{ blur[t5, t6, t7] -> blur[0, t8 = 0, y = t6, t9 = 0, c = t5, t10 = 0, x = t7, t11 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 1, 1022) {
    parallel (c3, 0, 3) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L1
0- for 1 <= y < 1023 | 0
	1- for 0 <= c < 3 | 0 | P
		2- for 1 <= x < 1023 | 0
			blur
Evaluation : 11.718500

{ blur[t5, t6, t7] -> blur[0, t8 = 0, y = t6, t9 = 0, c = t5, t10 = 0, x = t7, t11 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 1, 1022) {
    for (c3, 0, 3) {
      parallel (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c1)*(int64)1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c1)*(int64)1024) + (int64)-1024))) + int32((int64(c3)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L1
Parallelize L2
0- for 1 <= y < 1023 | 0
	1- for 0 <= c < 3 | 0
		2- for 1 <= x < 1023 | 0 | P
			blur
Evaluation : 394.152008

{ blur[t5, t6, t7] -> blur[0, t8 = 0, y = t6, t9 = 0, c = t5, t10 = 0, x = t7, t11 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
5.368470+11.718500+394.152008+5.309340+
remaining list
5.309340+5.368470+11.718500+394.152008+
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
0- for 0 <= c < 3 | 0 | P
	1- for 1 <= x < 1023 | 0
		2- for 1 <= y < 1023 | 0
			blur
Evaluation : 38.395500

{ blur[t5, t6, t7] -> blur[0, t26 = 0, c = t5, t27 = 0, x = t7, t28 = 0, y = t6, t29 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
0- for 0 <= c < 3 | 0
	1- for 1 <= x < 1023 | 0 | P
		2- for 1 <= y < 1023 | 0
			blur
Evaluation : 19.702999

{ blur[t5, t6, t7] -> blur[0, t26 = 0, c = t5, t27 = 0, x = t7, t28 = 0, y = t6, t29 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 1, 1022) {
      parallel (c5, 1, 1022) {
        output_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32((int64(c5)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)-1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c3 + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c3) + (int64)1)) + int32(((int64(c5)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
0- for 0 <= c < 3 | 0
	1- for 1 <= x < 1023 | 0
		2- for 1 <= y < 1023 | 0 | P
			blur
Evaluation : 531.749023

{ blur[t5, t6, t7] -> blur[0, t26 = 0, c = t5, t27 = 0, x = t7, t28 = 0, y = t6, t29 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
38.395500+19.702999+531.749023+72.276100+
remaining list
19.702999+38.395500+72.276100+531.749023+ Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0 | P
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 9.957430

{ blur[t5, t6, t7] -> blur[0, t1952 = 0, c = t5, t1954 = 0, x_outer, t1956 = 0, y_outer, t1958 = 0, x_inner, t1949 = 0, y_inner, t1960 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0 | P
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 10.707000

{ blur[t5, t6, t7] -> blur[0, t2009 = 0, c = t5, t2011 = 0, x_outer, t2013 = 0, y_outer, t2015 = 0, x_inner, t2006 = 0, y_inner, t2017 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0 | P
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 16.222500

{ blur[t5, t6, t7] -> blur[0, t2066 = 0, c = t5, t2068 = 0, x_outer, t2070 = 0, y_outer, t2072 = 0, x_inner, t2063 = 0, y_inner, t2074 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0 | P
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 9.540560

{ blur[t5, t6, t7] -> blur[0, t2123 = 0, c = t5, t2125 = 0, x_outer, t2127 = 0, y_outer, t2129 = 0, x_inner, t2120 = 0, y_inner, t2131 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0 | P
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 10.853500

{ blur[t5, t6, t7] -> blur[0, t2180 = 0, c = t5, t2182 = 0, x_outer, t2184 = 0, y_outer, t2186 = 0, x_inner, t2177 = 0, y_inner, t2188 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0 | P
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 14.977600

{ blur[t5, t6, t7] -> blur[0, t2237 = 0, c = t5, t2239 = 0, x_outer, t2241 = 0, y_outer, t2243 = 0, x_inner, t2234 = 0, y_inner, t2245 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0 | P
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 9.698510

{ blur[t5, t6, t7] -> blur[0, t2294 = 0, c = t5, t2296 = 0, x_outer, t2298 = 0, y_outer, t2300 = 0, x_inner, t2291 = 0, y_inner, t2302 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0 | P
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 10.767900

{ blur[t5, t6, t7] -> blur[0, t2351 = 0, c = t5, t2353 = 0, x_outer, t2355 = 0, y_outer, t2357 = 0, x_inner, t2348 = 0, y_inner, t2359 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L1
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0 | P
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 10.539100

{ blur[t5, t6, t7] -> blur[0, t2408 = 0, c = t5, t2410 = 0, x_outer, t2412 = 0, y_outer, t2414 = 0, x_inner, t2405 = 0, y_inner, t2416 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
9.957430+10.707000+16.222500+9.540560+10.853500+14.977600+9.698510+10.767900+10.539100+19.702999+
remaining list
9.540560+9.698510+9.957430+10.539100+ Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 12.944500

{ blur[t5, t6, t7] -> blur[0, t2465 = 0, c = t5, t2467 = 0, x_outer, t2469 = 0, y_outer, t2471 = 0, x_inner, t2462 = 0, y_inner, t2473 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 13.390700

{ blur[t5, t6, t7] -> blur[0, t2522 = 0, c = t5, t2524 = 0, x_outer, t2526 = 0, y_outer, t2528 = 0, x_inner, t2519 = 0, y_inner, t2530 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 12.671100

{ blur[t5, t6, t7] -> blur[0, t2579 = 0, c = t5, t2581 = 0, x_outer, t2583 = 0, y_outer, t2585 = 0, x_inner, t2576 = 0, y_inner, t2587 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 13.204600

{ blur[t5, t6, t7] -> blur[0, t2636 = 0, c = t5, t2638 = 0, x_outer, t2640 = 0, y_outer, t2642 = 0, x_inner, t2633 = 0, y_inner, t2644 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 11.598500

{ blur[t5, t6, t7] -> blur[0, t2693 = 0, c = t5, t2695 = 0, x_outer, t2697 = 0, y_outer, t2699 = 0, x_inner, t2690 = 0, y_inner, t2701 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 12.581900

{ blur[t5, t6, t7] -> blur[0, t2750 = 0, c = t5, t2752 = 0, x_outer, t2754 = 0, y_outer, t2756 = 0, x_inner, t2747 = 0, y_inner, t2758 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 11.453000

{ blur[t5, t6, t7] -> blur[0, t2807 = 0, c = t5, t2809 = 0, x_outer, t2811 = 0, y_outer, t2813 = 0, x_inner, t2804 = 0, y_inner, t2815 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 13.131400

{ blur[t5, t6, t7] -> blur[0, t2864 = 0, c = t5, t2866 = 0, x_outer, t2868 = 0, y_outer, t2870 = 0, x_inner, t2861 = 0, y_inner, t2872 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L0
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0 | P
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 12.460900

{ blur[t5, t6, t7] -> blur[0, t2921 = 0, c = t5, t2923 = 0, x_outer, t2925 = 0, y_outer, t2927 = 0, x_inner, t2918 = 0, y_inner, t2929 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
12.944500+13.390700+12.671100+13.204600+11.598500+12.581900+11.453000+13.131400+12.460900+38.395500+
remaining list
11.453000+11.598500+12.460900+12.581900+ Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 30.811899

{ blur[t5, t6, t7] -> blur[0, t2978 = 0, c = t5, t2980 = 0, x_outer, t2982 = 0, y_outer, t2984 = 0, x_inner, t2975 = 0, y_inner, t2986 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 32.879002

{ blur[t5, t6, t7] -> blur[0, t3034 = 0, c = t5, t3036 = 0, x_outer, t3038 = 0, y_outer, t3040 = 0, x_inner, t3031 = 0, y_inner, t3042 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 33.896400

{ blur[t5, t6, t7] -> blur[0, t3090 = 0, c = t5, t3092 = 0, x_outer, t3094 = 0, y_outer, t3096 = 0, x_inner, t3087 = 0, y_inner, t3098 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 29.935499

{ blur[t5, t6, t7] -> blur[0, t3146 = 0, c = t5, t3148 = 0, x_outer, t3150 = 0, y_outer, t3152 = 0, x_inner, t3143 = 0, y_inner, t3154 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 32.359501

{ blur[t5, t6, t7] -> blur[0, t3202 = 0, c = t5, t3204 = 0, x_outer, t3206 = 0, y_outer, t3208 = 0, x_inner, t3199 = 0, y_inner, t3210 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 33.356899

{ blur[t5, t6, t7] -> blur[0, t3258 = 0, c = t5, t3260 = 0, x_outer, t3262 = 0, y_outer, t3264 = 0, x_inner, t3255 = 0, y_inner, t3266 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 31 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 32.694302

{ blur[t5, t6, t7] -> blur[0, t3314 = 0, c = t5, t3316 = 0, x_outer, t3318 = 0, y_outer, t3320 = 0, x_inner, t3311 = 0, y_inner, t3322 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 15 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 33.232601

{ blur[t5, t6, t7] -> blur[0, t3370 = 0, c = t5, t3372 = 0, x_outer, t3374 = 0, y_outer, t3376 = 0, x_inner, t3367 = 0, y_inner, t3378 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 7 | 0
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 32.452499

{ blur[t5, t6, t7] -> blur[0, t3426 = 0, c = t5, t3428 = 0, x_outer, t3430 = 0, y_outer, t3432 = 0, x_inner, t3423 = 0, y_inner, t3434 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
30.811899+32.879002+33.896400+29.935499+32.359501+33.356899+32.694302+33.232601+32.452499+72.276100+
remaining list
29.935499+30.811899+32.359501+32.452499+ Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 32) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 32 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 31 | 0 | P
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 11.007500

{ blur[t5, t6, t7] -> blur[0, t3482 = 0, c = t5, t3484 = 0, x_outer, t3486 = 0, y_outer, t3488 = 0, x_inner, t3479 = 0, y_inner, t3490 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 16) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 32 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 15 | 0 | P
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 13.040100

{ blur[t5, t6, t7] -> blur[0, t3539 = 0, c = t5, t3541 = 0, x_outer, t3543 = 0, y_outer, t3545 = 0, x_inner, t3536 = 0, y_inner, t3547 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 32) {
      parallel (c5, 0, 8) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*32) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*32) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 32 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 31 | 0
		2- for 0 <= y_outer < 7 | 0 | P
			3- for 0 <= x_inner < 32 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 14.325400

{ blur[t5, t6, t7] -> blur[0, t3596 = 0, c = t5, t3598 = 0, x_outer, t3600 = 0, y_outer, t3602 = 0, x_inner, t3593 = 0, y_inner, t3604 = 0] : (-t7 + x_inner) mod 32 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 32) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 31 | 0 | P
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 12.415100

{ blur[t5, t6, t7] -> blur[0, t3653 = 0, c = t5, t3655 = 0, x_outer, t3657 = 0, y_outer, t3659 = 0, x_inner, t3650 = 0, y_inner, t3661 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 16) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 15 | 0 | P
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 12.503500

{ blur[t5, t6, t7] -> blur[0, t3710 = 0, c = t5, t3712 = 0, x_outer, t3714 = 0, y_outer, t3716 = 0, x_inner, t3707 = 0, y_inner, t3718 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 16) {
      parallel (c5, 0, 8) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*64) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*64) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 64 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 15 | 0
		2- for 0 <= y_outer < 7 | 0 | P
			3- for 0 <= x_inner < 64 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 14.411900

{ blur[t5, t6, t7] -> blur[0, t3767 = 0, c = t5, t3769 = 0, x_outer, t3771 = 0, y_outer, t3773 = 0, x_inner, t3764 = 0, y_inner, t3775 = 0] : (-t7 + x_inner) mod 64 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*32), 1)), ((min((c5*32), 1) - max((c5*32), 991)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*32) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*32) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 32
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 31 | 0 | P
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 32 | 0
					blur
Evaluation : 9.653570

{ blur[t5, t6, t7] -> blur[0, t3824 = 0, c = t5, t3826 = 0, x_outer, t3828 = 0, y_outer, t3830 = 0, x_inner, t3821 = 0, y_inner, t3832 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 16) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*64), 1)), ((min((c5*64), 1) - max((c5*64), 959)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*64) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*64) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 64
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 15 | 0 | P
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 64 | 0
					blur
Evaluation : 10.176400

{ blur[t5, t6, t7] -> blur[0, t3881 = 0, c = t5, t3883 = 0, x_outer, t3885 = 0, y_outer, t3887 = 0, x_inner, t3878 = 0, y_inner, t3889 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: c x y  deapth of outer is:1 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 3) {
    for (c3, 0, 8) {
      parallel (c5, 0, 8) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, (1 - min((c5*128), 1)), ((min((c5*128), 1) - max((c5*128), 895)) + 1022)) {
            output_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32((int64(((c5*128) + c9))*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)-1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((((c3*128) + c7) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(((c3*128) + c7)) + (int64)1)) + int32(((int64(((c5*128) + c9))*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L1  L2
Parallelize L2
Tiling L1 128 L2 128
0- for 0 <= c < 3 | 0
	1- for 0 <= x_outer < 7 | 0
		2- for 0 <= y_outer < 7 | 0 | P
			3- for 0 <= x_inner < 128 | 0
				4- for 0 <= y_inner < 128 | 0
					blur
Evaluation : 13.100000

{ blur[t5, t6, t7] -> blur[0, t3938 = 0, c = t5, t3940 = 0, x_outer, t3942 = 0, y_outer, t3944 = 0, x_inner, t3935 = 0, y_inner, t3946 = 0] : (-t7 + x_inner) mod 128 = 0 and (-t6 + y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
11.007500+13.040100+14.325400+12.415100+12.503500+14.411900+9.653570+10.176400+13.100000+531.749023+
remaining list
9.653570+10.176400+11.007500+12.415100+
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 1, 1022) {
    for (c3, 1, 1022) {
      for (c5, 0, 3) {
        output_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))] + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
0- for 1 <= x < 1023 | 0 | P
	1- for 1 <= y < 1023 | 0
		2- for 0 <= c < 3 | 0
			blur
Evaluation : 22.451500

{ blur[t5, t6, t7] -> blur[0, t17 = 0, x = t7, t18 = 0, y = t6, t19 = 0, c = t5, t20 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 1, 1022) {
    parallel (c3, 1, 1022) {
      for (c5, 0, 3) {
        output_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))] + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
0- for 1 <= x < 1023 | 0
	1- for 1 <= y < 1023 | 0 | P
		2- for 0 <= c < 3 | 0
			blur
Evaluation : 249.703995

{ blur[t5, t6, t7] -> blur[0, t17 = 0, x = t7, t18 = 0, y = t6, t19 = 0, c = t5, t20 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 1, 1022) {
    for (c3, 1, 1022) {
      parallel (c5, 0, 3) {
        output_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))] + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((c1 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))]) + input_buf[((int32((int64(c1) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c5)*(int64)1048576)))])*0.111111)
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
0- for 1 <= x < 1023 | 0
	1- for 1 <= y < 1023 | 0
		2- for 0 <= c < 3 | 0 | P
			blur
Evaluation : 5186.029785

{ blur[t5, t6, t7] -> blur[0, t17 = 0, x = t7, t18 = 0, y = t6, t19 = 0, c = t5, t20 = 0] : 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 }


input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
22.451500+249.703995+5186.029785+91.293098+
remaining list
22.451500+91.293098+249.703995+5186.029785+ Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= x_outer < 31 | 0 | P
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 10.864500

{ blur[t5, t6, t7] -> blur[0, t4013 = 0, x_outer, t4015 = 0, y_outer, t4017 = 0, x_inner, t4010 = 0, y_inner, t4019 = 0, c = t5, t4021 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= x_outer < 31 | 0 | P
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 18.364300

{ blur[t5, t6, t7] -> blur[0, t4070 = 0, x_outer, t4072 = 0, y_outer, t4074 = 0, x_inner, t4067 = 0, y_inner, t4076 = 0, c = t5, t4078 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= x_outer < 31 | 0 | P
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 13.985000

{ blur[t5, t6, t7] -> blur[0, t4127 = 0, x_outer, t4129 = 0, y_outer, t4131 = 0, x_inner, t4124 = 0, y_inner, t4133 = 0, c = t5, t4135 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= x_outer < 15 | 0 | P
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 11.673500

{ blur[t5, t6, t7] -> blur[0, t4184 = 0, x_outer, t4186 = 0, y_outer, t4188 = 0, x_inner, t4181 = 0, y_inner, t4190 = 0, c = t5, t4192 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= x_outer < 15 | 0 | P
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 13.960000

{ blur[t5, t6, t7] -> blur[0, t4241 = 0, x_outer, t4243 = 0, y_outer, t4245 = 0, x_inner, t4238 = 0, y_inner, t4247 = 0, c = t5, t4249 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= x_outer < 15 | 0 | P
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 15.686500

{ blur[t5, t6, t7] -> blur[0, t4298 = 0, x_outer, t4300 = 0, y_outer, t4302 = 0, x_inner, t4295 = 0, y_inner, t4304 = 0, c = t5, t4306 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= x_outer < 7 | 0 | P
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 10.016400

{ blur[t5, t6, t7] -> blur[0, t4355 = 0, x_outer, t4357 = 0, y_outer, t4359 = 0, x_inner, t4352 = 0, y_inner, t4361 = 0, c = t5, t4363 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= x_outer < 7 | 0 | P
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 11.387600

{ blur[t5, t6, t7] -> blur[0, t4412 = 0, x_outer, t4414 = 0, y_outer, t4416 = 0, x_inner, t4409 = 0, y_inner, t4418 = 0, c = t5, t4420 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= x_outer < 7 | 0 | P
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 15.986000

{ blur[t5, t6, t7] -> blur[0, t4469 = 0, x_outer, t4471 = 0, y_outer, t4473 = 0, x_inner, t4466 = 0, y_inner, t4475 = 0, c = t5, t4477 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
10.864500+18.364300+13.985000+11.673500+13.960000+15.686500+10.016400+11.387600+15.986000+22.451500+
remaining list
10.016400+10.864500+11.387600+11.673500+ Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 32 L1 32
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 38.738602

{ blur[t5, t6, t7] -> blur[0, t4526 = 0, x_outer, t4528 = 0, y_outer, t4530 = 0, x_inner, t4523 = 0, y_inner, t4532 = 0, c = t5, t4534 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 32 L1 64
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 37.279499

{ blur[t5, t6, t7] -> blur[0, t4582 = 0, x_outer, t4584 = 0, y_outer, t4586 = 0, x_inner, t4579 = 0, y_inner, t4588 = 0, c = t5, t4590 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 32 L1 128
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 39.367401

{ blur[t5, t6, t7] -> blur[0, t4638 = 0, x_outer, t4640 = 0, y_outer, t4642 = 0, x_inner, t4635 = 0, y_inner, t4644 = 0, c = t5, t4646 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 64 L1 32
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 37.607399

{ blur[t5, t6, t7] -> blur[0, t4694 = 0, x_outer, t4696 = 0, y_outer, t4698 = 0, x_inner, t4691 = 0, y_inner, t4700 = 0, c = t5, t4702 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 64 L1 64
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 36.696400

{ blur[t5, t6, t7] -> blur[0, t4750 = 0, x_outer, t4752 = 0, y_outer, t4754 = 0, x_inner, t4747 = 0, y_inner, t4756 = 0, c = t5, t4758 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 64 L1 128
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 38.044899

{ blur[t5, t6, t7] -> blur[0, t4806 = 0, x_outer, t4808 = 0, y_outer, t4810 = 0, x_inner, t4803 = 0, y_inner, t4812 = 0, c = t5, t4814 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 128 L1 32
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 36.024101

{ blur[t5, t6, t7] -> blur[0, t4862 = 0, x_outer, t4864 = 0, y_outer, t4866 = 0, x_inner, t4859 = 0, y_inner, t4868 = 0, c = t5, t4870 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 128 L1 64
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 36.609901

{ blur[t5, t6, t7] -> blur[0, t4918 = 0, x_outer, t4920 = 0, y_outer, t4922 = 0, x_inner, t4915 = 0, y_inner, t4924 = 0, c = t5, t4926 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Tiling L0 128 L1 128
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 39.447399

{ blur[t5, t6, t7] -> blur[0, t4974 = 0, x_outer, t4976 = 0, y_outer, t4978 = 0, x_inner, t4971 = 0, y_inner, t4980 = 0, c = t5, t4982 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
38.738602+37.279499+39.367401+37.607399+36.696400+38.044899+36.024101+36.609901+39.447399+91.293098+
remaining list
36.024101+36.609901+36.696400+37.279499+ Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    parallel (c3, 0, 32) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 31 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 13.153900

{ blur[t5, t6, t7] -> blur[0, t5030 = 0, x_outer, t5032 = 0, y_outer, t5034 = 0, x_inner, t5027 = 0, y_inner, t5036 = 0, c = t5, t5038 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    parallel (c3, 0, 16) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 15 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 19.058001

{ blur[t5, t6, t7] -> blur[0, t5087 = 0, x_outer, t5089 = 0, y_outer, t5091 = 0, x_inner, t5084 = 0, y_inner, t5093 = 0, c = t5, t5095 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    parallel (c3, 0, 8) {
      for (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 7 | 0 | P
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 35.954498

{ blur[t5, t6, t7] -> blur[0, t5144 = 0, x_outer, t5146 = 0, y_outer, t5148 = 0, x_inner, t5141 = 0, y_inner, t5150 = 0, c = t5, t5152 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    parallel (c3, 0, 32) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 31 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 12.952400

{ blur[t5, t6, t7] -> blur[0, t5201 = 0, x_outer, t5203 = 0, y_outer, t5205 = 0, x_inner, t5198 = 0, y_inner, t5207 = 0, c = t5, t5209 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    parallel (c3, 0, 16) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 15 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 13.160000

{ blur[t5, t6, t7] -> blur[0, t5258 = 0, x_outer, t5260 = 0, y_outer, t5262 = 0, x_inner, t5255 = 0, y_inner, t5264 = 0, c = t5, t5266 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    parallel (c3, 0, 8) {
      for (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 7 | 0 | P
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 34.259399

{ blur[t5, t6, t7] -> blur[0, t5315 = 0, x_outer, t5317 = 0, y_outer, t5319 = 0, x_inner, t5312 = 0, y_inner, t5321 = 0, c = t5, t5323 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    parallel (c3, 0, 32) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 31 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 11.258000

{ blur[t5, t6, t7] -> blur[0, t5372 = 0, x_outer, t5374 = 0, y_outer, t5376 = 0, x_inner, t5369 = 0, y_inner, t5378 = 0, c = t5, t5380 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    parallel (c3, 0, 16) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 15 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 21.068899

{ blur[t5, t6, t7] -> blur[0, t5429 = 0, x_outer, t5431 = 0, y_outer, t5433 = 0, x_inner, t5426 = 0, y_inner, t5435 = 0, c = t5, t5437 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 7 | 0 | P
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0
					blur
Evaluation : 27.555599

{ blur[t5, t6, t7] -> blur[0, t5486 = 0, x_outer, t5488 = 0, y_outer, t5490 = 0, x_inner, t5483 = 0, y_inner, t5492 = 0, c = t5, t5494 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
13.153900+19.058001+35.954498+12.952400+13.160000+34.259399+11.258000+21.068899+27.555599+249.703995+
remaining list
11.258000+12.952400+13.153900+13.160000+ Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 32) {
      parallel (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 32 L1 32
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 23.676500

{ blur[t5, t6, t7] -> blur[0, t5543 = 0, x_outer, t5545 = 0, y_outer, t5547 = 0, x_inner, t5540 = 0, y_inner, t5549 = 0, c = t5, t5551 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 16) {
      parallel (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 32 L1 64
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 18.672899

{ blur[t5, t6, t7] -> blur[0, t5600 = 0, x_outer, t5602 = 0, y_outer, t5604 = 0, x_inner, t5597 = 0, y_inner, t5606 = 0, c = t5, t5608 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 32) {
    for (c3, 0, 8) {
      parallel (c5, (1 - min((c1*32), 1)), ((min((c1*32), 1) - max((c1*32), 991)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*32) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*32) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 32 L1 128
0- for 0 <= x_outer < 31 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 32 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 20.558500

{ blur[t5, t6, t7] -> blur[0, t5657 = 0, x_outer, t5659 = 0, y_outer, t5661 = 0, x_inner, t5654 = 0, y_inner, t5663 = 0, c = t5, t5665 = 0] : (t7 - x_inner) mod 32 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -31 + t7 <= 32x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 31 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 32) {
      parallel (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 64 L1 32
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 18.819000

{ blur[t5, t6, t7] -> blur[0, t5714 = 0, x_outer, t5716 = 0, y_outer, t5718 = 0, x_inner, t5711 = 0, y_inner, t5720 = 0, c = t5, t5722 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 16) {
      parallel (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 64 L1 64
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 16.925699

{ blur[t5, t6, t7] -> blur[0, t5771 = 0, x_outer, t5773 = 0, y_outer, t5775 = 0, x_inner, t5768 = 0, y_inner, t5777 = 0, c = t5, t5779 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 16) {
    for (c3, 0, 8) {
      parallel (c5, (1 - min((c1*64), 1)), ((min((c1*64), 1) - max((c1*64), 959)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*64) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*64) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 64 L1 128
0- for 0 <= x_outer < 15 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 64 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 15.814100

{ blur[t5, t6, t7] -> blur[0, t5828 = 0, x_outer, t5830 = 0, y_outer, t5832 = 0, x_inner, t5825 = 0, y_inner, t5834 = 0, c = t5, t5836 = 0] : (t7 - x_inner) mod 64 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -63 + t7 <= 64x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 63 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 32) {
      parallel (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*32), 1)), ((min((c3*32), 1) - max((c3*32), 991)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*32) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*32) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 128 L1 32
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 31 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 32 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 15.384400

{ blur[t5, t6, t7] -> blur[0, t5885 = 0, x_outer, t5887 = 0, y_outer, t5889 = 0, x_inner, t5882 = 0, y_inner, t5891 = 0, c = t5, t5893 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 32 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -31 + t6 <= 32y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 31 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 16) {
      parallel (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*64), 1)), ((min((c3*64), 1) - max((c3*64), 959)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*64) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*64) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 128 L1 64
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 15 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 64 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 14.541500

{ blur[t5, t6, t7] -> blur[0, t5942 = 0, x_outer, t5944 = 0, y_outer, t5946 = 0, x_inner, t5939 = 0, y_inner, t5948 = 0, c = t5, t5950 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 64 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -63 + t6 <= 64y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 63 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>
 Tiling 2 loop names: x y c  deapth of outer is:0 test : x & y
Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      parallel (c5, (1 - min((c1*128), 1)), ((min((c1*128), 1) - max((c1*128), 895)) + 1022)) {
        for (c7, (1 - min((c3*128), 1)), ((min((c3*128), 1) - max((c3*128), 895)) + 1022)) {
          for (c9, 0, 3) {
            output_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))] + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32((int64(((c3*128) + c7))*(int64)1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)-1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((((c1*128) + c5) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))]) + input_buf[((int32((int64(((c1*128) + c5)) + (int64)1)) + int32(((int64(((c3*128) + c7))*(int64)1024) + (int64)-1024))) + int32((int64(c9)*(int64)1048576)))])*0.111111)
          }
        }
      }
    }
  }
}

-----------
Interchange L0  L2
Parallelize L2
Tiling L0 128 L1 128
0- for 0 <= x_outer < 7 | 0
	1- for 0 <= y_outer < 7 | 0
		2- for 0 <= x_inner < 128 | 0
			3- for 0 <= y_inner < 128 | 0
				4- for 0 <= c < 3 | 0 | P
					blur
Evaluation : 15.788000

{ blur[t5, t6, t7] -> blur[0, t5999 = 0, x_outer, t6001 = 0, y_outer, t6003 = 0, x_inner, t5996 = 0, y_inner, t6005 = 0, c = t5, t6007 = 0] : (t7 - x_inner) mod 128 = 0 and (t6 - y_inner) mod 128 = 0 and 0 <= t5 <= 2 and 0 < t6 <= 1022 and 0 < t7 <= 1022 and -127 + t7 <= 128x_outer <= t7 and -127 + t6 <= 128y_outer <= t6 and 0 <= x_inner <= 127 and 0 <= y_inner <= 127 }




input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 1 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 0 ,0 0 1 1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 -1 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 0 ,
input_img:1 0 0 0 ,0 1 0 -1 ,0 0 1 1 ,

<legal>

original list
23.676500+18.672899+20.558500+18.819000+16.925699+15.814100+15.384400+14.541500+15.788000+5186.029785+
remaining list
14.541500+15.384400+15.788000+15.814100+NB explored schedules : 123
Best evaluation : 4.250880
Initial exec time : 4.768970
Initial evaluation : 5.294440
Search time : 239669 ms 
0- for 0 <= c < 3 | 0 | P
	1- for 1 <= y < 1023 | 0
		2- for 1 <= x < 1023 | 0
			blur

Generated Halide IR:
assert((reinterpret(uint64, output_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("output_buf"))
assert((reinterpret(uint64, input_buf.buffer) != (uint64)0), halide_error_buffer_argument_is_null("input_buf"))
let input_buf = _halide_buffer_get_host(input_buf.buffer)
let output_buf = _halide_buffer_get_host(output_buf.buffer)
produce  {
  allocate _input_img_b0[float64 * 1024 * 1024 * 3]
  allocate _blur_b1[float64 * 1022 * 1022 * 3]
  parallel (c1, 0, 3) {
    for (c3, 1, 1022) {
      for (c5, 1, 1022) {
        output_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))] = (((((((((input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))] + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32((int64(c3)*(int64)1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)-1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((c5 + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))]) + input_buf[((int32((int64(c5) + (int64)1)) + int32(((int64(c3)*(int64)1024) + (int64)-1024))) + int32((int64(c1)*(int64)1048576)))])*0.111111)
      }
    }
  }
}
Best schedule exec time : 4.396560
Speedup : 1.084705
