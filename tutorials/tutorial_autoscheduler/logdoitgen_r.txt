
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}
======================step2==================================

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}
 vars i00 i01 i02 i03  interchange : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((c7 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Interchange L0  L1
0- for 0 <= i01 < 256 | 0
	1- for 0 <= i00 < 256 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i03 < 128 | 0
				comp03
Evaluation : 98.691902

{ comp03[t8, t9, t10, t11] -> comp03[0, t21 = 0, i01 = t9, t22 = 0, i00 = t8, t23 = 0, i02 = t10, t24 = 0, i03 = t11, t25 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  interchange : i00 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 256) {
        for (c7, 0, 128) {
          buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))]*buf01[(c7 + int32((int64(c1)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Interchange L0  L2
0- for 0 <= i02 < 128 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i00 < 256 | 0
			3- for 0 <= i03 < 128 | 0
				comp03
Evaluation : 839.469971

{ comp03[t8, t9, t10, t11] -> comp03[0, t35 = 0, i02 = t10, t36 = 0, i01 = t9, t37 = 0, i00 = t8, t38 = 0, i03 = t11, t39 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  interchange : i00 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 256) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c7)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c7)*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c7)*(int64)32768)))]*buf01[(c1 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Interchange L0  L3
0- for 0 <= i03 < 128 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i00 < 256 | 0
				comp03
Evaluation : 22618.400391

{ comp03[t8, t9, t10, t11] -> comp03[0, t49 = 0, i03 = t11, t50 = 0, i01 = t9, t51 = 0, i02 = t10, t52 = 0, i00 = t8, t53 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  interchange : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 256) {
        for (c7, 0, 128) {
          buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c3)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Interchange L1  L2
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i02 < 128 | 0
		2- for 0 <= i01 < 256 | 0
			3- for 0 <= i03 < 128 | 0
				comp03
Evaluation : 111.306000

{ comp03[t8, t9, t10, t11] -> comp03[0, t63 = 0, i00 = t8, t64 = 0, i02 = t10, t65 = 0, i01 = t9, t66 = 0, i03 = t11, t67 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  interchange : i01 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 128) {
        for (c7, 0, 256) {
          buf03[((c5 + int32((int64(c7)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c7)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(c7)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Interchange L1  L3
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i03 < 128 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i01 < 256 | 0
				comp03
Evaluation : 2969.649902

{ comp03[t8, t9, t10, t11] -> comp03[0, t77 = 0, i00 = t8, t78 = 0, i03 = t11, t79 = 0, i02 = t10, t80 = 0, i01 = t9, t81 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  interchange : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c5 + int32((int64(c7)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Interchange L2  L3
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i03 < 128 | 0
			3- for 0 <= i02 < 128 | 0
				comp03
Evaluation : 800.023987

{ comp03[t8, t9, t10, t11] -> comp03[0, t91 = 0, i00 = t8, t92 = 0, i01 = t9, t93 = 0, i03 = t11, t94 = 0, i02 = t10, t95 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
98.691902+839.469971+22618.400391+111.306000+2969.649902+800.023987+93.728996+
remaining list
93.728996+98.691902+111.306000+800.023987+ vars i00 i01 i02 i03  Skewing : i02 & i03
 transformation map:{[i,j]->[1*i1*j ,0*i1*j]}
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 255) {
        for (c7, max((c5 + -127), 0), ((min(c5, 127) - max((c5 + -127), 0)) + 1)) {
          buf03[(((c5 - c7) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((c5 - c7) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64((c5 - c7))*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_1 < 255 | 0
			3- for 0 <= i03_skew < 65 | 0
				comp03
Evaluation : 1045.750000

{ comp03[t8, t9, t10, t11] -> comp03[t107 = 0, t108 = 0, i00 = t8, t110 = 0, i01 = t9, t112 = 0, i02_skew_1_1 = t10 + t11, t114 = 0, i03_skew = t11, t116 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  Skewing : i02 & i03
 transformation map:{[i,j]->[1*i2*j ,0*i1*j]}
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 382) {
        for (c7, max((int32(floor_f32(float32((c5/2)))) + -63), 0), ((min(int32(floor_f32(float32((c5/2)))), 127) - max((int32(floor_f32(float32((c5/2)))) + -63), 0)) + 1)) {
          buf03[(((c5 - (c7*2)) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((c5 - (c7*2)) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64((c5 - (c7*2)))*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 2
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_2 < 382 | 0
			3- for 0 <= i03_skew < 44 | 0
				comp03
Evaluation : 1333.290039

{ comp03[t8, t9, t10, t11] -> comp03[t135 = 0, t136 = 0, i00 = t8, t138 = 0, i01 = t9, t140 = 0, i02_skew_1_2 = t10 + 2t11, t142 = 0, i03_skew = t11, t144 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 vars i00 i01 i02 i03  Skewing : i02 & i03
 transformation map:{[i,j]->[1*i3*j ,0*i1*j]}
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 509) {
        for (c7, max((int32(floor_f32(float32(((c5 + 1)/3)))) + -42), 0), ((min(int32(floor_f32(float32((c5/3)))), 127) - max((int32(floor_f32(float32(((c5 + 1)/3)))) + -42), 0)) + 1)) {
          buf03[(((c5 - (c7*3)) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((c5 - (c7*3)) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64((c5 - (c7*3)))*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 3
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_3 < 509 | 0
			3- for 0 <= i03_skew < 33 | 0
				comp03
Evaluation : 1510.089966

{ comp03[t8, t9, t10, t11] -> comp03[t163 = 0, t164 = 0, i00 = t8, t166 = 0, i01 = t9, t168 = 0, i02_skew_1_3 = t10 + 3t11, t170 = 0, i03_skew = t11, t172 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
1045.750000+1333.290039+1510.089966+93.728996+
remaining list
93.728996+1045.750000+1333.290039+1510.089966+
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Parallelize L0
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i03 < 128 | 0
				comp03
Evaluation : 23.410999

{ comp03[t8, t9, t10, t11] -> comp03[0, 0, i00 = t8, 0, i01 = t9, 0, i02 = t10, 0, i03 = t11, 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Parallelize L1
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i03 < 128 | 0
				comp03
Evaluation : 31.290100

{ comp03[t8, t9, t10, t11] -> comp03[0, 0, i00 = t8, 0, i01 = t9, 0, i02 = t10, 0, i03 = t11, 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Parallelize L2
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02 < 128 | 0 | P
			3- for 0 <= i03 < 128 | 0
				comp03
Evaluation : 1792.680054

{ comp03[t8, t9, t10, t11] -> comp03[0, 0, i00 = t8, 0, i01 = t9, 0, i02 = t10, 0, i03 = t11, 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
23.410999+31.290100+1792.680054+93.728996+
remaining list
23.410999+31.290100+93.728996+1792.680054+ Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.173000

{ comp03[t8, t9, t10, t11] -> comp03[0, t218 = 0, i00_outer, t220 = 0, i01_outer, t222 = 0, i00_inner, t215 = 0, i01_inner, t224 = 0, i02 = t10, t226 = 0, i03 = t11, t228 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.993000

{ comp03[t8, t9, t10, t11] -> comp03[0, t298 = 0, i00_outer, t300 = 0, i01_outer, t302 = 0, i02_outer, t304 = 0, i00_inner, t306 = 0, i01_inner, t295 = 0, i02_inner, t308 = 0, i03 = t11, t310 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.579100

{ comp03[t8, t9, t10, t11] -> comp03[0, t399 = 0, i00_outer, t401 = 0, i01_outer, t403 = 0, i02_outer, t405 = 0, i00_inner, t407 = 0, i01_inner, t396 = 0, i02_inner, t409 = 0, i03 = t11, t411 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 25.816900

{ comp03[t8, t9, t10, t11] -> comp03[0, t485 = 0, i00_outer, t487 = 0, i01_outer, t489 = 0, i00_inner, t482 = 0, i01_inner, t491 = 0, i02 = t10, t493 = 0, i03 = t11, t495 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 41.806000

{ comp03[t8, t9, t10, t11] -> comp03[0, t565 = 0, i00_outer, t567 = 0, i01_outer, t569 = 0, i02_outer, t571 = 0, i00_inner, t573 = 0, i01_inner, t562 = 0, i02_inner, t575 = 0, i03 = t11, t577 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 35.470001

{ comp03[t8, t9, t10, t11] -> comp03[0, t666 = 0, i00_outer, t668 = 0, i01_outer, t670 = 0, i02_outer, t672 = 0, i00_inner, t674 = 0, i01_inner, t663 = 0, i02_inner, t676 = 0, i03 = t11, t678 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.983999

{ comp03[t8, t9, t10, t11] -> comp03[0, t752 = 0, i00_outer, t754 = 0, i01_outer, t756 = 0, i00_inner, t749 = 0, i01_inner, t758 = 0, i02 = t10, t760 = 0, i03 = t11, t762 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 28.462200

{ comp03[t8, t9, t10, t11] -> comp03[0, t832 = 0, i00_outer, t834 = 0, i01_outer, t836 = 0, i02_outer, t838 = 0, i00_inner, t840 = 0, i01_inner, t829 = 0, i02_inner, t842 = 0, i03 = t11, t844 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.903000

{ comp03[t8, t9, t10, t11] -> comp03[0, t933 = 0, i00_outer, t935 = 0, i01_outer, t937 = 0, i02_outer, t939 = 0, i00_inner, t941 = 0, i01_inner, t930 = 0, i02_inner, t943 = 0, i03 = t11, t945 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 25.538000

{ comp03[t8, t9, t10, t11] -> comp03[0, t1019 = 0, i00_outer, t1021 = 0, i01_outer, t1023 = 0, i00_inner, t1016 = 0, i01_inner, t1025 = 0, i02 = t10, t1027 = 0, i03 = t11, t1029 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.647200

{ comp03[t8, t9, t10, t11] -> comp03[0, t1099 = 0, i00_outer, t1101 = 0, i01_outer, t1103 = 0, i02_outer, t1105 = 0, i00_inner, t1107 = 0, i01_inner, t1096 = 0, i02_inner, t1109 = 0, i03 = t11, t1111 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.278999

{ comp03[t8, t9, t10, t11] -> comp03[0, t1200 = 0, i00_outer, t1202 = 0, i01_outer, t1204 = 0, i02_outer, t1206 = 0, i00_inner, t1208 = 0, i01_inner, t1197 = 0, i02_inner, t1210 = 0, i03 = t11, t1212 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 25.417999

{ comp03[t8, t9, t10, t11] -> comp03[0, t1286 = 0, i00_outer, t1288 = 0, i01_outer, t1290 = 0, i00_inner, t1283 = 0, i01_inner, t1292 = 0, i02 = t10, t1294 = 0, i03 = t11, t1296 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.237000

{ comp03[t8, t9, t10, t11] -> comp03[0, t1366 = 0, i00_outer, t1368 = 0, i01_outer, t1370 = 0, i02_outer, t1372 = 0, i00_inner, t1374 = 0, i01_inner, t1363 = 0, i02_inner, t1376 = 0, i03 = t11, t1378 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.626200

{ comp03[t8, t9, t10, t11] -> comp03[0, t1467 = 0, i00_outer, t1469 = 0, i01_outer, t1471 = 0, i02_outer, t1473 = 0, i00_inner, t1475 = 0, i01_inner, t1464 = 0, i02_inner, t1477 = 0, i03 = t11, t1479 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.237900

{ comp03[t8, t9, t10, t11] -> comp03[0, t1553 = 0, i00_outer, t1555 = 0, i01_outer, t1557 = 0, i00_inner, t1550 = 0, i01_inner, t1559 = 0, i02 = t10, t1561 = 0, i03 = t11, t1563 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 27.043800

{ comp03[t8, t9, t10, t11] -> comp03[0, t1633 = 0, i00_outer, t1635 = 0, i01_outer, t1637 = 0, i02_outer, t1639 = 0, i00_inner, t1641 = 0, i01_inner, t1630 = 0, i02_inner, t1643 = 0, i03 = t11, t1645 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 24.775999

{ comp03[t8, t9, t10, t11] -> comp03[0, t1734 = 0, i00_outer, t1736 = 0, i01_outer, t1738 = 0, i02_outer, t1740 = 0, i00_inner, t1742 = 0, i01_inner, t1731 = 0, i02_inner, t1744 = 0, i03 = t11, t1746 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 44.456001

{ comp03[t8, t9, t10, t11] -> comp03[0, t1820 = 0, i00_outer, t1822 = 0, i01_outer, t1824 = 0, i00_inner, t1817 = 0, i01_inner, t1826 = 0, i02 = t10, t1828 = 0, i03 = t11, t1830 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 47.151100

{ comp03[t8, t9, t10, t11] -> comp03[0, t1900 = 0, i00_outer, t1902 = 0, i01_outer, t1904 = 0, i02_outer, t1906 = 0, i00_inner, t1908 = 0, i01_inner, t1897 = 0, i02_inner, t1910 = 0, i03 = t11, t1912 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.006001

{ comp03[t8, t9, t10, t11] -> comp03[0, t2001 = 0, i00_outer, t2003 = 0, i01_outer, t2005 = 0, i02_outer, t2007 = 0, i00_inner, t2009 = 0, i01_inner, t1998 = 0, i02_inner, t2011 = 0, i03 = t11, t2013 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 44.480999

{ comp03[t8, t9, t10, t11] -> comp03[0, t2087 = 0, i00_outer, t2089 = 0, i01_outer, t2091 = 0, i00_inner, t2084 = 0, i01_inner, t2093 = 0, i02 = t10, t2095 = 0, i03 = t11, t2097 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 46.819901

{ comp03[t8, t9, t10, t11] -> comp03[0, t2167 = 0, i00_outer, t2169 = 0, i01_outer, t2171 = 0, i02_outer, t2173 = 0, i00_inner, t2175 = 0, i01_inner, t2164 = 0, i02_inner, t2177 = 0, i03 = t11, t2179 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.621201

{ comp03[t8, t9, t10, t11] -> comp03[0, t2268 = 0, i00_outer, t2270 = 0, i01_outer, t2272 = 0, i02_outer, t2274 = 0, i00_inner, t2276 = 0, i01_inner, t2265 = 0, i02_inner, t2278 = 0, i03 = t11, t2280 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 50.110802

{ comp03[t8, t9, t10, t11] -> comp03[0, t2354 = 0, i00_outer, t2356 = 0, i01_outer, t2358 = 0, i00_inner, t2351 = 0, i01_inner, t2360 = 0, i02 = t10, t2362 = 0, i03 = t11, t2364 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 48.306900

{ comp03[t8, t9, t10, t11] -> comp03[0, t2434 = 0, i00_outer, t2436 = 0, i01_outer, t2438 = 0, i02_outer, t2440 = 0, i00_inner, t2442 = 0, i01_inner, t2431 = 0, i02_inner, t2444 = 0, i03 = t11, t2446 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.412102

{ comp03[t8, t9, t10, t11] -> comp03[0, t2535 = 0, i00_outer, t2537 = 0, i01_outer, t2539 = 0, i02_outer, t2541 = 0, i00_inner, t2543 = 0, i01_inner, t2532 = 0, i02_inner, t2545 = 0, i03 = t11, t2547 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 31.750000

{ comp03[t8, t9, t10, t11] -> comp03[0, t2621 = 0, i00 = t8, t2623 = 0, i01_outer, t2625 = 0, i02_outer, t2627 = 0, i01_inner, t2618 = 0, i02_inner, t2629 = 0, i03 = t11, t2631 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 100.500999

{ comp03[t8, t9, t10, t11] -> comp03[0, t2701 = 0, i00 = t8, t2703 = 0, i01_outer, t2705 = 0, i02_outer, t2707 = 0, i03_outer, t2709 = 0, i01_inner, t2711 = 0, i02_inner, t2698 = 0, i03_inner, t2713 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 32 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 25.603100

{ comp03[t8, t9, t10, t11] -> comp03[0, t2802 = 0, i00 = t8, t2804 = 0, i01_outer, t2806 = 0, i02_outer, t2808 = 0, i03_outer, t2810 = 0, i01_inner, t2812 = 0, i02_inner, t2799 = 0, i03_inner, t2814 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.113199

{ comp03[t8, t9, t10, t11] -> comp03[0, t2888 = 0, i00 = t8, t2890 = 0, i01_outer, t2892 = 0, i02_outer, t2894 = 0, i01_inner, t2885 = 0, i02_inner, t2896 = 0, i03 = t11, t2898 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 96.874001

{ comp03[t8, t9, t10, t11] -> comp03[0, t2968 = 0, i00 = t8, t2970 = 0, i01_outer, t2972 = 0, i02_outer, t2974 = 0, i03_outer, t2976 = 0, i01_inner, t2978 = 0, i02_inner, t2965 = 0, i03_inner, t2980 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 32 L2 64 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 26.531000

{ comp03[t8, t9, t10, t11] -> comp03[0, t3069 = 0, i00 = t8, t3071 = 0, i01_outer, t3073 = 0, i02_outer, t3075 = 0, i03_outer, t3077 = 0, i01_inner, t3079 = 0, i02_inner, t3066 = 0, i03_inner, t3081 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 40.258900

{ comp03[t8, t9, t10, t11] -> comp03[0, t3155 = 0, i00 = t8, t3157 = 0, i01_outer, t3159 = 0, i02_outer, t3161 = 0, i01_inner, t3152 = 0, i02_inner, t3163 = 0, i03 = t11, t3165 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 117.879997

{ comp03[t8, t9, t10, t11] -> comp03[0, t3235 = 0, i00 = t8, t3237 = 0, i01_outer, t3239 = 0, i02_outer, t3241 = 0, i03_outer, t3243 = 0, i01_inner, t3245 = 0, i02_inner, t3232 = 0, i03_inner, t3247 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 32 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 37.987000

{ comp03[t8, t9, t10, t11] -> comp03[0, t3336 = 0, i00 = t8, t3338 = 0, i01_outer, t3340 = 0, i02_outer, t3342 = 0, i03_outer, t3344 = 0, i01_inner, t3346 = 0, i02_inner, t3333 = 0, i03_inner, t3348 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.644199

{ comp03[t8, t9, t10, t11] -> comp03[0, t3422 = 0, i00 = t8, t3424 = 0, i01_outer, t3426 = 0, i02_outer, t3428 = 0, i01_inner, t3419 = 0, i02_inner, t3430 = 0, i03 = t11, t3432 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 95.056999

{ comp03[t8, t9, t10, t11] -> comp03[0, t3502 = 0, i00 = t8, t3504 = 0, i01_outer, t3506 = 0, i02_outer, t3508 = 0, i03_outer, t3510 = 0, i01_inner, t3512 = 0, i02_inner, t3499 = 0, i03_inner, t3514 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 34.445999

{ comp03[t8, t9, t10, t11] -> comp03[0, t3603 = 0, i00 = t8, t3605 = 0, i01_outer, t3607 = 0, i02_outer, t3609 = 0, i03_outer, t3611 = 0, i01_inner, t3613 = 0, i02_inner, t3600 = 0, i03_inner, t3615 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 36.206001

{ comp03[t8, t9, t10, t11] -> comp03[0, t3689 = 0, i00 = t8, t3691 = 0, i01_outer, t3693 = 0, i02_outer, t3695 = 0, i01_inner, t3686 = 0, i02_inner, t3697 = 0, i03 = t11, t3699 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 122.167000

{ comp03[t8, t9, t10, t11] -> comp03[0, t3769 = 0, i00 = t8, t3771 = 0, i01_outer, t3773 = 0, i02_outer, t3775 = 0, i03_outer, t3777 = 0, i01_inner, t3779 = 0, i02_inner, t3766 = 0, i03_inner, t3781 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 32 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 41.379002

{ comp03[t8, t9, t10, t11] -> comp03[0, t3870 = 0, i00 = t8, t3872 = 0, i01_outer, t3874 = 0, i02_outer, t3876 = 0, i03_outer, t3878 = 0, i01_inner, t3880 = 0, i02_inner, t3867 = 0, i03_inner, t3882 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.547899

{ comp03[t8, t9, t10, t11] -> comp03[0, t3956 = 0, i00 = t8, t3958 = 0, i01_outer, t3960 = 0, i02_outer, t3962 = 0, i01_inner, t3953 = 0, i02_inner, t3964 = 0, i03 = t11, t3966 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 93.493202

{ comp03[t8, t9, t10, t11] -> comp03[0, t4036 = 0, i00 = t8, t4038 = 0, i01_outer, t4040 = 0, i02_outer, t4042 = 0, i03_outer, t4044 = 0, i01_inner, t4046 = 0, i02_inner, t4033 = 0, i03_inner, t4048 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 32.731098

{ comp03[t8, t9, t10, t11] -> comp03[0, t4137 = 0, i00 = t8, t4139 = 0, i01_outer, t4141 = 0, i02_outer, t4143 = 0, i03_outer, t4145 = 0, i01_inner, t4147 = 0, i02_inner, t4134 = 0, i03_inner, t4149 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 95.323097

{ comp03[t8, t9, t10, t11] -> comp03[0, t4223 = 0, i00 = t8, t4225 = 0, i01 = t9, t4227 = 0, i02_outer, t4229 = 0, i03_outer, t4231 = 0, i02_inner, t4220 = 0, i03_inner, t4233 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L2 32 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 25.136900

{ comp03[t8, t9, t10, t11] -> comp03[0, t4288 = 0, i00 = t8, t4290 = 0, i01 = t9, t4292 = 0, i02_outer, t4294 = 0, i03_outer, t4296 = 0, i02_inner, t4285 = 0, i03_inner, t4298 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 93.095100

{ comp03[t8, t9, t10, t11] -> comp03[0, t4353 = 0, i00 = t8, t4355 = 0, i01 = t9, t4357 = 0, i02_outer, t4359 = 0, i03_outer, t4361 = 0, i02_inner, t4350 = 0, i03_inner, t4363 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L2 64 L3 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 25.723000

{ comp03[t8, t9, t10, t11] -> comp03[0, t4418 = 0, i00 = t8, t4420 = 0, i01 = t9, t4422 = 0, i02_outer, t4424 = 0, i03_outer, t4426 = 0, i02_inner, t4415 = 0, i03_inner, t4428 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
24.173000+26.993000+26.579100+25.816900+41.806000+35.470001+23.983999+28.462200+25.903000+25.538000+25.647200+25.278999+25.417999+26.237000+25.626200+24.237900+27.043800+24.775999+44.456001+47.151100+45.006001+44.480999+46.819901+45.621201+50.110802+48.306900+45.412102+31.750000+100.500999+25.603100+24.113199+96.874001+26.531000+40.258900+117.879997+37.987000+23.644199+95.056999+34.445999+36.206001+122.167000+41.379002+23.547899+93.493202+32.731098+95.323097+25.136900+93.095100+25.723000+23.410999+
remaining list
23.410999+23.547899+23.644199+23.983999+
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*4) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*4) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L3 4
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i03_outer < 32 | 0
				4- for 0 <= i03_inner < 4 | 1
					comp03
Evaluation : 68.320000

{ comp03[t8, t9, t10, t11] -> comp03[0, 0, i00 = t8, 0, i01 = t9, 0, i02 = t10, 0, i03 = t11, 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }




comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*8) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*8) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L3 8
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i03_outer < 16 | 0
				4- for 0 <= i03_inner < 8 | 1
					comp03
Evaluation : 104.056999

{ comp03[t8, t9, t10, t11] -> comp03[0, 0, i00 = t8, 0, i01 = t9, 0, i02 = t10, 0, i03 = t11, 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }




comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*16) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*16) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Unrolling L3 16
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02 < 128 | 0
			3- for 0 <= i03_outer < 8 | 0
				4- for 0 <= i03_inner < 16 | 1
					comp03
Evaluation : 40.341099

{ comp03[t8, t9, t10, t11] -> comp03[0, 0, i00 = t8, 0, i01 = t9, 0, i02 = t10, 0, i03 = t11, 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }




comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
Unrolling L5 4
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 68.669098

{ comp03[t8, t9, t10, t11] -> comp03[0, t3956 = 0, i00 = t8, t3958 = 0, i01_outer, t3960 = 0, i02_outer, t3962 = 0, i01_inner, t3953 = 0, i02_inner, t3964 = 0, i03 = t11, t3966 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
Unrolling L5 8
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 104.071999

{ comp03[t8, t9, t10, t11] -> comp03[0, t3956 = 0, i00 = t8, t3958 = 0, i01_outer, t3960 = 0, i02_outer, t3962 = 0, i01_inner, t3953 = 0, i02_inner, t3964 = 0, i03 = t11, t3966 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 128 L2 64
Unrolling L5 16
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 39.940102

{ comp03[t8, t9, t10, t11] -> comp03[0, t3956 = 0, i00 = t8, t3958 = 0, i01_outer, t3960 = 0, i02_outer, t3962 = 0, i01_inner, t3953 = 0, i02_inner, t3964 = 0, i03 = t11, t3966 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
Unrolling L5 4
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 74.149101

{ comp03[t8, t9, t10, t11] -> comp03[0, t3422 = 0, i00 = t8, t3424 = 0, i01_outer, t3426 = 0, i02_outer, t3428 = 0, i01_inner, t3419 = 0, i02_inner, t3430 = 0, i03 = t11, t3432 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
Unrolling L5 8
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 104.545998

{ comp03[t8, t9, t10, t11] -> comp03[0, t3422 = 0, i00 = t8, t3424 = 0, i01_outer, t3426 = 0, i02_outer, t3428 = 0, i01_inner, t3419 = 0, i02_inner, t3430 = 0, i03 = t11, t3432 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L1 64 L2 64
Unrolling L5 16
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 39.777000

{ comp03[t8, t9, t10, t11] -> comp03[0, t3422 = 0, i00 = t8, t3424 = 0, i01_outer, t3426 = 0, i02_outer, t3428 = 0, i01_inner, t3419 = 0, i02_inner, t3430 = 0, i03 = t11, t3432 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L5 4
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 69.371902

{ comp03[t8, t9, t10, t11] -> comp03[0, t752 = 0, i00_outer, t754 = 0, i01_outer, t756 = 0, i00_inner, t749 = 0, i01_inner, t758 = 0, i02 = t10, t760 = 0, i03 = t11, t762 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L5 8
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 107.521004

{ comp03[t8, t9, t10, t11] -> comp03[0, t752 = 0, i00_outer, t754 = 0, i01_outer, t756 = 0, i00_inner, t749 = 0, i01_inner, t758 = 0, i02 = t10, t760 = 0, i03 = t11, t762 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L0
Tiling L0 32 L1 128
Unrolling L5 16
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 41.042999

{ comp03[t8, t9, t10, t11] -> comp03[0, t752 = 0, i00_outer, t754 = 0, i01_outer, t756 = 0, i00_inner, t749 = 0, i01_inner, t758 = 0, i02 = t10, t760 = 0, i03 = t11, t762 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 25.844101

{ comp03[t8, t9, t10, t11] -> comp03[0, t5101 = 0, i00_outer, t5103 = 0, i01_outer, t5105 = 0, i00_inner, t5098 = 0, i01_inner, t5107 = 0, i02 = t10, t5109 = 0, i03 = t11, t5111 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.530100

{ comp03[t8, t9, t10, t11] -> comp03[0, t5181 = 0, i00_outer, t5183 = 0, i01_outer, t5185 = 0, i02_outer, t5187 = 0, i00_inner, t5189 = 0, i01_inner, t5178 = 0, i02_inner, t5191 = 0, i03 = t11, t5193 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 24.912800

{ comp03[t8, t9, t10, t11] -> comp03[0, t5282 = 0, i00_outer, t5284 = 0, i01_outer, t5286 = 0, i02_outer, t5288 = 0, i00_inner, t5290 = 0, i01_inner, t5279 = 0, i02_inner, t5292 = 0, i03 = t11, t5294 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 25.410900

{ comp03[t8, t9, t10, t11] -> comp03[0, t5368 = 0, i00_outer, t5370 = 0, i01_outer, t5372 = 0, i00_inner, t5365 = 0, i01_inner, t5374 = 0, i02 = t10, t5376 = 0, i03 = t11, t5378 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.110901

{ comp03[t8, t9, t10, t11] -> comp03[0, t5448 = 0, i00_outer, t5450 = 0, i01_outer, t5452 = 0, i02_outer, t5454 = 0, i00_inner, t5456 = 0, i01_inner, t5445 = 0, i02_inner, t5458 = 0, i03 = t11, t5460 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 24.814100

{ comp03[t8, t9, t10, t11] -> comp03[0, t5549 = 0, i00_outer, t5551 = 0, i01_outer, t5553 = 0, i02_outer, t5555 = 0, i00_inner, t5557 = 0, i01_inner, t5546 = 0, i02_inner, t5559 = 0, i03 = t11, t5561 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 82.007896

{ comp03[t8, t9, t10, t11] -> comp03[0, t5635 = 0, i00_outer, t5637 = 0, i01_outer, t5639 = 0, i00_inner, t5632 = 0, i01_inner, t5641 = 0, i02 = t10, t5643 = 0, i03 = t11, t5645 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.025101

{ comp03[t8, t9, t10, t11] -> comp03[0, t5715 = 0, i00_outer, t5717 = 0, i01_outer, t5719 = 0, i02_outer, t5721 = 0, i00_inner, t5723 = 0, i01_inner, t5712 = 0, i02_inner, t5725 = 0, i03 = t11, t5727 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 43.844002

{ comp03[t8, t9, t10, t11] -> comp03[0, t5816 = 0, i00_outer, t5818 = 0, i01_outer, t5820 = 0, i02_outer, t5822 = 0, i00_inner, t5824 = 0, i01_inner, t5813 = 0, i02_inner, t5826 = 0, i03 = t11, t5828 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.870001

{ comp03[t8, t9, t10, t11] -> comp03[0, t5902 = 0, i00_outer, t5904 = 0, i01_outer, t5906 = 0, i00_inner, t5899 = 0, i01_inner, t5908 = 0, i02 = t10, t5910 = 0, i03 = t11, t5912 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.021000

{ comp03[t8, t9, t10, t11] -> comp03[0, t5982 = 0, i00_outer, t5984 = 0, i01_outer, t5986 = 0, i02_outer, t5988 = 0, i00_inner, t5990 = 0, i01_inner, t5979 = 0, i02_inner, t5992 = 0, i03 = t11, t5994 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.066099

{ comp03[t8, t9, t10, t11] -> comp03[0, t6083 = 0, i00_outer, t6085 = 0, i01_outer, t6087 = 0, i02_outer, t6089 = 0, i00_inner, t6091 = 0, i01_inner, t6080 = 0, i02_inner, t6093 = 0, i03 = t11, t6095 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.643900

{ comp03[t8, t9, t10, t11] -> comp03[0, t6169 = 0, i00_outer, t6171 = 0, i01_outer, t6173 = 0, i00_inner, t6166 = 0, i01_inner, t6175 = 0, i02 = t10, t6177 = 0, i03 = t11, t6179 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.418098

{ comp03[t8, t9, t10, t11] -> comp03[0, t6249 = 0, i00_outer, t6251 = 0, i01_outer, t6253 = 0, i02_outer, t6255 = 0, i00_inner, t6257 = 0, i01_inner, t6246 = 0, i02_inner, t6259 = 0, i03 = t11, t6261 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.395901

{ comp03[t8, t9, t10, t11] -> comp03[0, t6350 = 0, i00_outer, t6352 = 0, i01_outer, t6354 = 0, i02_outer, t6356 = 0, i00_inner, t6358 = 0, i01_inner, t6347 = 0, i02_inner, t6360 = 0, i03 = t11, t6362 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 43.334000

{ comp03[t8, t9, t10, t11] -> comp03[0, t6436 = 0, i00_outer, t6438 = 0, i01_outer, t6440 = 0, i00_inner, t6433 = 0, i01_inner, t6442 = 0, i02 = t10, t6444 = 0, i03 = t11, t6446 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.559898

{ comp03[t8, t9, t10, t11] -> comp03[0, t6516 = 0, i00_outer, t6518 = 0, i01_outer, t6520 = 0, i02_outer, t6522 = 0, i00_inner, t6524 = 0, i01_inner, t6513 = 0, i02_inner, t6526 = 0, i03 = t11, t6528 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.249100

{ comp03[t8, t9, t10, t11] -> comp03[0, t6617 = 0, i00_outer, t6619 = 0, i01_outer, t6621 = 0, i02_outer, t6623 = 0, i00_inner, t6625 = 0, i01_inner, t6614 = 0, i02_inner, t6627 = 0, i03 = t11, t6629 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.329901

{ comp03[t8, t9, t10, t11] -> comp03[0, t6703 = 0, i00_outer, t6705 = 0, i01_outer, t6707 = 0, i00_inner, t6700 = 0, i01_inner, t6709 = 0, i02 = t10, t6711 = 0, i03 = t11, t6713 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.202000

{ comp03[t8, t9, t10, t11] -> comp03[0, t6783 = 0, i00_outer, t6785 = 0, i01_outer, t6787 = 0, i02_outer, t6789 = 0, i00_inner, t6791 = 0, i01_inner, t6780 = 0, i02_inner, t6793 = 0, i03 = t11, t6795 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 24.159901

{ comp03[t8, t9, t10, t11] -> comp03[0, t6884 = 0, i00_outer, t6886 = 0, i01_outer, t6888 = 0, i02_outer, t6890 = 0, i00_inner, t6892 = 0, i01_inner, t6881 = 0, i02_inner, t6894 = 0, i03 = t11, t6896 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 41.753101

{ comp03[t8, t9, t10, t11] -> comp03[0, t6970 = 0, i00_outer, t6972 = 0, i01_outer, t6974 = 0, i00_inner, t6967 = 0, i01_inner, t6976 = 0, i02 = t10, t6978 = 0, i03 = t11, t6980 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.381001

{ comp03[t8, t9, t10, t11] -> comp03[0, t7050 = 0, i00_outer, t7052 = 0, i01_outer, t7054 = 0, i02_outer, t7056 = 0, i00_inner, t7058 = 0, i01_inner, t7047 = 0, i02_inner, t7060 = 0, i03 = t11, t7062 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 24.658199

{ comp03[t8, t9, t10, t11] -> comp03[0, t7151 = 0, i00_outer, t7153 = 0, i01_outer, t7155 = 0, i02_outer, t7157 = 0, i00_inner, t7159 = 0, i01_inner, t7148 = 0, i02_inner, t7161 = 0, i03 = t11, t7163 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 43.200001

{ comp03[t8, t9, t10, t11] -> comp03[0, t7237 = 0, i00_outer, t7239 = 0, i01_outer, t7241 = 0, i00_inner, t7234 = 0, i01_inner, t7243 = 0, i02 = t10, t7245 = 0, i03 = t11, t7247 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.694099

{ comp03[t8, t9, t10, t11] -> comp03[0, t7317 = 0, i00_outer, t7319 = 0, i01_outer, t7321 = 0, i02_outer, t7323 = 0, i00_inner, t7325 = 0, i01_inner, t7314 = 0, i02_inner, t7327 = 0, i03 = t11, t7329 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.208000

{ comp03[t8, t9, t10, t11] -> comp03[0, t7418 = 0, i00_outer, t7420 = 0, i01_outer, t7422 = 0, i02_outer, t7424 = 0, i00_inner, t7426 = 0, i01_inner, t7415 = 0, i02_inner, t7428 = 0, i03 = t11, t7430 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 29.886999

{ comp03[t8, t9, t10, t11] -> comp03[0, t7504 = 0, i00 = t8, t7506 = 0, i01_outer, t7508 = 0, i02_outer, t7510 = 0, i01_inner, t7501 = 0, i02_inner, t7512 = 0, i03 = t11, t7514 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 102.819000

{ comp03[t8, t9, t10, t11] -> comp03[0, t7584 = 0, i00 = t8, t7586 = 0, i01_outer, t7588 = 0, i02_outer, t7590 = 0, i03_outer, t7592 = 0, i01_inner, t7594 = 0, i02_inner, t7581 = 0, i03_inner, t7596 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 31.139900

{ comp03[t8, t9, t10, t11] -> comp03[0, t7685 = 0, i00 = t8, t7687 = 0, i01_outer, t7689 = 0, i02_outer, t7691 = 0, i03_outer, t7693 = 0, i01_inner, t7695 = 0, i02_inner, t7682 = 0, i03_inner, t7697 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 29.771799

{ comp03[t8, t9, t10, t11] -> comp03[0, t7771 = 0, i00 = t8, t7773 = 0, i01_outer, t7775 = 0, i02_outer, t7777 = 0, i01_inner, t7768 = 0, i02_inner, t7779 = 0, i03 = t11, t7781 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 100.469002

{ comp03[t8, t9, t10, t11] -> comp03[0, t7851 = 0, i00 = t8, t7853 = 0, i01_outer, t7855 = 0, i02_outer, t7857 = 0, i03_outer, t7859 = 0, i01_inner, t7861 = 0, i02_inner, t7848 = 0, i03_inner, t7863 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 32 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 30.788900

{ comp03[t8, t9, t10, t11] -> comp03[0, t7952 = 0, i00 = t8, t7954 = 0, i01_outer, t7956 = 0, i02_outer, t7958 = 0, i03_outer, t7960 = 0, i01_inner, t7962 = 0, i02_inner, t7949 = 0, i03_inner, t7964 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 30.538099

{ comp03[t8, t9, t10, t11] -> comp03[0, t8038 = 0, i00 = t8, t8040 = 0, i01_outer, t8042 = 0, i02_outer, t8044 = 0, i01_inner, t8035 = 0, i02_inner, t8046 = 0, i03 = t11, t8048 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 104.146004

{ comp03[t8, t9, t10, t11] -> comp03[0, t8118 = 0, i00 = t8, t8120 = 0, i01_outer, t8122 = 0, i02_outer, t8124 = 0, i03_outer, t8126 = 0, i01_inner, t8128 = 0, i02_inner, t8115 = 0, i03_inner, t8130 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 31.517000

{ comp03[t8, t9, t10, t11] -> comp03[0, t8219 = 0, i00 = t8, t8221 = 0, i01_outer, t8223 = 0, i02_outer, t8225 = 0, i03_outer, t8227 = 0, i01_inner, t8229 = 0, i02_inner, t8216 = 0, i03_inner, t8231 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 30.502100

{ comp03[t8, t9, t10, t11] -> comp03[0, t8305 = 0, i00 = t8, t8307 = 0, i01_outer, t8309 = 0, i02_outer, t8311 = 0, i01_inner, t8302 = 0, i02_inner, t8313 = 0, i03 = t11, t8315 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 101.592003

{ comp03[t8, t9, t10, t11] -> comp03[0, t8385 = 0, i00 = t8, t8387 = 0, i01_outer, t8389 = 0, i02_outer, t8391 = 0, i03_outer, t8393 = 0, i01_inner, t8395 = 0, i02_inner, t8382 = 0, i03_inner, t8397 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 64 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 31.256001

{ comp03[t8, t9, t10, t11] -> comp03[0, t8486 = 0, i00 = t8, t8488 = 0, i01_outer, t8490 = 0, i02_outer, t8492 = 0, i03_outer, t8494 = 0, i01_inner, t8496 = 0, i02_inner, t8483 = 0, i03_inner, t8498 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 46.384998

{ comp03[t8, t9, t10, t11] -> comp03[0, t8572 = 0, i00 = t8, t8574 = 0, i01_outer, t8576 = 0, i02_outer, t8578 = 0, i01_inner, t8569 = 0, i02_inner, t8580 = 0, i03 = t11, t8582 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 178.733002

{ comp03[t8, t9, t10, t11] -> comp03[0, t8652 = 0, i00 = t8, t8654 = 0, i01_outer, t8656 = 0, i02_outer, t8658 = 0, i03_outer, t8660 = 0, i01_inner, t8662 = 0, i02_inner, t8649 = 0, i03_inner, t8664 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 48.476002

{ comp03[t8, t9, t10, t11] -> comp03[0, t8753 = 0, i00 = t8, t8755 = 0, i01_outer, t8757 = 0, i02_outer, t8759 = 0, i03_outer, t8761 = 0, i01_inner, t8763 = 0, i02_inner, t8750 = 0, i03_inner, t8765 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 45.707001

{ comp03[t8, t9, t10, t11] -> comp03[0, t8839 = 0, i00 = t8, t8841 = 0, i01_outer, t8843 = 0, i02_outer, t8845 = 0, i01_inner, t8836 = 0, i02_inner, t8847 = 0, i03 = t11, t8849 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 176.692001

{ comp03[t8, t9, t10, t11] -> comp03[0, t8919 = 0, i00 = t8, t8921 = 0, i01_outer, t8923 = 0, i02_outer, t8925 = 0, i03_outer, t8927 = 0, i01_inner, t8929 = 0, i02_inner, t8916 = 0, i03_inner, t8931 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L1 128 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 48.263100

{ comp03[t8, t9, t10, t11] -> comp03[0, t9020 = 0, i00 = t8, t9022 = 0, i01_outer, t9024 = 0, i02_outer, t9026 = 0, i03_outer, t9028 = 0, i01_inner, t9030 = 0, i02_inner, t9017 = 0, i03_inner, t9032 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 108.552002

{ comp03[t8, t9, t10, t11] -> comp03[0, t9106 = 0, i00 = t8, t9108 = 0, i01 = t9, t9110 = 0, i02_outer, t9112 = 0, i03_outer, t9114 = 0, i02_inner, t9103 = 0, i03_inner, t9116 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 33.237000

{ comp03[t8, t9, t10, t11] -> comp03[0, t9171 = 0, i00 = t8, t9173 = 0, i01 = t9, t9175 = 0, i02_outer, t9177 = 0, i03_outer, t9179 = 0, i02_inner, t9168 = 0, i03_inner, t9181 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 105.678001

{ comp03[t8, t9, t10, t11] -> comp03[0, t9236 = 0, i00 = t8, t9238 = 0, i01 = t9, t9240 = 0, i02_outer, t9242 = 0, i03_outer, t9244 = 0, i02_inner, t9233 = 0, i03_inner, t9246 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 33.631100

{ comp03[t8, t9, t10, t11] -> comp03[0, t9301 = 0, i00 = t8, t9303 = 0, i01 = t9, t9305 = 0, i02_outer, t9307 = 0, i03_outer, t9309 = 0, i02_inner, t9298 = 0, i03_inner, t9311 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
25.844101+25.530100+24.912800+25.410900+26.110901+24.814100+82.007896+45.025101+43.844002+23.870001+26.021000+25.066099+24.643900+44.418098+25.395901+43.334000+45.559898+44.249100+24.329901+26.202000+24.159901+41.753101+26.381001+24.658199+43.200001+45.694099+44.208000+29.886999+102.819000+31.139900+29.771799+100.469002+30.788900+30.538099+104.146004+31.517000+30.502100+101.592003+31.256001+46.384998+178.733002+48.476002+45.707001+176.692001+48.263100+108.552002+33.237000+105.678001+33.631100+31.290100+
remaining list
23.870001+24.159901+24.329901+24.643900+
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L5 4
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 68.651901

{ comp03[t8, t9, t10, t11] -> comp03[0, t5902 = 0, i00_outer, t5904 = 0, i01_outer, t5906 = 0, i00_inner, t5899 = 0, i01_inner, t5908 = 0, i02 = t10, t5910 = 0, i03 = t11, t5912 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L5 8
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 107.572998

{ comp03[t8, t9, t10, t11] -> comp03[0, t5902 = 0, i00_outer, t5904 = 0, i01_outer, t5906 = 0, i00_inner, t5899 = 0, i01_inner, t5908 = 0, i02 = t10, t5910 = 0, i03 = t11, t5912 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 32
Unrolling L5 16
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 42.756100

{ comp03[t8, t9, t10, t11] -> comp03[0, t5902 = 0, i00_outer, t5904 = 0, i01_outer, t5906 = 0, i00_inner, t5899 = 0, i01_inner, t5908 = 0, i02 = t10, t5910 = 0, i03 = t11, t5912 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 64
Unrolling L6 4
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_outer < 32 | 0
							7- for 0 <= i03_inner < 4 | 1
								comp03
Evaluation : 88.939903

{ comp03[t8, t9, t10, t11] -> comp03[0, t6884 = 0, i00_outer, t6886 = 0, i01_outer, t6888 = 0, i02_outer, t6890 = 0, i00_inner, t6892 = 0, i01_inner, t6881 = 0, i02_inner, t6894 = 0, i03 = t11, t6896 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }







comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 64
Unrolling L6 8
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_outer < 16 | 0
							7- for 0 <= i03_inner < 8 | 1
								comp03
Evaluation : 107.662003

{ comp03[t8, t9, t10, t11] -> comp03[0, t6884 = 0, i00_outer, t6886 = 0, i01_outer, t6888 = 0, i02_outer, t6890 = 0, i00_inner, t6892 = 0, i01_inner, t6881 = 0, i02_inner, t6894 = 0, i03 = t11, t6896 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }







comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32 L2 64
Unrolling L6 16
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_outer < 8 | 0
							7- for 0 <= i03_inner < 16 | 1
								comp03
Evaluation : 48.872898

{ comp03[t8, t9, t10, t11] -> comp03[0, t6884 = 0, i00_outer, t6886 = 0, i01_outer, t6888 = 0, i02_outer, t6890 = 0, i00_inner, t6892 = 0, i01_inner, t6881 = 0, i02_inner, t6894 = 0, i03 = t11, t6896 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }







comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L5 4
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 85.043198

{ comp03[t8, t9, t10, t11] -> comp03[0, t6703 = 0, i00_outer, t6705 = 0, i01_outer, t6707 = 0, i00_inner, t6700 = 0, i01_inner, t6709 = 0, i02 = t10, t6711 = 0, i03 = t11, t6713 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L5 8
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 106.787003

{ comp03[t8, t9, t10, t11] -> comp03[0, t6703 = 0, i00_outer, t6705 = 0, i01_outer, t6707 = 0, i00_inner, t6700 = 0, i01_inner, t6709 = 0, i02 = t10, t6711 = 0, i03 = t11, t6713 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 128 L1 32
Unrolling L5 16
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 43.882099

{ comp03[t8, t9, t10, t11] -> comp03[0, t6703 = 0, i00_outer, t6705 = 0, i01_outer, t6707 = 0, i00_inner, t6700 = 0, i01_inner, t6709 = 0, i02 = t10, t6711 = 0, i03 = t11, t6713 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
Unrolling L5 4
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 68.814003

{ comp03[t8, t9, t10, t11] -> comp03[0, t6169 = 0, i00_outer, t6171 = 0, i01_outer, t6173 = 0, i00_inner, t6166 = 0, i01_inner, t6175 = 0, i02 = t10, t6177 = 0, i03 = t11, t6179 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
Unrolling L5 8
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 107.358002

{ comp03[t8, t9, t10, t11] -> comp03[0, t6169 = 0, i00_outer, t6171 = 0, i01_outer, t6173 = 0, i00_inner, t6166 = 0, i01_inner, t6175 = 0, i02 = t10, t6177 = 0, i03 = t11, t6179 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L1
Tiling L0 64 L1 64
Unrolling L5 16
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 42.105000

{ comp03[t8, t9, t10, t11] -> comp03[0, t6169 = 0, i00_outer, t6171 = 0, i01_outer, t6173 = 0, i00_inner, t6166 = 0, i01_inner, t6175 = 0, i02 = t10, t6177 = 0, i03 = t11, t6179 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.738899

{ comp03[t8, t9, t10, t11] -> comp03[0, t10113 = 0, i00_outer, t10115 = 0, i01_outer, t10117 = 0, i00_inner, t10110 = 0, i01_inner, t10119 = 0, i02 = t10, t10121 = 0, i03 = t11, t10123 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 87.565903

{ comp03[t8, t9, t10, t11] -> comp03[0, t10192 = 0, i00_outer, t10194 = 0, i01_outer, t10196 = 0, i02_outer, t10198 = 0, i00_inner, t10200 = 0, i01_inner, t10189 = 0, i02_inner, t10202 = 0, i03 = t11, t10204 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 84.751099

{ comp03[t8, t9, t10, t11] -> comp03[0, t10292 = 0, i00_outer, t10294 = 0, i01_outer, t10296 = 0, i02_outer, t10298 = 0, i00_inner, t10300 = 0, i01_inner, t10289 = 0, i02_inner, t10302 = 0, i03 = t11, t10304 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.291100

{ comp03[t8, t9, t10, t11] -> comp03[0, t10377 = 0, i00_outer, t10379 = 0, i01_outer, t10381 = 0, i00_inner, t10374 = 0, i01_inner, t10383 = 0, i02 = t10, t10385 = 0, i03 = t11, t10387 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 166.597000

{ comp03[t8, t9, t10, t11] -> comp03[0, t10456 = 0, i00_outer, t10458 = 0, i01_outer, t10460 = 0, i02_outer, t10462 = 0, i00_inner, t10464 = 0, i01_inner, t10453 = 0, i02_inner, t10466 = 0, i03 = t11, t10468 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 85.401100

{ comp03[t8, t9, t10, t11] -> comp03[0, t10556 = 0, i00_outer, t10558 = 0, i01_outer, t10560 = 0, i02_outer, t10562 = 0, i00_inner, t10564 = 0, i01_inner, t10553 = 0, i02_inner, t10566 = 0, i03 = t11, t10568 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.323997

{ comp03[t8, t9, t10, t11] -> comp03[0, t10641 = 0, i00_outer, t10643 = 0, i01_outer, t10645 = 0, i00_inner, t10638 = 0, i01_inner, t10647 = 0, i02 = t10, t10649 = 0, i03 = t11, t10651 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 88.106903

{ comp03[t8, t9, t10, t11] -> comp03[0, t10720 = 0, i00_outer, t10722 = 0, i01_outer, t10724 = 0, i02_outer, t10726 = 0, i00_inner, t10728 = 0, i01_inner, t10717 = 0, i02_inner, t10730 = 0, i03 = t11, t10732 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 86.116096

{ comp03[t8, t9, t10, t11] -> comp03[0, t10820 = 0, i00_outer, t10822 = 0, i01_outer, t10824 = 0, i02_outer, t10826 = 0, i00_inner, t10828 = 0, i01_inner, t10817 = 0, i02_inner, t10830 = 0, i03 = t11, t10832 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 181.112000

{ comp03[t8, t9, t10, t11] -> comp03[0, t10905 = 0, i00_outer, t10907 = 0, i01_outer, t10909 = 0, i00_inner, t10902 = 0, i01_inner, t10911 = 0, i02 = t10, t10913 = 0, i03 = t11, t10915 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 87.866997

{ comp03[t8, t9, t10, t11] -> comp03[0, t10984 = 0, i00_outer, t10986 = 0, i01_outer, t10988 = 0, i02_outer, t10990 = 0, i00_inner, t10992 = 0, i01_inner, t10981 = 0, i02_inner, t10994 = 0, i03 = t11, t10996 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 85.652802

{ comp03[t8, t9, t10, t11] -> comp03[0, t11084 = 0, i00_outer, t11086 = 0, i01_outer, t11088 = 0, i02_outer, t11090 = 0, i00_inner, t11092 = 0, i01_inner, t11081 = 0, i02_inner, t11094 = 0, i03 = t11, t11096 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.119003

{ comp03[t8, t9, t10, t11] -> comp03[0, t11169 = 0, i00_outer, t11171 = 0, i01_outer, t11173 = 0, i00_inner, t11166 = 0, i01_inner, t11175 = 0, i02 = t10, t11177 = 0, i03 = t11, t11179 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 88.578903

{ comp03[t8, t9, t10, t11] -> comp03[0, t11248 = 0, i00_outer, t11250 = 0, i01_outer, t11252 = 0, i02_outer, t11254 = 0, i00_inner, t11256 = 0, i01_inner, t11245 = 0, i02_inner, t11258 = 0, i03 = t11, t11260 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 86.637001

{ comp03[t8, t9, t10, t11] -> comp03[0, t11348 = 0, i00_outer, t11350 = 0, i01_outer, t11352 = 0, i02_outer, t11354 = 0, i00_inner, t11356 = 0, i01_inner, t11345 = 0, i02_inner, t11358 = 0, i03 = t11, t11360 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 84.949997

{ comp03[t8, t9, t10, t11] -> comp03[0, t11433 = 0, i00_outer, t11435 = 0, i01_outer, t11437 = 0, i00_inner, t11430 = 0, i01_inner, t11439 = 0, i02 = t10, t11441 = 0, i03 = t11, t11443 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 91.841003

{ comp03[t8, t9, t10, t11] -> comp03[0, t11512 = 0, i00_outer, t11514 = 0, i01_outer, t11516 = 0, i02_outer, t11518 = 0, i00_inner, t11520 = 0, i01_inner, t11509 = 0, i02_inner, t11522 = 0, i03 = t11, t11524 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 85.781097

{ comp03[t8, t9, t10, t11] -> comp03[0, t11612 = 0, i00_outer, t11614 = 0, i01_outer, t11616 = 0, i02_outer, t11618 = 0, i00_inner, t11620 = 0, i01_inner, t11609 = 0, i02_inner, t11622 = 0, i03 = t11, t11624 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.678101

{ comp03[t8, t9, t10, t11] -> comp03[0, t11697 = 0, i00_outer, t11699 = 0, i01_outer, t11701 = 0, i00_inner, t11694 = 0, i01_inner, t11703 = 0, i02 = t10, t11705 = 0, i03 = t11, t11707 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 88.183197

{ comp03[t8, t9, t10, t11] -> comp03[0, t11776 = 0, i00_outer, t11778 = 0, i01_outer, t11780 = 0, i02_outer, t11782 = 0, i00_inner, t11784 = 0, i01_inner, t11773 = 0, i02_inner, t11786 = 0, i03 = t11, t11788 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 85.720100

{ comp03[t8, t9, t10, t11] -> comp03[0, t11876 = 0, i00_outer, t11878 = 0, i01_outer, t11880 = 0, i02_outer, t11882 = 0, i00_inner, t11884 = 0, i01_inner, t11873 = 0, i02_inner, t11886 = 0, i03 = t11, t11888 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.443001

{ comp03[t8, t9, t10, t11] -> comp03[0, t11961 = 0, i00_outer, t11963 = 0, i01_outer, t11965 = 0, i00_inner, t11958 = 0, i01_inner, t11967 = 0, i02 = t10, t11969 = 0, i03 = t11, t11971 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 92.330002

{ comp03[t8, t9, t10, t11] -> comp03[0, t12040 = 0, i00_outer, t12042 = 0, i01_outer, t12044 = 0, i02_outer, t12046 = 0, i00_inner, t12048 = 0, i01_inner, t12037 = 0, i02_inner, t12050 = 0, i03 = t11, t12052 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 86.247902

{ comp03[t8, t9, t10, t11] -> comp03[0, t12140 = 0, i00_outer, t12142 = 0, i01_outer, t12144 = 0, i02_outer, t12146 = 0, i00_inner, t12148 = 0, i01_inner, t12137 = 0, i02_inner, t12150 = 0, i03 = t11, t12152 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.075104

{ comp03[t8, t9, t10, t11] -> comp03[0, t12225 = 0, i00_outer, t12227 = 0, i01_outer, t12229 = 0, i00_inner, t12222 = 0, i01_inner, t12231 = 0, i02 = t10, t12233 = 0, i03 = t11, t12235 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 92.147102

{ comp03[t8, t9, t10, t11] -> comp03[0, t12304 = 0, i00_outer, t12306 = 0, i01_outer, t12308 = 0, i02_outer, t12310 = 0, i00_inner, t12312 = 0, i01_inner, t12301 = 0, i02_inner, t12314 = 0, i03 = t11, t12316 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 86.710899

{ comp03[t8, t9, t10, t11] -> comp03[0, t12404 = 0, i00_outer, t12406 = 0, i01_outer, t12408 = 0, i02_outer, t12410 = 0, i00_inner, t12412 = 0, i01_inner, t12401 = 0, i02_inner, t12414 = 0, i03 = t11, t12416 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 86.483002

{ comp03[t8, t9, t10, t11] -> comp03[0, t12489 = 0, i00 = t8, t12491 = 0, i01_outer, t12493 = 0, i02_outer, t12495 = 0, i01_inner, t12486 = 0, i02_inner, t12497 = 0, i03 = t11, t12499 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 354.153015

{ comp03[t8, t9, t10, t11] -> comp03[0, t12568 = 0, i00 = t8, t12570 = 0, i01_outer, t12572 = 0, i02_outer, t12574 = 0, i03_outer, t12576 = 0, i01_inner, t12578 = 0, i02_inner, t12565 = 0, i03_inner, t12580 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 88.087097

{ comp03[t8, t9, t10, t11] -> comp03[0, t12668 = 0, i00 = t8, t12670 = 0, i01_outer, t12672 = 0, i02_outer, t12674 = 0, i03_outer, t12676 = 0, i01_inner, t12678 = 0, i02_inner, t12665 = 0, i03_inner, t12680 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 84.822197

{ comp03[t8, t9, t10, t11] -> comp03[0, t12753 = 0, i00 = t8, t12755 = 0, i01_outer, t12757 = 0, i02_outer, t12759 = 0, i01_inner, t12750 = 0, i02_inner, t12761 = 0, i03 = t11, t12763 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 353.800995

{ comp03[t8, t9, t10, t11] -> comp03[0, t12832 = 0, i00 = t8, t12834 = 0, i01_outer, t12836 = 0, i02_outer, t12838 = 0, i03_outer, t12840 = 0, i01_inner, t12842 = 0, i02_inner, t12829 = 0, i03_inner, t12844 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 90.763100

{ comp03[t8, t9, t10, t11] -> comp03[0, t12932 = 0, i00 = t8, t12934 = 0, i01_outer, t12936 = 0, i02_outer, t12938 = 0, i03_outer, t12940 = 0, i01_inner, t12942 = 0, i02_inner, t12929 = 0, i03_inner, t12944 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 86.871902

{ comp03[t8, t9, t10, t11] -> comp03[0, t13017 = 0, i00 = t8, t13019 = 0, i01_outer, t13021 = 0, i02_outer, t13023 = 0, i01_inner, t13014 = 0, i02_inner, t13025 = 0, i03 = t11, t13027 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 355.079010

{ comp03[t8, t9, t10, t11] -> comp03[0, t13096 = 0, i00 = t8, t13098 = 0, i01_outer, t13100 = 0, i02_outer, t13102 = 0, i03_outer, t13104 = 0, i01_inner, t13106 = 0, i02_inner, t13093 = 0, i03_inner, t13108 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 87.770897

{ comp03[t8, t9, t10, t11] -> comp03[0, t13196 = 0, i00 = t8, t13198 = 0, i01_outer, t13200 = 0, i02_outer, t13202 = 0, i03_outer, t13204 = 0, i01_inner, t13206 = 0, i02_inner, t13193 = 0, i03_inner, t13208 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 85.412003

{ comp03[t8, t9, t10, t11] -> comp03[0, t13281 = 0, i00 = t8, t13283 = 0, i01_outer, t13285 = 0, i02_outer, t13287 = 0, i01_inner, t13278 = 0, i02_inner, t13289 = 0, i03 = t11, t13291 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 346.433014

{ comp03[t8, t9, t10, t11] -> comp03[0, t13360 = 0, i00 = t8, t13362 = 0, i01_outer, t13364 = 0, i02_outer, t13366 = 0, i03_outer, t13368 = 0, i01_inner, t13370 = 0, i02_inner, t13357 = 0, i03_inner, t13372 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 64 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 90.606903

{ comp03[t8, t9, t10, t11] -> comp03[0, t13460 = 0, i00 = t8, t13462 = 0, i01_outer, t13464 = 0, i02_outer, t13466 = 0, i03_outer, t13468 = 0, i01_inner, t13470 = 0, i02_inner, t13457 = 0, i03_inner, t13472 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 87.059998

{ comp03[t8, t9, t10, t11] -> comp03[0, t13545 = 0, i00 = t8, t13547 = 0, i01_outer, t13549 = 0, i02_outer, t13551 = 0, i01_inner, t13542 = 0, i02_inner, t13553 = 0, i03 = t11, t13555 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 352.712006

{ comp03[t8, t9, t10, t11] -> comp03[0, t13624 = 0, i00 = t8, t13626 = 0, i01_outer, t13628 = 0, i02_outer, t13630 = 0, i03_outer, t13632 = 0, i01_inner, t13634 = 0, i02_inner, t13621 = 0, i03_inner, t13636 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 88.194801

{ comp03[t8, t9, t10, t11] -> comp03[0, t13724 = 0, i00 = t8, t13726 = 0, i01_outer, t13728 = 0, i02_outer, t13730 = 0, i03_outer, t13732 = 0, i01_inner, t13734 = 0, i02_inner, t13721 = 0, i03_inner, t13736 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 86.068199

{ comp03[t8, t9, t10, t11] -> comp03[0, t13809 = 0, i00 = t8, t13811 = 0, i01_outer, t13813 = 0, i02_outer, t13815 = 0, i01_inner, t13806 = 0, i02_inner, t13817 = 0, i03 = t11, t13819 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 344.041992

{ comp03[t8, t9, t10, t11] -> comp03[0, t13888 = 0, i00 = t8, t13890 = 0, i01_outer, t13892 = 0, i02_outer, t13894 = 0, i03_outer, t13896 = 0, i01_inner, t13898 = 0, i02_inner, t13885 = 0, i03_inner, t13900 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 128 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 90.585197

{ comp03[t8, t9, t10, t11] -> comp03[0, t13988 = 0, i00 = t8, t13990 = 0, i01_outer, t13992 = 0, i02_outer, t13994 = 0, i03_outer, t13996 = 0, i01_inner, t13998 = 0, i02_inner, t13985 = 0, i03_inner, t14000 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 359.720001

{ comp03[t8, t9, t10, t11] -> comp03[0, t14073 = 0, i00 = t8, t14075 = 0, i01 = t9, t14077 = 0, i02_outer, t14079 = 0, i03_outer, t14081 = 0, i02_inner, t14070 = 0, i03_inner, t14083 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 4 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 93.239998

{ comp03[t8, t9, t10, t11] -> comp03[0, t14137 = 0, i00 = t8, t14139 = 0, i01 = t9, t14141 = 0, i02_outer, t14143 = 0, i03_outer, t14145 = 0, i02_inner, t14134 = 0, i03_inner, t14147 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 356.157990

{ comp03[t8, t9, t10, t11] -> comp03[0, t14201 = 0, i00 = t8, t14203 = 0, i01 = t9, t14205 = 0, i02_outer, t14207 = 0, i03_outer, t14209 = 0, i02_inner, t14198 = 0, i03_inner, t14211 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 94.447098

{ comp03[t8, t9, t10, t11] -> comp03[0, t14265 = 0, i00 = t8, t14267 = 0, i01 = t9, t14269 = 0, i02_outer, t14271 = 0, i03_outer, t14273 = 0, i02_inner, t14262 = 0, i03_inner, t14275 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
85.738899+87.565903+84.751099+85.291100+166.597000+85.401100+85.323997+88.106903+86.116096+181.112000+87.866997+85.652802+85.119003+88.578903+86.637001+84.949997+91.841003+85.781097+85.678101+88.183197+85.720100+85.443001+92.330002+86.247902+85.075104+92.147102+86.710899+86.483002+354.153015+88.087097+84.822197+353.800995+90.763100+86.871902+355.079010+87.770897+85.412003+346.433014+90.606903+87.059998+352.712006+88.194801+86.068199+344.041992+90.585197+359.720001+93.239998+356.157990+94.447098+93.728996+
remaining list
84.751099+84.822197+84.949997+85.075104+
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 64
Unrolling L6 4
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_outer < 32 | 0
							7- for 0 <= i03_inner < 4 | 1
								comp03
Evaluation : 261.268005

{ comp03[t8, t9, t10, t11] -> comp03[0, t10292 = 0, i00_outer, t10294 = 0, i01_outer, t10296 = 0, i02_outer, t10298 = 0, i00_inner, t10300 = 0, i01_inner, t10289 = 0, i02_inner, t10302 = 0, i03 = t11, t10304 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }







comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 64
Unrolling L6 8
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_outer < 16 | 0
							7- for 0 <= i03_inner < 8 | 1
								comp03
Evaluation : 388.950989

{ comp03[t8, t9, t10, t11] -> comp03[0, t10292 = 0, i00_outer, t10294 = 0, i01_outer, t10296 = 0, i02_outer, t10298 = 0, i00_inner, t10300 = 0, i01_inner, t10289 = 0, i02_inner, t10302 = 0, i03 = t11, t10304 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }







comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 32 L1 32 L2 64
Unrolling L6 16
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_outer < 8 | 0
							7- for 0 <= i03_inner < 16 | 1
								comp03
Evaluation : 147.080002

{ comp03[t8, t9, t10, t11] -> comp03[0, t10292 = 0, i00_outer, t10294 = 0, i01_outer, t10296 = 0, i02_outer, t10298 = 0, i00_inner, t10300 = 0, i01_inner, t10289 = 0, i02_inner, t10302 = 0, i03 = t11, t10304 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }







comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
Unrolling L5 4
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 257.898987

{ comp03[t8, t9, t10, t11] -> comp03[0, t12753 = 0, i00 = t8, t12755 = 0, i01_outer, t12757 = 0, i02_outer, t12759 = 0, i01_inner, t12750 = 0, i02_inner, t12761 = 0, i03 = t11, t12763 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
Unrolling L5 8
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 388.626007

{ comp03[t8, t9, t10, t11] -> comp03[0, t12753 = 0, i00 = t8, t12755 = 0, i01_outer, t12757 = 0, i02_outer, t12759 = 0, i01_inner, t12750 = 0, i02_inner, t12761 = 0, i03 = t11, t12763 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L1 32 L2 64
Unrolling L5 16
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 147.112000

{ comp03[t8, t9, t10, t11] -> comp03[0, t12753 = 0, i00 = t8, t12755 = 0, i01_outer, t12757 = 0, i02_outer, t12759 = 0, i01_inner, t12750 = 0, i02_inner, t12761 = 0, i03 = t11, t12763 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L5 4
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 252.945999

{ comp03[t8, t9, t10, t11] -> comp03[0, t11433 = 0, i00_outer, t11435 = 0, i01_outer, t11437 = 0, i00_inner, t11430 = 0, i01_inner, t11439 = 0, i02 = t10, t11441 = 0, i03 = t11, t11443 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L5 8
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 388.773987

{ comp03[t8, t9, t10, t11] -> comp03[0, t11433 = 0, i00_outer, t11435 = 0, i01_outer, t11437 = 0, i00_inner, t11430 = 0, i01_inner, t11439 = 0, i02 = t10, t11441 = 0, i03 = t11, t11443 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 64 L1 128
Unrolling L5 16
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 148.658997

{ comp03[t8, t9, t10, t11] -> comp03[0, t11433 = 0, i00_outer, t11435 = 0, i01_outer, t11437 = 0, i00_inner, t11430 = 0, i01_inner, t11439 = 0, i02 = t10, t11441 = 0, i03 = t11, t11443 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L5 4
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 254.220993

{ comp03[t8, t9, t10, t11] -> comp03[0, t12225 = 0, i00_outer, t12227 = 0, i01_outer, t12229 = 0, i00_inner, t12222 = 0, i01_inner, t12231 = 0, i02 = t10, t12233 = 0, i03 = t11, t12235 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L5 8
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 387.739990

{ comp03[t8, t9, t10, t11] -> comp03[0, t12225 = 0, i00_outer, t12227 = 0, i01_outer, t12229 = 0, i00_inner, t12222 = 0, i01_inner, t12231 = 0, i02 = t10, t12233 = 0, i03 = t11, t12235 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Tiling L0 128 L1 128
Unrolling L5 16
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 148.681000

{ comp03[t8, t9, t10, t11] -> comp03[0, t12225 = 0, i00_outer, t12227 = 0, i01_outer, t12229 = 0, i00_inner, t12222 = 0, i01_inner, t12231 = 0, i02 = t10, t12233 = 0, i03 = t11, t12235 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      parallel (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 32.130001

{ comp03[t8, t9, t10, t11] -> comp03[0, t15064 = 0, i00_outer, t15066 = 0, i01_outer, t15068 = 0, i00_inner, t15061 = 0, i01_inner, t15070 = 0, i02 = t10, t15072 = 0, i03 = t11, t15074 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      parallel (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.429199

{ comp03[t8, t9, t10, t11] -> comp03[0, t15144 = 0, i00_outer, t15146 = 0, i01_outer, t15148 = 0, i02_outer, t15150 = 0, i00_inner, t15152 = 0, i01_inner, t15141 = 0, i02_inner, t15154 = 0, i03 = t11, t15156 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      parallel (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.396801

{ comp03[t8, t9, t10, t11] -> comp03[0, t15245 = 0, i00_outer, t15247 = 0, i01_outer, t15249 = 0, i02_outer, t15251 = 0, i00_inner, t15253 = 0, i01_inner, t15242 = 0, i02_inner, t15255 = 0, i03 = t11, t15257 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      parallel (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.385000

{ comp03[t8, t9, t10, t11] -> comp03[0, t15331 = 0, i00_outer, t15333 = 0, i01_outer, t15335 = 0, i00_inner, t15328 = 0, i01_inner, t15337 = 0, i02 = t10, t15339 = 0, i03 = t11, t15341 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      parallel (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.662100

{ comp03[t8, t9, t10, t11] -> comp03[0, t15411 = 0, i00_outer, t15413 = 0, i01_outer, t15415 = 0, i02_outer, t15417 = 0, i00_inner, t15419 = 0, i01_inner, t15408 = 0, i02_inner, t15421 = 0, i03 = t11, t15423 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      parallel (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.259998

{ comp03[t8, t9, t10, t11] -> comp03[0, t15512 = 0, i00_outer, t15514 = 0, i01_outer, t15516 = 0, i02_outer, t15518 = 0, i00_inner, t15520 = 0, i01_inner, t15509 = 0, i02_inner, t15522 = 0, i03 = t11, t15524 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.613001

{ comp03[t8, t9, t10, t11] -> comp03[0, t15598 = 0, i00_outer, t15600 = 0, i01_outer, t15602 = 0, i00_inner, t15595 = 0, i01_inner, t15604 = 0, i02 = t10, t15606 = 0, i03 = t11, t15608 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      parallel (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.587000

{ comp03[t8, t9, t10, t11] -> comp03[0, t15678 = 0, i00_outer, t15680 = 0, i01_outer, t15682 = 0, i02_outer, t15684 = 0, i00_inner, t15686 = 0, i01_inner, t15675 = 0, i02_inner, t15688 = 0, i03 = t11, t15690 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      parallel (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.791000

{ comp03[t8, t9, t10, t11] -> comp03[0, t15779 = 0, i00_outer, t15781 = 0, i01_outer, t15783 = 0, i02_outer, t15785 = 0, i00_inner, t15787 = 0, i01_inner, t15776 = 0, i02_inner, t15789 = 0, i03 = t11, t15791 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      parallel (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.814899

{ comp03[t8, t9, t10, t11] -> comp03[0, t15865 = 0, i00_outer, t15867 = 0, i01_outer, t15869 = 0, i00_inner, t15862 = 0, i01_inner, t15871 = 0, i02 = t10, t15873 = 0, i03 = t11, t15875 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      parallel (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 27.205000

{ comp03[t8, t9, t10, t11] -> comp03[0, t15945 = 0, i00_outer, t15947 = 0, i01_outer, t15949 = 0, i02_outer, t15951 = 0, i00_inner, t15953 = 0, i01_inner, t15942 = 0, i02_inner, t15955 = 0, i03 = t11, t15957 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      parallel (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.847000

{ comp03[t8, t9, t10, t11] -> comp03[0, t16046 = 0, i00_outer, t16048 = 0, i01_outer, t16050 = 0, i02_outer, t16052 = 0, i00_inner, t16054 = 0, i01_inner, t16043 = 0, i02_inner, t16056 = 0, i03 = t11, t16058 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      parallel (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 24.121000

{ comp03[t8, t9, t10, t11] -> comp03[0, t16132 = 0, i00_outer, t16134 = 0, i01_outer, t16136 = 0, i00_inner, t16129 = 0, i01_inner, t16138 = 0, i02 = t10, t16140 = 0, i03 = t11, t16142 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      parallel (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.398899

{ comp03[t8, t9, t10, t11] -> comp03[0, t16212 = 0, i00_outer, t16214 = 0, i01_outer, t16216 = 0, i02_outer, t16218 = 0, i00_inner, t16220 = 0, i01_inner, t16209 = 0, i02_inner, t16222 = 0, i03 = t11, t16224 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      parallel (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.142899

{ comp03[t8, t9, t10, t11] -> comp03[0, t16313 = 0, i00_outer, t16315 = 0, i01_outer, t16317 = 0, i02_outer, t16319 = 0, i00_inner, t16321 = 0, i01_inner, t16310 = 0, i02_inner, t16323 = 0, i03 = t11, t16325 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      parallel (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.665001

{ comp03[t8, t9, t10, t11] -> comp03[0, t16399 = 0, i00_outer, t16401 = 0, i01_outer, t16403 = 0, i00_inner, t16396 = 0, i01_inner, t16405 = 0, i02 = t10, t16407 = 0, i03 = t11, t16409 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      parallel (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.321199

{ comp03[t8, t9, t10, t11] -> comp03[0, t16479 = 0, i00_outer, t16481 = 0, i01_outer, t16483 = 0, i02_outer, t16485 = 0, i00_inner, t16487 = 0, i01_inner, t16476 = 0, i02_inner, t16489 = 0, i03 = t11, t16491 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      parallel (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.569000

{ comp03[t8, t9, t10, t11] -> comp03[0, t16580 = 0, i00_outer, t16582 = 0, i01_outer, t16584 = 0, i02_outer, t16586 = 0, i00_inner, t16588 = 0, i01_inner, t16577 = 0, i02_inner, t16590 = 0, i03 = t11, t16592 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      parallel (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.769899

{ comp03[t8, t9, t10, t11] -> comp03[0, t16666 = 0, i00_outer, t16668 = 0, i01_outer, t16670 = 0, i00_inner, t16663 = 0, i01_inner, t16672 = 0, i02 = t10, t16674 = 0, i03 = t11, t16676 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      parallel (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.351000

{ comp03[t8, t9, t10, t11] -> comp03[0, t16746 = 0, i00_outer, t16748 = 0, i01_outer, t16750 = 0, i02_outer, t16752 = 0, i00_inner, t16754 = 0, i01_inner, t16743 = 0, i02_inner, t16756 = 0, i03 = t11, t16758 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      parallel (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.847000

{ comp03[t8, t9, t10, t11] -> comp03[0, t16847 = 0, i00_outer, t16849 = 0, i01_outer, t16851 = 0, i02_outer, t16853 = 0, i00_inner, t16855 = 0, i01_inner, t16844 = 0, i02_inner, t16857 = 0, i03 = t11, t16859 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.165899

{ comp03[t8, t9, t10, t11] -> comp03[0, t16933 = 0, i00_outer, t16935 = 0, i01_outer, t16937 = 0, i00_inner, t16930 = 0, i01_inner, t16939 = 0, i02 = t10, t16941 = 0, i03 = t11, t16943 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      parallel (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 25.618099

{ comp03[t8, t9, t10, t11] -> comp03[0, t17013 = 0, i00_outer, t17015 = 0, i01_outer, t17017 = 0, i02_outer, t17019 = 0, i00_inner, t17021 = 0, i01_inner, t17010 = 0, i02_inner, t17023 = 0, i03 = t11, t17025 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      parallel (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 44.717098

{ comp03[t8, t9, t10, t11] -> comp03[0, t17114 = 0, i00_outer, t17116 = 0, i01_outer, t17118 = 0, i02_outer, t17120 = 0, i00_inner, t17122 = 0, i01_inner, t17111 = 0, i02_inner, t17124 = 0, i03 = t11, t17126 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 23.601999

{ comp03[t8, t9, t10, t11] -> comp03[0, t17200 = 0, i00_outer, t17202 = 0, i01_outer, t17204 = 0, i00_inner, t17197 = 0, i01_inner, t17206 = 0, i02 = t10, t17208 = 0, i03 = t11, t17210 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      parallel (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 26.353800

{ comp03[t8, t9, t10, t11] -> comp03[0, t17280 = 0, i00_outer, t17282 = 0, i01_outer, t17284 = 0, i02_outer, t17286 = 0, i00_inner, t17288 = 0, i01_inner, t17277 = 0, i02_inner, t17290 = 0, i03 = t11, t17292 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      parallel (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03 < 128 | 0
							comp03
Evaluation : 45.154999

{ comp03[t8, t9, t10, t11] -> comp03[0, t17381 = 0, i00_outer, t17383 = 0, i01_outer, t17385 = 0, i02_outer, t17387 = 0, i00_inner, t17389 = 0, i01_inner, t17378 = 0, i02_inner, t17391 = 0, i03 = t11, t17393 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      parallel (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 59.070801

{ comp03[t8, t9, t10, t11] -> comp03[0, t17467 = 0, i00 = t8, t17469 = 0, i01_outer, t17471 = 0, i02_outer, t17473 = 0, i01_inner, t17464 = 0, i02_inner, t17475 = 0, i03 = t11, t17477 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      parallel (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 149.013000

{ comp03[t8, t9, t10, t11] -> comp03[0, t17547 = 0, i00 = t8, t17549 = 0, i01_outer, t17551 = 0, i02_outer, t17553 = 0, i03_outer, t17555 = 0, i01_inner, t17557 = 0, i02_inner, t17544 = 0, i03_inner, t17559 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      parallel (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 58.577099

{ comp03[t8, t9, t10, t11] -> comp03[0, t17648 = 0, i00 = t8, t17650 = 0, i01_outer, t17652 = 0, i02_outer, t17654 = 0, i03_outer, t17656 = 0, i01_inner, t17658 = 0, i02_inner, t17645 = 0, i03_inner, t17660 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      parallel (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 56.674000

{ comp03[t8, t9, t10, t11] -> comp03[0, t17734 = 0, i00 = t8, t17736 = 0, i01_outer, t17738 = 0, i02_outer, t17740 = 0, i01_inner, t17731 = 0, i02_inner, t17742 = 0, i03 = t11, t17744 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      parallel (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 202.451996

{ comp03[t8, t9, t10, t11] -> comp03[0, t17814 = 0, i00 = t8, t17816 = 0, i01_outer, t17818 = 0, i02_outer, t17820 = 0, i03_outer, t17822 = 0, i01_inner, t17824 = 0, i02_inner, t17811 = 0, i03_inner, t17826 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      parallel (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 32 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 60.474899

{ comp03[t8, t9, t10, t11] -> comp03[0, t17915 = 0, i00 = t8, t17917 = 0, i01_outer, t17919 = 0, i02_outer, t17921 = 0, i03_outer, t17923 = 0, i01_inner, t17925 = 0, i02_inner, t17912 = 0, i03_inner, t17927 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      parallel (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 53.618000

{ comp03[t8, t9, t10, t11] -> comp03[0, t18001 = 0, i00 = t8, t18003 = 0, i01_outer, t18005 = 0, i02_outer, t18007 = 0, i01_inner, t17998 = 0, i02_inner, t18009 = 0, i03 = t11, t18011 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      parallel (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 179.701996

{ comp03[t8, t9, t10, t11] -> comp03[0, t18081 = 0, i00 = t8, t18083 = 0, i01_outer, t18085 = 0, i02_outer, t18087 = 0, i03_outer, t18089 = 0, i01_inner, t18091 = 0, i02_inner, t18078 = 0, i03_inner, t18093 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      parallel (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 73.457001

{ comp03[t8, t9, t10, t11] -> comp03[0, t18182 = 0, i00 = t8, t18184 = 0, i01_outer, t18186 = 0, i02_outer, t18188 = 0, i03_outer, t18190 = 0, i01_inner, t18192 = 0, i02_inner, t18179 = 0, i03_inner, t18194 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      parallel (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 50.883099

{ comp03[t8, t9, t10, t11] -> comp03[0, t18268 = 0, i00 = t8, t18270 = 0, i01_outer, t18272 = 0, i02_outer, t18274 = 0, i01_inner, t18265 = 0, i02_inner, t18276 = 0, i03 = t11, t18278 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      parallel (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 194.916000

{ comp03[t8, t9, t10, t11] -> comp03[0, t18348 = 0, i00 = t8, t18350 = 0, i01_outer, t18352 = 0, i02_outer, t18354 = 0, i03_outer, t18356 = 0, i01_inner, t18358 = 0, i02_inner, t18345 = 0, i03_inner, t18360 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      parallel (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 64 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 56.443001

{ comp03[t8, t9, t10, t11] -> comp03[0, t18449 = 0, i00 = t8, t18451 = 0, i01_outer, t18453 = 0, i02_outer, t18455 = 0, i03_outer, t18457 = 0, i01_inner, t18459 = 0, i02_inner, t18446 = 0, i03_inner, t18461 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      parallel (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 36.322800

{ comp03[t8, t9, t10, t11] -> comp03[0, t18535 = 0, i00 = t8, t18537 = 0, i01_outer, t18539 = 0, i02_outer, t18541 = 0, i01_inner, t18532 = 0, i02_inner, t18543 = 0, i03 = t11, t18545 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      parallel (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 120.600998

{ comp03[t8, t9, t10, t11] -> comp03[0, t18615 = 0, i00 = t8, t18617 = 0, i01_outer, t18619 = 0, i02_outer, t18621 = 0, i03_outer, t18623 = 0, i01_inner, t18625 = 0, i02_inner, t18612 = 0, i03_inner, t18627 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      parallel (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 32 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 38.193001

{ comp03[t8, t9, t10, t11] -> comp03[0, t18716 = 0, i00 = t8, t18718 = 0, i01_outer, t18720 = 0, i02_outer, t18722 = 0, i03_outer, t18724 = 0, i01_inner, t18726 = 0, i02_inner, t18713 = 0, i03_inner, t18728 = 0] : (-t10 + i02_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      parallel (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03 < 128 | 0
						comp03
Evaluation : 48.551102

{ comp03[t8, t9, t10, t11] -> comp03[0, t18802 = 0, i00 = t8, t18804 = 0, i01_outer, t18806 = 0, i02_outer, t18808 = 0, i01_inner, t18799 = 0, i02_inner, t18810 = 0, i03 = t11, t18812 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 - i02_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      parallel (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 32 | 0
							comp03
Evaluation : 189.311996

{ comp03[t8, t9, t10, t11] -> comp03[0, t18882 = 0, i00 = t8, t18884 = 0, i01_outer, t18886 = 0, i02_outer, t18888 = 0, i03_outer, t18890 = 0, i01_inner, t18892 = 0, i02_inner, t18879 = 0, i03_inner, t18894 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02 i03  deapth of outer is:1 test : i01 & i02
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      parallel (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L1 128 L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_inner < 64 | 0
						6- for 0 <= i03_inner < 64 | 0
							comp03
Evaluation : 54.202999

{ comp03[t8, t9, t10, t11] -> comp03[0, t18983 = 0, i00 = t8, t18985 = 0, i01_outer, t18987 = 0, i02_outer, t18989 = 0, i03_outer, t18991 = 0, i01_inner, t18993 = 0, i02_inner, t18980 = 0, i03_inner, t18995 = 0] : (-t10 + i02_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      parallel (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 806.250000

{ comp03[t8, t9, t10, t11] -> comp03[0, t19069 = 0, i00 = t8, t19071 = 0, i01 = t9, t19073 = 0, i02_outer, t19075 = 0, i03_outer, t19077 = 0, i02_inner, t19066 = 0, i03_inner, t19079 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      parallel (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L2 32 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 4 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 32 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 665.711975

{ comp03[t8, t9, t10, t11] -> comp03[0, t19134 = 0, i00 = t8, t19136 = 0, i01 = t9, t19138 = 0, i02_outer, t19140 = 0, i03_outer, t19142 = 0, i02_inner, t19131 = 0, i03_inner, t19144 = 0] : (-t10 + i02_inner) mod 32 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 <= 32i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 31 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      parallel (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 4 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 32 | 0
						comp03
Evaluation : 561.620972

{ comp03[t8, t9, t10, t11] -> comp03[0, t19199 = 0, i00 = t8, t19201 = 0, i01 = t9, t19203 = 0, i02_outer, t19205 = 0, i03_outer, t19207 = 0, i02_inner, t19196 = 0, i03_inner, t19209 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -31 + t11 <= 32i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02 i03  deapth of outer is:2 test : i02 & i03
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 256) {
      parallel (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L2 64 L3 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_outer < 2 | 0 | P
			3- for 0 <= i03_outer < 2 | 0
				4- for 0 <= i02_inner < 64 | 0
					5- for 0 <= i03_inner < 64 | 0
						comp03
Evaluation : 385.160004

{ comp03[t8, t9, t10, t11] -> comp03[0, t19264 = 0, i00 = t8, t19266 = 0, i01 = t9, t19268 = 0, i02_outer, t19270 = 0, i03_outer, t19272 = 0, i02_inner, t19261 = 0, i03_inner, t19274 = 0] : (-t10 + i02_inner) mod 64 = 0 and (-t11 + i03_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 <= 64i02_outer <= t10 and -63 + t11 <= 64i03_outer <= t11 and 0 <= i02_inner <= 63 and 0 <= i03_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
32.130001+26.429199+45.396801+24.385000+26.662100+45.259998+23.613001+26.587000+44.791000+23.814899+27.205000+44.847000+24.121000+26.398899+45.142899+23.665001+26.321199+44.569000+23.769899+26.351000+44.847000+23.165899+25.618099+44.717098+23.601999+26.353800+45.154999+59.070801+149.013000+58.577099+56.674000+202.451996+60.474899+53.618000+179.701996+73.457001+50.883099+194.916000+56.443001+36.322800+120.600998+38.193001+48.551102+189.311996+54.202999+806.250000+665.711975+561.620972+385.160004+1792.680054+
remaining list
23.165899+23.601999+23.613001+23.665001+
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
Unrolling L5 4
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 68.203003

{ comp03[t8, t9, t10, t11] -> comp03[0, t16933 = 0, i00_outer, t16935 = 0, i01_outer, t16937 = 0, i00_inner, t16930 = 0, i01_inner, t16939 = 0, i02 = t10, t16941 = 0, i03 = t11, t16943 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
Unrolling L5 8
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 106.213997

{ comp03[t8, t9, t10, t11] -> comp03[0, t16933 = 0, i00_outer, t16935 = 0, i01_outer, t16937 = 0, i00_inner, t16930 = 0, i01_inner, t16939 = 0, i02 = t10, t16941 = 0, i03 = t11, t16943 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      parallel (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 64
Unrolling L5 16
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 47.977001

{ comp03[t8, t9, t10, t11] -> comp03[0, t16933 = 0, i00_outer, t16935 = 0, i01_outer, t16937 = 0, i00_inner, t16930 = 0, i01_inner, t16939 = 0, i02 = t10, t16941 = 0, i03 = t11, t16943 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128
Unrolling L5 4
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 69.382896

{ comp03[t8, t9, t10, t11] -> comp03[0, t17200 = 0, i00_outer, t17202 = 0, i01_outer, t17204 = 0, i00_inner, t17197 = 0, i01_inner, t17206 = 0, i02 = t10, t17208 = 0, i03 = t11, t17210 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128
Unrolling L5 8
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 106.008003

{ comp03[t8, t9, t10, t11] -> comp03[0, t17200 = 0, i00_outer, t17202 = 0, i01_outer, t17204 = 0, i00_inner, t17197 = 0, i01_inner, t17206 = 0, i02 = t10, t17208 = 0, i03 = t11, t17210 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      parallel (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 128 L1 128
Unrolling L5 16
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 41.126999

{ comp03[t8, t9, t10, t11] -> comp03[0, t17200 = 0, i00_outer, t17202 = 0, i01_outer, t17204 = 0, i00_inner, t17197 = 0, i01_inner, t17206 = 0, i02 = t10, t17208 = 0, i03 = t11, t17210 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128
Unrolling L5 4
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 69.045097

{ comp03[t8, t9, t10, t11] -> comp03[0, t15598 = 0, i00_outer, t15600 = 0, i01_outer, t15602 = 0, i00_inner, t15595 = 0, i01_inner, t15604 = 0, i02 = t10, t15606 = 0, i03 = t11, t15608 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128
Unrolling L5 8
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 107.817001

{ comp03[t8, t9, t10, t11] -> comp03[0, t15598 = 0, i00_outer, t15600 = 0, i01_outer, t15602 = 0, i00_inner, t15595 = 0, i01_inner, t15604 = 0, i02 = t10, t15606 = 0, i03 = t11, t15608 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      parallel (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 32 L1 128
Unrolling L5 16
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 40.696098

{ comp03[t8, t9, t10, t11] -> comp03[0, t15598 = 0, i00_outer, t15600 = 0, i01_outer, t15602 = 0, i00_inner, t15595 = 0, i01_inner, t15604 = 0, i02 = t10, t15606 = 0, i03 = t11, t15608 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      parallel (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128
Unrolling L5 4
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 32 | 0
						6- for 0 <= i03_inner < 4 | 1
							comp03
Evaluation : 68.882896

{ comp03[t8, t9, t10, t11] -> comp03[0, t16399 = 0, i00_outer, t16401 = 0, i01_outer, t16403 = 0, i00_inner, t16396 = 0, i01_inner, t16405 = 0, i02 = t10, t16407 = 0, i03 = t11, t16409 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      parallel (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128
Unrolling L5 8
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 16 | 0
						6- for 0 <= i03_inner < 8 | 1
							comp03
Evaluation : 106.967003

{ comp03[t8, t9, t10, t11] -> comp03[0, t16399 = 0, i00_outer, t16401 = 0, i01_outer, t16403 = 0, i00_inner, t16396 = 0, i01_inner, t16405 = 0, i02 = t10, t16407 = 0, i03 = t11, t16409 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      parallel (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Parallelize L2
Tiling L0 64 L1 128
Unrolling L5 16
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02 < 128 | 0 | P
					5- for 0 <= i03_outer < 8 | 0
						6- for 0 <= i03_inner < 16 | 1
							comp03
Evaluation : 40.988899

{ comp03[t8, t9, t10, t11] -> comp03[0, t16399 = 0, i00_outer, t16401 = 0, i01_outer, t16403 = 0, i00_inner, t16396 = 0, i01_inner, t16405 = 0, i02 = t10, t16407 = 0, i03 = t11, t16409 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 255) {
        for (c7, max((c5 + -127), 0), ((min(c5, 127) - max((c5 + -127), 0)) + 1)) {
          buf03[(((c5 - c7) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((c5 - c7) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64((c5 - c7))*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_1 < 255 | 0
			3- for 0 <= i03_skew < 65 | 0
				comp03
Evaluation : 272.011993

{ comp03[t8, t9, t10, t11] -> comp03[t107 = 0, t108 = 0, i00 = t8, t110 = 0, i01 = t9, t112 = 0, i02_skew_1_1 = t10 + t11, t114 = 0, i03_skew = t11, t116 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 255) {
        for (c7, max((c5 + -127), 0), ((min(c5, 127) - max((c5 + -127), 0)) + 1)) {
          buf03[(((c5 - c7) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((c5 - c7) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64((c5 - c7))*(int64)128)))]))
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_skew_1_1 < 255 | 0
			3- for 0 <= i03_skew < 65 | 0
				comp03
Evaluation : 298.441010

{ comp03[t8, t9, t10, t11] -> comp03[t107 = 0, t108 = 0, i00 = t8, t110 = 0, i01 = t9, t112 = 0, i02_skew_1_1 = t10 + t11, t114 = 0, i03_skew = t11, t116 = 0] : 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 }



comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
272.011993+298.441010+1045.750000+
remaining list
272.011993+298.441010+1045.750000+ Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 278.066010

{ comp03[t8, t9, t10, t11] -> comp03[0, t20047 = 0, i00_outer, t20049 = 0, i01_outer, t20051 = 0, i00_inner, t20044 = 0, i01_inner, t20053 = 0, i02_skew_1_1 = t10 + t11, t20055 = 0, i03_skew = t11, t20057 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 280.601990

{ comp03[t8, t9, t10, t11] -> comp03[0, t20140 = 0, i00_outer, t20142 = 0, i01_outer, t20144 = 0, i02_skew_1_1_outer, t20146 = 0, i00_inner, t20148 = 0, i01_inner, t20137 = 0, i02_skew_1_1_inner, t20150 = 0, i03_skew = t11, t20152 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 289.096008

{ comp03[t8, t9, t10, t11] -> comp03[0, t20254 = 0, i00_outer, t20256 = 0, i01_outer, t20258 = 0, i02_skew_1_1_outer, t20260 = 0, i00_inner, t20262 = 0, i01_inner, t20251 = 0, i02_skew_1_1_inner, t20264 = 0, i03_skew = t11, t20266 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 274.169006

{ comp03[t8, t9, t10, t11] -> comp03[0, t20368 = 0, i00_outer, t20370 = 0, i01_outer, t20372 = 0, i02_skew_1_1_outer, t20374 = 0, i00_inner, t20376 = 0, i01_inner, t20365 = 0, i02_skew_1_1_inner, t20378 = 0, i03_skew = t11, t20380 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 278.191986

{ comp03[t8, t9, t10, t11] -> comp03[0, t20467 = 0, i00_outer, t20469 = 0, i01_outer, t20471 = 0, i00_inner, t20464 = 0, i01_inner, t20473 = 0, i02_skew_1_1 = t10 + t11, t20475 = 0, i03_skew = t11, t20477 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 282.544006

{ comp03[t8, t9, t10, t11] -> comp03[0, t20560 = 0, i00_outer, t20562 = 0, i01_outer, t20564 = 0, i02_skew_1_1_outer, t20566 = 0, i00_inner, t20568 = 0, i01_inner, t20557 = 0, i02_skew_1_1_inner, t20570 = 0, i03_skew = t11, t20572 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 290.248993

{ comp03[t8, t9, t10, t11] -> comp03[0, t20674 = 0, i00_outer, t20676 = 0, i01_outer, t20678 = 0, i02_skew_1_1_outer, t20680 = 0, i00_inner, t20682 = 0, i01_inner, t20671 = 0, i02_skew_1_1_inner, t20684 = 0, i03_skew = t11, t20686 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 275.153992

{ comp03[t8, t9, t10, t11] -> comp03[0, t20788 = 0, i00_outer, t20790 = 0, i01_outer, t20792 = 0, i02_skew_1_1_outer, t20794 = 0, i00_inner, t20796 = 0, i01_inner, t20785 = 0, i02_skew_1_1_inner, t20798 = 0, i03_skew = t11, t20800 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 278.813995

{ comp03[t8, t9, t10, t11] -> comp03[0, t20887 = 0, i00_outer, t20889 = 0, i01_outer, t20891 = 0, i00_inner, t20884 = 0, i01_inner, t20893 = 0, i02_skew_1_1 = t10 + t11, t20895 = 0, i03_skew = t11, t20897 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 282.144012

{ comp03[t8, t9, t10, t11] -> comp03[0, t20980 = 0, i00_outer, t20982 = 0, i01_outer, t20984 = 0, i02_skew_1_1_outer, t20986 = 0, i00_inner, t20988 = 0, i01_inner, t20977 = 0, i02_skew_1_1_inner, t20990 = 0, i03_skew = t11, t20992 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 288.389008

{ comp03[t8, t9, t10, t11] -> comp03[0, t21094 = 0, i00_outer, t21096 = 0, i01_outer, t21098 = 0, i02_skew_1_1_outer, t21100 = 0, i00_inner, t21102 = 0, i01_inner, t21091 = 0, i02_skew_1_1_inner, t21104 = 0, i03_skew = t11, t21106 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 8 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 289.472992

{ comp03[t8, t9, t10, t11] -> comp03[0, t21208 = 0, i00_outer, t21210 = 0, i01_outer, t21212 = 0, i02_skew_1_1_outer, t21214 = 0, i00_inner, t21216 = 0, i01_inner, t21205 = 0, i02_skew_1_1_inner, t21218 = 0, i03_skew = t11, t21220 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 280.195007

{ comp03[t8, t9, t10, t11] -> comp03[0, t21307 = 0, i00_outer, t21309 = 0, i01_outer, t21311 = 0, i00_inner, t21304 = 0, i01_inner, t21313 = 0, i02_skew_1_1 = t10 + t11, t21315 = 0, i03_skew = t11, t21317 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 282.908997

{ comp03[t8, t9, t10, t11] -> comp03[0, t21400 = 0, i00_outer, t21402 = 0, i01_outer, t21404 = 0, i02_skew_1_1_outer, t21406 = 0, i00_inner, t21408 = 0, i01_inner, t21397 = 0, i02_skew_1_1_inner, t21410 = 0, i03_skew = t11, t21412 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 292.096985

{ comp03[t8, t9, t10, t11] -> comp03[0, t21514 = 0, i00_outer, t21516 = 0, i01_outer, t21518 = 0, i02_skew_1_1_outer, t21520 = 0, i00_inner, t21522 = 0, i01_inner, t21511 = 0, i02_skew_1_1_inner, t21524 = 0, i03_skew = t11, t21526 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 274.114014

{ comp03[t8, t9, t10, t11] -> comp03[0, t21628 = 0, i00_outer, t21630 = 0, i01_outer, t21632 = 0, i02_skew_1_1_outer, t21634 = 0, i00_inner, t21636 = 0, i01_inner, t21625 = 0, i02_skew_1_1_inner, t21638 = 0, i03_skew = t11, t21640 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 279.062012

{ comp03[t8, t9, t10, t11] -> comp03[0, t21727 = 0, i00_outer, t21729 = 0, i01_outer, t21731 = 0, i00_inner, t21724 = 0, i01_inner, t21733 = 0, i02_skew_1_1 = t10 + t11, t21735 = 0, i03_skew = t11, t21737 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 283.532013

{ comp03[t8, t9, t10, t11] -> comp03[0, t21820 = 0, i00_outer, t21822 = 0, i01_outer, t21824 = 0, i02_skew_1_1_outer, t21826 = 0, i00_inner, t21828 = 0, i01_inner, t21817 = 0, i02_skew_1_1_inner, t21830 = 0, i03_skew = t11, t21832 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 289.776001

{ comp03[t8, t9, t10, t11] -> comp03[0, t21934 = 0, i00_outer, t21936 = 0, i01_outer, t21938 = 0, i02_skew_1_1_outer, t21940 = 0, i00_inner, t21942 = 0, i01_inner, t21931 = 0, i02_skew_1_1_inner, t21944 = 0, i03_skew = t11, t21946 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 274.127014

{ comp03[t8, t9, t10, t11] -> comp03[0, t22048 = 0, i00_outer, t22050 = 0, i01_outer, t22052 = 0, i02_skew_1_1_outer, t22054 = 0, i00_inner, t22056 = 0, i01_inner, t22045 = 0, i02_skew_1_1_inner, t22058 = 0, i03_skew = t11, t22060 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 279.463013

{ comp03[t8, t9, t10, t11] -> comp03[0, t22147 = 0, i00_outer, t22149 = 0, i01_outer, t22151 = 0, i00_inner, t22144 = 0, i01_inner, t22153 = 0, i02_skew_1_1 = t10 + t11, t22155 = 0, i03_skew = t11, t22157 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 281.997986

{ comp03[t8, t9, t10, t11] -> comp03[0, t22240 = 0, i00_outer, t22242 = 0, i01_outer, t22244 = 0, i02_skew_1_1_outer, t22246 = 0, i00_inner, t22248 = 0, i01_inner, t22237 = 0, i02_skew_1_1_inner, t22250 = 0, i03_skew = t11, t22252 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 300.833008

{ comp03[t8, t9, t10, t11] -> comp03[0, t22354 = 0, i00_outer, t22356 = 0, i01_outer, t22358 = 0, i02_skew_1_1_outer, t22360 = 0, i00_inner, t22362 = 0, i01_inner, t22351 = 0, i02_skew_1_1_inner, t22364 = 0, i03_skew = t11, t22366 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 4 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 294.367004

{ comp03[t8, t9, t10, t11] -> comp03[0, t22468 = 0, i00_outer, t22470 = 0, i01_outer, t22472 = 0, i02_skew_1_1_outer, t22474 = 0, i00_inner, t22476 = 0, i01_inner, t22465 = 0, i02_skew_1_1_inner, t22478 = 0, i03_skew = t11, t22480 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 513.023987

{ comp03[t8, t9, t10, t11] -> comp03[0, t22567 = 0, i00_outer, t22569 = 0, i01_outer, t22571 = 0, i00_inner, t22564 = 0, i01_inner, t22573 = 0, i02_skew_1_1 = t10 + t11, t22575 = 0, i03_skew = t11, t22577 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 515.846008

{ comp03[t8, t9, t10, t11] -> comp03[0, t22660 = 0, i00_outer, t22662 = 0, i01_outer, t22664 = 0, i02_skew_1_1_outer, t22666 = 0, i00_inner, t22668 = 0, i01_inner, t22657 = 0, i02_skew_1_1_inner, t22670 = 0, i03_skew = t11, t22672 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 531.807983

{ comp03[t8, t9, t10, t11] -> comp03[0, t22774 = 0, i00_outer, t22776 = 0, i01_outer, t22778 = 0, i02_skew_1_1_outer, t22780 = 0, i00_inner, t22782 = 0, i01_inner, t22771 = 0, i02_skew_1_1_inner, t22784 = 0, i03_skew = t11, t22786 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 505.341003

{ comp03[t8, t9, t10, t11] -> comp03[0, t22888 = 0, i00_outer, t22890 = 0, i01_outer, t22892 = 0, i02_skew_1_1_outer, t22894 = 0, i00_inner, t22896 = 0, i01_inner, t22885 = 0, i02_skew_1_1_inner, t22898 = 0, i03_skew = t11, t22900 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 514.799011

{ comp03[t8, t9, t10, t11] -> comp03[0, t22987 = 0, i00_outer, t22989 = 0, i01_outer, t22991 = 0, i00_inner, t22984 = 0, i01_inner, t22993 = 0, i02_skew_1_1 = t10 + t11, t22995 = 0, i03_skew = t11, t22997 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 517.601013

{ comp03[t8, t9, t10, t11] -> comp03[0, t23080 = 0, i00_outer, t23082 = 0, i01_outer, t23084 = 0, i02_skew_1_1_outer, t23086 = 0, i00_inner, t23088 = 0, i01_inner, t23077 = 0, i02_skew_1_1_inner, t23090 = 0, i03_skew = t11, t23092 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 531.330017

{ comp03[t8, t9, t10, t11] -> comp03[0, t23194 = 0, i00_outer, t23196 = 0, i01_outer, t23198 = 0, i02_skew_1_1_outer, t23200 = 0, i00_inner, t23202 = 0, i01_inner, t23191 = 0, i02_skew_1_1_inner, t23204 = 0, i03_skew = t11, t23206 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 533.838989

{ comp03[t8, t9, t10, t11] -> comp03[0, t23308 = 0, i00_outer, t23310 = 0, i01_outer, t23312 = 0, i02_skew_1_1_outer, t23314 = 0, i00_inner, t23316 = 0, i01_inner, t23305 = 0, i02_skew_1_1_inner, t23318 = 0, i03_skew = t11, t23320 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 546.096985

{ comp03[t8, t9, t10, t11] -> comp03[0, t23407 = 0, i00_outer, t23409 = 0, i01_outer, t23411 = 0, i00_inner, t23404 = 0, i01_inner, t23413 = 0, i02_skew_1_1 = t10 + t11, t23415 = 0, i03_skew = t11, t23417 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 530.130981

{ comp03[t8, t9, t10, t11] -> comp03[0, t23500 = 0, i00_outer, t23502 = 0, i01_outer, t23504 = 0, i02_skew_1_1_outer, t23506 = 0, i00_inner, t23508 = 0, i01_inner, t23497 = 0, i02_skew_1_1_inner, t23510 = 0, i03_skew = t11, t23512 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 533.797974

{ comp03[t8, t9, t10, t11] -> comp03[0, t23614 = 0, i00_outer, t23616 = 0, i01_outer, t23618 = 0, i02_skew_1_1_outer, t23620 = 0, i00_inner, t23622 = 0, i01_inner, t23611 = 0, i02_skew_1_1_inner, t23624 = 0, i03_skew = t11, t23626 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 2 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 563.187012

{ comp03[t8, t9, t10, t11] -> comp03[0, t23728 = 0, i00_outer, t23730 = 0, i01_outer, t23732 = 0, i02_skew_1_1_outer, t23734 = 0, i00_inner, t23736 = 0, i01_inner, t23725 = 0, i02_skew_1_1_inner, t23738 = 0, i03_skew = t11, t23740 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 318.643005

{ comp03[t8, t9, t10, t11] -> comp03[0, t23827 = 0, i00 = t8, t23829 = 0, i01_outer, t23831 = 0, i02_skew_1_1_outer, t23833 = 0, i01_inner, t23824 = 0, i02_skew_1_1_inner, t23835 = 0, i03_skew = t11, t23837 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 32) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 310.523987

{ comp03[t8, t9, t10, t11] -> comp03[0, t23920 = 0, i00 = t8, t23922 = 0, i01_outer, t23924 = 0, i02_skew_1_1_outer, t23926 = 0, i03_skew_outer, t23928 = 0, i01_inner, t23930 = 0, i02_skew_1_1_inner, t23917 = 0, i03_skew_inner, t23932 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 288.747986

{ comp03[t8, t9, t10, t11] -> comp03[0, t24019 = 0, i00 = t8, t24021 = 0, i01_outer, t24023 = 0, i02_skew_1_1_outer, t24025 = 0, i01_inner, t24016 = 0, i02_skew_1_1_inner, t24027 = 0, i03_skew = t11, t24029 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 32) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 334.838989

{ comp03[t8, t9, t10, t11] -> comp03[0, t24112 = 0, i00 = t8, t24114 = 0, i01_outer, t24116 = 0, i02_skew_1_1_outer, t24118 = 0, i03_skew_outer, t24120 = 0, i01_inner, t24122 = 0, i02_skew_1_1_inner, t24109 = 0, i03_skew_inner, t24124 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 32 L2 128
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 288.239990

{ comp03[t8, t9, t10, t11] -> comp03[0, t24211 = 0, i00 = t8, t24213 = 0, i01_outer, t24215 = 0, i02_skew_1_1_outer, t24217 = 0, i01_inner, t24208 = 0, i02_skew_1_1_inner, t24219 = 0, i03_skew = t11, t24221 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 32 L2 128 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 335.036987

{ comp03[t8, t9, t10, t11] -> comp03[0, t24304 = 0, i00 = t8, t24306 = 0, i01_outer, t24308 = 0, i02_skew_1_1_outer, t24310 = 0, i03_skew_outer, t24312 = 0, i01_inner, t24314 = 0, i02_skew_1_1_inner, t24301 = 0, i03_skew_inner, t24316 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 412.664001

{ comp03[t8, t9, t10, t11] -> comp03[0, t24403 = 0, i00 = t8, t24405 = 0, i01_outer, t24407 = 0, i02_skew_1_1_outer, t24409 = 0, i01_inner, t24400 = 0, i02_skew_1_1_inner, t24411 = 0, i03_skew = t11, t24413 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 64) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 429.781006

{ comp03[t8, t9, t10, t11] -> comp03[0, t24496 = 0, i00 = t8, t24498 = 0, i01_outer, t24500 = 0, i02_skew_1_1_outer, t24502 = 0, i03_skew_outer, t24504 = 0, i01_inner, t24506 = 0, i02_skew_1_1_inner, t24493 = 0, i03_skew_inner, t24508 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 360.359985

{ comp03[t8, t9, t10, t11] -> comp03[0, t24595 = 0, i00 = t8, t24597 = 0, i01_outer, t24599 = 0, i02_skew_1_1_outer, t24601 = 0, i01_inner, t24592 = 0, i02_skew_1_1_inner, t24603 = 0, i03_skew = t11, t24605 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 64) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 409.234009

{ comp03[t8, t9, t10, t11] -> comp03[0, t24688 = 0, i00 = t8, t24690 = 0, i01_outer, t24692 = 0, i02_skew_1_1_outer, t24694 = 0, i03_skew_outer, t24696 = 0, i01_inner, t24698 = 0, i02_skew_1_1_inner, t24685 = 0, i03_skew_inner, t24700 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 64 L2 128
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 380.217987

{ comp03[t8, t9, t10, t11] -> comp03[0, t24787 = 0, i00 = t8, t24789 = 0, i01_outer, t24791 = 0, i02_skew_1_1_outer, t24793 = 0, i01_inner, t24784 = 0, i02_skew_1_1_inner, t24795 = 0, i03_skew = t11, t24797 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 64 L2 128 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 455.674011

{ comp03[t8, t9, t10, t11] -> comp03[0, t24880 = 0, i00 = t8, t24882 = 0, i01_outer, t24884 = 0, i02_skew_1_1_outer, t24886 = 0, i03_skew_outer, t24888 = 0, i01_inner, t24890 = 0, i02_skew_1_1_inner, t24877 = 0, i03_skew_inner, t24892 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 312.842010

{ comp03[t8, t9, t10, t11] -> comp03[0, t24979 = 0, i00 = t8, t24981 = 0, i01_outer, t24983 = 0, i02_skew_1_1_outer, t24985 = 0, i01_inner, t24976 = 0, i02_skew_1_1_inner, t24987 = 0, i03_skew = t11, t24989 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 128) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 352.009003

{ comp03[t8, t9, t10, t11] -> comp03[0, t25072 = 0, i00 = t8, t25074 = 0, i01_outer, t25076 = 0, i02_skew_1_1_outer, t25078 = 0, i03_skew_outer, t25080 = 0, i01_inner, t25082 = 0, i02_skew_1_1_inner, t25069 = 0, i03_skew_inner, t25084 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 359.852997

{ comp03[t8, t9, t10, t11] -> comp03[0, t25171 = 0, i00 = t8, t25173 = 0, i01_outer, t25175 = 0, i02_skew_1_1_outer, t25177 = 0, i01_inner, t25168 = 0, i02_skew_1_1_inner, t25179 = 0, i03_skew = t11, t25181 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 128) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 128 L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 421.963013

{ comp03[t8, t9, t10, t11] -> comp03[0, t25264 = 0, i00 = t8, t25266 = 0, i01_outer, t25268 = 0, i02_skew_1_1_outer, t25270 = 0, i03_skew_outer, t25272 = 0, i01_inner, t25274 = 0, i02_skew_1_1_inner, t25261 = 0, i03_skew_inner, t25276 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 128 L2 128
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 281.354004

{ comp03[t8, t9, t10, t11] -> comp03[0, t25363 = 0, i00 = t8, t25365 = 0, i01_outer, t25367 = 0, i02_skew_1_1_outer, t25369 = 0, i01_inner, t25360 = 0, i02_skew_1_1_inner, t25371 = 0, i03_skew = t11, t25373 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L1 128 L2 128 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 410.338013

{ comp03[t8, t9, t10, t11] -> comp03[0, t25456 = 0, i00 = t8, t25458 = 0, i01_outer, t25460 = 0, i02_skew_1_1_outer, t25462 = 0, i03_skew_outer, t25464 = 0, i01_inner, t25466 = 0, i02_skew_1_1_inner, t25453 = 0, i03_skew_inner, t25468 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:2 test : i02_skew_1_1 & i03_skew
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
            for (c11, max(((((c5 - c7)*32) + c9) + -127), 0), ((min((((c5 - c7)*32) + c9), 31) - max(((((c5 - c7)*32) + c9) + -127), 0)) + 1)) {
              buf03[((((((c5 - c7)*32) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((((c5 - c7)*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L2 32 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew_inner < 32 | 0
						comp03
Evaluation : 410.899994

{ comp03[t8, t9, t10, t11] -> comp03[0, t25555 = 0, i00 = t8, t25557 = 0, i01 = t9, t25559 = 0, i02_skew_1_1_outer, t25561 = 0, i03_skew_outer, t25563 = 0, i02_skew_1_1_inner, t25552 = 0, i03_skew_inner, t25565 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:2 test : i02_skew_1_1 & i03_skew
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
            for (c11, max(((((c5*64) - (c7*32)) + c9) + -127), 0), ((min((((c5*64) - (c7*32)) + c9), 31) - max(((((c5*64) - (c7*32)) + c9) + -127), 0)) + 1)) {
              buf03[((((((c5*64) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((((c5*64) - (c7*32)) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L2 64 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew_inner < 32 | 0
						comp03
Evaluation : 398.493011

{ comp03[t8, t9, t10, t11] -> comp03[0, t25633 = 0, i00 = t8, t25635 = 0, i01 = t9, t25637 = 0, i02_skew_1_1_outer, t25639 = 0, i03_skew_outer, t25641 = 0, i02_skew_1_1_inner, t25630 = 0, i03_skew_inner, t25643 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:2 test : i02_skew_1_1 & i03_skew
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
            for (c11, max(((((c5*128) - (c7*32)) + c9) + -127), 0), ((min((((c5*128) - (c7*32)) + c9), 31) - max(((((c5*128) - (c7*32)) + c9) + -127), 0)) + 1)) {
              buf03[((((((c5*128) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((((c5*128) - (c7*32)) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L0
Tiling L2 128 L3 32
0- for 0 <= i00 < 256 | 0 | P
	1- for 0 <= i01 < 256 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew_inner < 32 | 0
						comp03
Evaluation : 316.214996

{ comp03[t8, t9, t10, t11] -> comp03[0, t25711 = 0, i00 = t8, t25713 = 0, i01 = t9, t25715 = 0, i02_skew_1_1_outer, t25717 = 0, i03_skew_outer, t25719 = 0, i02_skew_1_1_inner, t25708 = 0, i03_skew_inner, t25721 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
278.066010+280.601990+289.096008+274.169006+278.191986+282.544006+290.248993+275.153992+278.813995+282.144012+288.389008+289.472992+280.195007+282.908997+292.096985+274.114014+279.062012+283.532013+289.776001+274.127014+279.463013+281.997986+300.833008+294.367004+513.023987+515.846008+531.807983+505.341003+514.799011+517.601013+531.330017+533.838989+546.096985+530.130981+533.797974+563.187012+318.643005+310.523987+288.747986+334.838989+288.239990+335.036987+412.664001+429.781006+360.359985+409.234009+380.217987+455.674011+312.842010+352.009003+359.852997+421.963013+281.354004+410.338013+410.899994+398.493011+316.214996+272.011993+
remaining list
272.011993+274.114014+274.127014+274.169006+ Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 381.759003

{ comp03[t8, t9, t10, t11] -> comp03[0, t25789 = 0, i00_outer, t25791 = 0, i01_outer, t25793 = 0, i00_inner, t25786 = 0, i01_inner, t25795 = 0, i02_skew_1_1 = t10 + t11, t25797 = 0, i03_skew = t11, t25799 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 373.467987

{ comp03[t8, t9, t10, t11] -> comp03[0, t25882 = 0, i00_outer, t25884 = 0, i01_outer, t25886 = 0, i02_skew_1_1_outer, t25888 = 0, i00_inner, t25890 = 0, i01_inner, t25879 = 0, i02_skew_1_1_inner, t25892 = 0, i03_skew = t11, t25894 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 378.294006

{ comp03[t8, t9, t10, t11] -> comp03[0, t25996 = 0, i00_outer, t25998 = 0, i01_outer, t26000 = 0, i02_skew_1_1_outer, t26002 = 0, i00_inner, t26004 = 0, i01_inner, t25993 = 0, i02_skew_1_1_inner, t26006 = 0, i03_skew = t11, t26008 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 386.260010

{ comp03[t8, t9, t10, t11] -> comp03[0, t26110 = 0, i00_outer, t26112 = 0, i01_outer, t26114 = 0, i02_skew_1_1_outer, t26116 = 0, i00_inner, t26118 = 0, i01_inner, t26107 = 0, i02_skew_1_1_inner, t26120 = 0, i03_skew = t11, t26122 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 332.062012

{ comp03[t8, t9, t10, t11] -> comp03[0, t26209 = 0, i00_outer, t26211 = 0, i01_outer, t26213 = 0, i00_inner, t26206 = 0, i01_inner, t26215 = 0, i02_skew_1_1 = t10 + t11, t26217 = 0, i03_skew = t11, t26219 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 341.028015

{ comp03[t8, t9, t10, t11] -> comp03[0, t26302 = 0, i00_outer, t26304 = 0, i01_outer, t26306 = 0, i02_skew_1_1_outer, t26308 = 0, i00_inner, t26310 = 0, i01_inner, t26299 = 0, i02_skew_1_1_inner, t26312 = 0, i03_skew = t11, t26314 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 340.197998

{ comp03[t8, t9, t10, t11] -> comp03[0, t26416 = 0, i00_outer, t26418 = 0, i01_outer, t26420 = 0, i02_skew_1_1_outer, t26422 = 0, i00_inner, t26424 = 0, i01_inner, t26413 = 0, i02_skew_1_1_inner, t26426 = 0, i03_skew = t11, t26428 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 341.196014

{ comp03[t8, t9, t10, t11] -> comp03[0, t26530 = 0, i00_outer, t26532 = 0, i01_outer, t26534 = 0, i02_skew_1_1_outer, t26536 = 0, i00_inner, t26538 = 0, i01_inner, t26527 = 0, i02_skew_1_1_inner, t26540 = 0, i03_skew = t11, t26542 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 539.426025

{ comp03[t8, t9, t10, t11] -> comp03[0, t26629 = 0, i00_outer, t26631 = 0, i01_outer, t26633 = 0, i00_inner, t26626 = 0, i01_inner, t26635 = 0, i02_skew_1_1 = t10 + t11, t26637 = 0, i03_skew = t11, t26639 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 537.718994

{ comp03[t8, t9, t10, t11] -> comp03[0, t26722 = 0, i00_outer, t26724 = 0, i01_outer, t26726 = 0, i02_skew_1_1_outer, t26728 = 0, i00_inner, t26730 = 0, i01_inner, t26719 = 0, i02_skew_1_1_inner, t26732 = 0, i03_skew = t11, t26734 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 563.578003

{ comp03[t8, t9, t10, t11] -> comp03[0, t26836 = 0, i00_outer, t26838 = 0, i01_outer, t26840 = 0, i02_skew_1_1_outer, t26842 = 0, i00_inner, t26844 = 0, i01_inner, t26833 = 0, i02_skew_1_1_inner, t26846 = 0, i03_skew = t11, t26848 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 559.153992

{ comp03[t8, t9, t10, t11] -> comp03[0, t26950 = 0, i00_outer, t26952 = 0, i01_outer, t26954 = 0, i02_skew_1_1_outer, t26956 = 0, i00_inner, t26958 = 0, i01_inner, t26947 = 0, i02_skew_1_1_inner, t26960 = 0, i03_skew = t11, t26962 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 327.470001

{ comp03[t8, t9, t10, t11] -> comp03[0, t27049 = 0, i00_outer, t27051 = 0, i01_outer, t27053 = 0, i00_inner, t27046 = 0, i01_inner, t27055 = 0, i02_skew_1_1 = t10 + t11, t27057 = 0, i03_skew = t11, t27059 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 330.705994

{ comp03[t8, t9, t10, t11] -> comp03[0, t27142 = 0, i00_outer, t27144 = 0, i01_outer, t27146 = 0, i02_skew_1_1_outer, t27148 = 0, i00_inner, t27150 = 0, i01_inner, t27139 = 0, i02_skew_1_1_inner, t27152 = 0, i03_skew = t11, t27154 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 347.285004

{ comp03[t8, t9, t10, t11] -> comp03[0, t27256 = 0, i00_outer, t27258 = 0, i01_outer, t27260 = 0, i02_skew_1_1_outer, t27262 = 0, i00_inner, t27264 = 0, i01_inner, t27253 = 0, i02_skew_1_1_inner, t27266 = 0, i03_skew = t11, t27268 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 336.221008

{ comp03[t8, t9, t10, t11] -> comp03[0, t27370 = 0, i00_outer, t27372 = 0, i01_outer, t27374 = 0, i02_skew_1_1_outer, t27376 = 0, i00_inner, t27378 = 0, i01_inner, t27367 = 0, i02_skew_1_1_inner, t27380 = 0, i03_skew = t11, t27382 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 362.846008

{ comp03[t8, t9, t10, t11] -> comp03[0, t27469 = 0, i00_outer, t27471 = 0, i01_outer, t27473 = 0, i00_inner, t27466 = 0, i01_inner, t27475 = 0, i02_skew_1_1 = t10 + t11, t27477 = 0, i03_skew = t11, t27479 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 330.272003

{ comp03[t8, t9, t10, t11] -> comp03[0, t27562 = 0, i00_outer, t27564 = 0, i01_outer, t27566 = 0, i02_skew_1_1_outer, t27568 = 0, i00_inner, t27570 = 0, i01_inner, t27559 = 0, i02_skew_1_1_inner, t27572 = 0, i03_skew = t11, t27574 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 335.109985

{ comp03[t8, t9, t10, t11] -> comp03[0, t27676 = 0, i00_outer, t27678 = 0, i01_outer, t27680 = 0, i02_skew_1_1_outer, t27682 = 0, i00_inner, t27684 = 0, i01_inner, t27673 = 0, i02_skew_1_1_inner, t27686 = 0, i03_skew = t11, t27688 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 470.713013

{ comp03[t8, t9, t10, t11] -> comp03[0, t27790 = 0, i00_outer, t27792 = 0, i01_outer, t27794 = 0, i02_skew_1_1_outer, t27796 = 0, i00_inner, t27798 = 0, i01_inner, t27787 = 0, i02_skew_1_1_inner, t27800 = 0, i03_skew = t11, t27802 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 541.494995

{ comp03[t8, t9, t10, t11] -> comp03[0, t27889 = 0, i00_outer, t27891 = 0, i01_outer, t27893 = 0, i00_inner, t27886 = 0, i01_inner, t27895 = 0, i02_skew_1_1 = t10 + t11, t27897 = 0, i03_skew = t11, t27899 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 543.932007

{ comp03[t8, t9, t10, t11] -> comp03[0, t27982 = 0, i00_outer, t27984 = 0, i01_outer, t27986 = 0, i02_skew_1_1_outer, t27988 = 0, i00_inner, t27990 = 0, i01_inner, t27979 = 0, i02_skew_1_1_inner, t27992 = 0, i03_skew = t11, t27994 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 559.091980

{ comp03[t8, t9, t10, t11] -> comp03[0, t28096 = 0, i00_outer, t28098 = 0, i01_outer, t28100 = 0, i02_skew_1_1_outer, t28102 = 0, i00_inner, t28104 = 0, i01_inner, t28093 = 0, i02_skew_1_1_inner, t28106 = 0, i03_skew = t11, t28108 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 568.557007

{ comp03[t8, t9, t10, t11] -> comp03[0, t28210 = 0, i00_outer, t28212 = 0, i01_outer, t28214 = 0, i02_skew_1_1_outer, t28216 = 0, i00_inner, t28218 = 0, i01_inner, t28207 = 0, i02_skew_1_1_inner, t28220 = 0, i03_skew = t11, t28222 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 325.949005

{ comp03[t8, t9, t10, t11] -> comp03[0, t28309 = 0, i00_outer, t28311 = 0, i01_outer, t28313 = 0, i00_inner, t28306 = 0, i01_inner, t28315 = 0, i02_skew_1_1 = t10 + t11, t28317 = 0, i03_skew = t11, t28319 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 333.306000

{ comp03[t8, t9, t10, t11] -> comp03[0, t28402 = 0, i00_outer, t28404 = 0, i01_outer, t28406 = 0, i02_skew_1_1_outer, t28408 = 0, i00_inner, t28410 = 0, i01_inner, t28399 = 0, i02_skew_1_1_inner, t28412 = 0, i03_skew = t11, t28414 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 343.046997

{ comp03[t8, t9, t10, t11] -> comp03[0, t28516 = 0, i00_outer, t28518 = 0, i01_outer, t28520 = 0, i02_skew_1_1_outer, t28522 = 0, i00_inner, t28524 = 0, i01_inner, t28513 = 0, i02_skew_1_1_inner, t28526 = 0, i03_skew = t11, t28528 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 332.472992

{ comp03[t8, t9, t10, t11] -> comp03[0, t28630 = 0, i00_outer, t28632 = 0, i01_outer, t28634 = 0, i02_skew_1_1_outer, t28636 = 0, i00_inner, t28638 = 0, i01_inner, t28627 = 0, i02_skew_1_1_inner, t28640 = 0, i03_skew = t11, t28642 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 326.880005

{ comp03[t8, t9, t10, t11] -> comp03[0, t28729 = 0, i00_outer, t28731 = 0, i01_outer, t28733 = 0, i00_inner, t28726 = 0, i01_inner, t28735 = 0, i02_skew_1_1 = t10 + t11, t28737 = 0, i03_skew = t11, t28739 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 330.345001

{ comp03[t8, t9, t10, t11] -> comp03[0, t28822 = 0, i00_outer, t28824 = 0, i01_outer, t28826 = 0, i02_skew_1_1_outer, t28828 = 0, i00_inner, t28830 = 0, i01_inner, t28819 = 0, i02_skew_1_1_inner, t28832 = 0, i03_skew = t11, t28834 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 400.315002

{ comp03[t8, t9, t10, t11] -> comp03[0, t28936 = 0, i00_outer, t28938 = 0, i01_outer, t28940 = 0, i02_skew_1_1_outer, t28942 = 0, i00_inner, t28944 = 0, i01_inner, t28933 = 0, i02_skew_1_1_inner, t28946 = 0, i03_skew = t11, t28948 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 335.488007

{ comp03[t8, t9, t10, t11] -> comp03[0, t29050 = 0, i00_outer, t29052 = 0, i01_outer, t29054 = 0, i02_skew_1_1_outer, t29056 = 0, i00_inner, t29058 = 0, i01_inner, t29047 = 0, i02_skew_1_1_inner, t29060 = 0, i03_skew = t11, t29062 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 536.161987

{ comp03[t8, t9, t10, t11] -> comp03[0, t29149 = 0, i00_outer, t29151 = 0, i01_outer, t29153 = 0, i00_inner, t29146 = 0, i01_inner, t29155 = 0, i02_skew_1_1 = t10 + t11, t29157 = 0, i03_skew = t11, t29159 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 536.080994

{ comp03[t8, t9, t10, t11] -> comp03[0, t29242 = 0, i00_outer, t29244 = 0, i01_outer, t29246 = 0, i02_skew_1_1_outer, t29248 = 0, i00_inner, t29250 = 0, i01_inner, t29239 = 0, i02_skew_1_1_inner, t29252 = 0, i03_skew = t11, t29254 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 557.260010

{ comp03[t8, t9, t10, t11] -> comp03[0, t29356 = 0, i00_outer, t29358 = 0, i01_outer, t29360 = 0, i02_skew_1_1_outer, t29362 = 0, i00_inner, t29364 = 0, i01_inner, t29353 = 0, i02_skew_1_1_inner, t29366 = 0, i03_skew = t11, t29368 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 567.531982

{ comp03[t8, t9, t10, t11] -> comp03[0, t29470 = 0, i00_outer, t29472 = 0, i01_outer, t29474 = 0, i02_skew_1_1_outer, t29476 = 0, i00_inner, t29478 = 0, i01_inner, t29467 = 0, i02_skew_1_1_inner, t29480 = 0, i03_skew = t11, t29482 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 356.157990

{ comp03[t8, t9, t10, t11] -> comp03[0, t29569 = 0, i00 = t8, t29571 = 0, i01_outer, t29573 = 0, i02_skew_1_1_outer, t29575 = 0, i01_inner, t29566 = 0, i02_skew_1_1_inner, t29577 = 0, i03_skew = t11, t29579 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 32) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 403.513000

{ comp03[t8, t9, t10, t11] -> comp03[0, t29662 = 0, i00 = t8, t29664 = 0, i01_outer, t29666 = 0, i02_skew_1_1_outer, t29668 = 0, i03_skew_outer, t29670 = 0, i01_inner, t29672 = 0, i02_skew_1_1_inner, t29659 = 0, i03_skew_inner, t29674 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 307.140015

{ comp03[t8, t9, t10, t11] -> comp03[0, t29761 = 0, i00 = t8, t29763 = 0, i01_outer, t29765 = 0, i02_skew_1_1_outer, t29767 = 0, i01_inner, t29758 = 0, i02_skew_1_1_inner, t29769 = 0, i03_skew = t11, t29771 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 32) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 352.177002

{ comp03[t8, t9, t10, t11] -> comp03[0, t29854 = 0, i00 = t8, t29856 = 0, i01_outer, t29858 = 0, i02_skew_1_1_outer, t29860 = 0, i03_skew_outer, t29862 = 0, i01_inner, t29864 = 0, i02_skew_1_1_inner, t29851 = 0, i03_skew_inner, t29866 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 32 L2 128
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 285.330994

{ comp03[t8, t9, t10, t11] -> comp03[0, t29953 = 0, i00 = t8, t29955 = 0, i01_outer, t29957 = 0, i02_skew_1_1_outer, t29959 = 0, i01_inner, t29950 = 0, i02_skew_1_1_inner, t29961 = 0, i03_skew = t11, t29963 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 32 L2 128 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 322.278015

{ comp03[t8, t9, t10, t11] -> comp03[0, t30046 = 0, i00 = t8, t30048 = 0, i01_outer, t30050 = 0, i02_skew_1_1_outer, t30052 = 0, i03_skew_outer, t30054 = 0, i01_inner, t30056 = 0, i02_skew_1_1_inner, t30043 = 0, i03_skew_inner, t30058 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 290.278992

{ comp03[t8, t9, t10, t11] -> comp03[0, t30145 = 0, i00 = t8, t30147 = 0, i01_outer, t30149 = 0, i02_skew_1_1_outer, t30151 = 0, i01_inner, t30142 = 0, i02_skew_1_1_inner, t30153 = 0, i03_skew = t11, t30155 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 64) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 321.971008

{ comp03[t8, t9, t10, t11] -> comp03[0, t30238 = 0, i00 = t8, t30240 = 0, i01_outer, t30242 = 0, i02_skew_1_1_outer, t30244 = 0, i03_skew_outer, t30246 = 0, i01_inner, t30248 = 0, i02_skew_1_1_inner, t30235 = 0, i03_skew_inner, t30250 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 301.856995

{ comp03[t8, t9, t10, t11] -> comp03[0, t30337 = 0, i00 = t8, t30339 = 0, i01_outer, t30341 = 0, i02_skew_1_1_outer, t30343 = 0, i01_inner, t30334 = 0, i02_skew_1_1_inner, t30345 = 0, i03_skew = t11, t30347 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 64) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 354.877014

{ comp03[t8, t9, t10, t11] -> comp03[0, t30430 = 0, i00 = t8, t30432 = 0, i01_outer, t30434 = 0, i02_skew_1_1_outer, t30436 = 0, i03_skew_outer, t30438 = 0, i01_inner, t30440 = 0, i02_skew_1_1_inner, t30427 = 0, i03_skew_inner, t30442 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 64 L2 128
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 300.916992

{ comp03[t8, t9, t10, t11] -> comp03[0, t30529 = 0, i00 = t8, t30531 = 0, i01_outer, t30533 = 0, i02_skew_1_1_outer, t30535 = 0, i01_inner, t30526 = 0, i02_skew_1_1_inner, t30537 = 0, i03_skew = t11, t30539 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 64 L2 128 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 328.412994

{ comp03[t8, t9, t10, t11] -> comp03[0, t30622 = 0, i00 = t8, t30624 = 0, i01_outer, t30626 = 0, i02_skew_1_1_outer, t30628 = 0, i03_skew_outer, t30630 = 0, i01_inner, t30632 = 0, i02_skew_1_1_inner, t30619 = 0, i03_skew_inner, t30634 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 515.721008

{ comp03[t8, t9, t10, t11] -> comp03[0, t30721 = 0, i00 = t8, t30723 = 0, i01_outer, t30725 = 0, i02_skew_1_1_outer, t30727 = 0, i01_inner, t30718 = 0, i02_skew_1_1_inner, t30729 = 0, i03_skew = t11, t30731 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 128) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 564.562988

{ comp03[t8, t9, t10, t11] -> comp03[0, t30814 = 0, i00 = t8, t30816 = 0, i01_outer, t30818 = 0, i02_skew_1_1_outer, t30820 = 0, i03_skew_outer, t30822 = 0, i01_inner, t30824 = 0, i02_skew_1_1_inner, t30811 = 0, i03_skew_inner, t30826 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 532.914978

{ comp03[t8, t9, t10, t11] -> comp03[0, t30913 = 0, i00 = t8, t30915 = 0, i01_outer, t30917 = 0, i02_skew_1_1_outer, t30919 = 0, i01_inner, t30910 = 0, i02_skew_1_1_inner, t30921 = 0, i03_skew = t11, t30923 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 128) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 128 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 619.934021

{ comp03[t8, t9, t10, t11] -> comp03[0, t31006 = 0, i00 = t8, t31008 = 0, i01_outer, t31010 = 0, i02_skew_1_1_outer, t31012 = 0, i03_skew_outer, t31014 = 0, i01_inner, t31016 = 0, i02_skew_1_1_inner, t31003 = 0, i03_skew_inner, t31018 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 128 L2 128
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 507.893005

{ comp03[t8, t9, t10, t11] -> comp03[0, t31105 = 0, i00 = t8, t31107 = 0, i01_outer, t31109 = 0, i02_skew_1_1_outer, t31111 = 0, i01_inner, t31102 = 0, i02_skew_1_1_inner, t31113 = 0, i03_skew = t11, t31115 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L1 128 L2 128 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 577.080994

{ comp03[t8, t9, t10, t11] -> comp03[0, t31198 = 0, i00 = t8, t31200 = 0, i01_outer, t31202 = 0, i02_skew_1_1_outer, t31204 = 0, i03_skew_outer, t31206 = 0, i01_inner, t31208 = 0, i02_skew_1_1_inner, t31195 = 0, i03_skew_inner, t31210 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:2 test : i02_skew_1_1 & i03_skew
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
            for (c11, max(((((c5 - c7)*32) + c9) + -127), 0), ((min((((c5 - c7)*32) + c9), 31) - max(((((c5 - c7)*32) + c9) + -127), 0)) + 1)) {
              buf03[((((((c5 - c7)*32) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((((c5 - c7)*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew_inner < 32 | 0
						comp03
Evaluation : 340.264008

{ comp03[t8, t9, t10, t11] -> comp03[0, t31297 = 0, i00 = t8, t31299 = 0, i01 = t9, t31301 = 0, i02_skew_1_1_outer, t31303 = 0, i03_skew_outer, t31305 = 0, i02_skew_1_1_inner, t31294 = 0, i03_skew_inner, t31307 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:2 test : i02_skew_1_1 & i03_skew
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
            for (c11, max(((((c5*64) - (c7*32)) + c9) + -127), 0), ((min((((c5*64) - (c7*32)) + c9), 31) - max(((((c5*64) - (c7*32)) + c9) + -127), 0)) + 1)) {
              buf03[((((((c5*64) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((((c5*64) - (c7*32)) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew_inner < 32 | 0
						comp03
Evaluation : 347.613007

{ comp03[t8, t9, t10, t11] -> comp03[0, t31375 = 0, i00 = t8, t31377 = 0, i01 = t9, t31379 = 0, i02_skew_1_1_outer, t31381 = 0, i03_skew_outer, t31383 = 0, i02_skew_1_1_inner, t31372 = 0, i03_skew_inner, t31385 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:2 test : i02_skew_1_1 & i03_skew
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    parallel (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
            for (c11, max(((((c5*128) - (c7*32)) + c9) + -127), 0), ((min((((c5*128) - (c7*32)) + c9), 31) - max(((((c5*128) - (c7*32)) + c9) + -127), 0)) + 1)) {
              buf03[((((((c5*128) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c9) - c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((((c5*128) - (c7*32)) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Parallelize L1
Tiling L2 128 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01 < 256 | 0 | P
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew_inner < 32 | 0
						comp03
Evaluation : 337.947998

{ comp03[t8, t9, t10, t11] -> comp03[0, t31453 = 0, i00 = t8, t31455 = 0, i01 = t9, t31457 = 0, i02_skew_1_1_outer, t31459 = 0, i03_skew_outer, t31461 = 0, i02_skew_1_1_inner, t31450 = 0, i03_skew_inner, t31463 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>

original list
381.759003+373.467987+378.294006+386.260010+332.062012+341.028015+340.197998+341.196014+539.426025+537.718994+563.578003+559.153992+327.470001+330.705994+347.285004+336.221008+362.846008+330.272003+335.109985+470.713013+541.494995+543.932007+559.091980+568.557007+325.949005+333.306000+343.046997+332.472992+326.880005+330.345001+400.315002+335.488007+536.161987+536.080994+557.260010+567.531982+356.157990+403.513000+307.140015+352.177002+285.330994+322.278015+290.278992+321.971008+301.856995+354.877014+300.916992+328.412994+515.721008+564.562988+532.914978+619.934021+507.893005+577.080994+340.264008+347.613007+337.947998+298.441010+
remaining list
285.330994+290.278992+298.441010+300.916992+ Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1022.119995

{ comp03[t8, t9, t10, t11] -> comp03[0, t31531 = 0, i00_outer, t31533 = 0, i01_outer, t31535 = 0, i00_inner, t31528 = 0, i01_inner, t31537 = 0, i02_skew_1_1 = t10 + t11, t31539 = 0, i03_skew = t11, t31541 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 32 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1011.450012

{ comp03[t8, t9, t10, t11] -> comp03[0, t31623 = 0, i00_outer, t31625 = 0, i01_outer, t31627 = 0, i02_skew_1_1_outer, t31629 = 0, i00_inner, t31631 = 0, i01_inner, t31620 = 0, i02_skew_1_1_inner, t31633 = 0, i03_skew = t11, t31635 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 32 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1037.890015

{ comp03[t8, t9, t10, t11] -> comp03[0, t31736 = 0, i00_outer, t31738 = 0, i01_outer, t31740 = 0, i02_skew_1_1_outer, t31742 = 0, i00_inner, t31744 = 0, i01_inner, t31733 = 0, i02_skew_1_1_inner, t31746 = 0, i03_skew = t11, t31748 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 32 L2 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 999.348999

{ comp03[t8, t9, t10, t11] -> comp03[0, t31849 = 0, i00_outer, t31851 = 0, i01_outer, t31853 = 0, i02_skew_1_1_outer, t31855 = 0, i00_inner, t31857 = 0, i01_inner, t31846 = 0, i02_skew_1_1_inner, t31859 = 0, i03_skew = t11, t31861 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1023.190002

{ comp03[t8, t9, t10, t11] -> comp03[0, t31947 = 0, i00_outer, t31949 = 0, i01_outer, t31951 = 0, i00_inner, t31944 = 0, i01_inner, t31953 = 0, i02_skew_1_1 = t10 + t11, t31955 = 0, i03_skew = t11, t31957 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 64 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1013.450012

{ comp03[t8, t9, t10, t11] -> comp03[0, t32039 = 0, i00_outer, t32041 = 0, i01_outer, t32043 = 0, i02_skew_1_1_outer, t32045 = 0, i00_inner, t32047 = 0, i01_inner, t32036 = 0, i02_skew_1_1_inner, t32049 = 0, i03_skew = t11, t32051 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 64 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1040.910034

{ comp03[t8, t9, t10, t11] -> comp03[0, t32152 = 0, i00_outer, t32154 = 0, i01_outer, t32156 = 0, i02_skew_1_1_outer, t32158 = 0, i00_inner, t32160 = 0, i01_inner, t32149 = 0, i02_skew_1_1_inner, t32162 = 0, i03_skew = t11, t32164 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 64 L2 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1004.450012

{ comp03[t8, t9, t10, t11] -> comp03[0, t32265 = 0, i00_outer, t32267 = 0, i01_outer, t32269 = 0, i02_skew_1_1_outer, t32271 = 0, i00_inner, t32273 = 0, i01_inner, t32262 = 0, i02_skew_1_1_inner, t32275 = 0, i03_skew = t11, t32277 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 32 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1018.750000

{ comp03[t8, t9, t10, t11] -> comp03[0, t32363 = 0, i00_outer, t32365 = 0, i01_outer, t32367 = 0, i00_inner, t32360 = 0, i01_inner, t32369 = 0, i02_skew_1_1 = t10 + t11, t32371 = 0, i03_skew = t11, t32373 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 128 L2 32
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1016.909973

{ comp03[t8, t9, t10, t11] -> comp03[0, t32455 = 0, i00_outer, t32457 = 0, i01_outer, t32459 = 0, i02_skew_1_1_outer, t32461 = 0, i00_inner, t32463 = 0, i01_inner, t32452 = 0, i02_skew_1_1_inner, t32465 = 0, i03_skew = t11, t32467 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 128 L2 64
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1043.579956

{ comp03[t8, t9, t10, t11] -> comp03[0, t32568 = 0, i00_outer, t32570 = 0, i01_outer, t32572 = 0, i02_skew_1_1_outer, t32574 = 0, i00_inner, t32576 = 0, i01_inner, t32565 = 0, i02_skew_1_1_inner, t32578 = 0, i03_skew = t11, t32580 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 32 L1 128 L2 128
0- for 0 <= i00_outer < 8 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 32 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1053.819946

{ comp03[t8, t9, t10, t11] -> comp03[0, t32681 = 0, i00_outer, t32683 = 0, i01_outer, t32685 = 0, i02_skew_1_1_outer, t32687 = 0, i00_inner, t32689 = 0, i01_inner, t32678 = 0, i02_skew_1_1_inner, t32691 = 0, i03_skew = t11, t32693 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t8 <= 32i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 31 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1020.409973

{ comp03[t8, t9, t10, t11] -> comp03[0, t32779 = 0, i00_outer, t32781 = 0, i01_outer, t32783 = 0, i00_inner, t32776 = 0, i01_inner, t32785 = 0, i02_skew_1_1 = t10 + t11, t32787 = 0, i03_skew = t11, t32789 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 32 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1015.190002

{ comp03[t8, t9, t10, t11] -> comp03[0, t32871 = 0, i00_outer, t32873 = 0, i01_outer, t32875 = 0, i02_skew_1_1_outer, t32877 = 0, i00_inner, t32879 = 0, i01_inner, t32868 = 0, i02_skew_1_1_inner, t32881 = 0, i03_skew = t11, t32883 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 32 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1039.130005

{ comp03[t8, t9, t10, t11] -> comp03[0, t32984 = 0, i00_outer, t32986 = 0, i01_outer, t32988 = 0, i02_skew_1_1_outer, t32990 = 0, i00_inner, t32992 = 0, i01_inner, t32981 = 0, i02_skew_1_1_inner, t32994 = 0, i03_skew = t11, t32996 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 32 L2 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 999.911987

{ comp03[t8, t9, t10, t11] -> comp03[0, t33097 = 0, i00_outer, t33099 = 0, i01_outer, t33101 = 0, i02_skew_1_1_outer, t33103 = 0, i00_inner, t33105 = 0, i01_inner, t33094 = 0, i02_skew_1_1_inner, t33107 = 0, i03_skew = t11, t33109 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1024.359985

{ comp03[t8, t9, t10, t11] -> comp03[0, t33195 = 0, i00_outer, t33197 = 0, i01_outer, t33199 = 0, i00_inner, t33192 = 0, i01_inner, t33201 = 0, i02_skew_1_1 = t10 + t11, t33203 = 0, i03_skew = t11, t33205 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 64 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1015.469971

{ comp03[t8, t9, t10, t11] -> comp03[0, t33287 = 0, i00_outer, t33289 = 0, i01_outer, t33291 = 0, i02_skew_1_1_outer, t33293 = 0, i00_inner, t33295 = 0, i01_inner, t33284 = 0, i02_skew_1_1_inner, t33297 = 0, i03_skew = t11, t33299 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 64 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1039.109985

{ comp03[t8, t9, t10, t11] -> comp03[0, t33400 = 0, i00_outer, t33402 = 0, i01_outer, t33404 = 0, i02_skew_1_1_outer, t33406 = 0, i00_inner, t33408 = 0, i01_inner, t33397 = 0, i02_skew_1_1_inner, t33410 = 0, i03_skew = t11, t33412 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 64 L2 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 998.926025

{ comp03[t8, t9, t10, t11] -> comp03[0, t33513 = 0, i00_outer, t33515 = 0, i01_outer, t33517 = 0, i02_skew_1_1_outer, t33519 = 0, i00_inner, t33521 = 0, i01_inner, t33510 = 0, i02_skew_1_1_inner, t33523 = 0, i03_skew = t11, t33525 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 64 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1016.929993

{ comp03[t8, t9, t10, t11] -> comp03[0, t33611 = 0, i00_outer, t33613 = 0, i01_outer, t33615 = 0, i00_inner, t33608 = 0, i01_inner, t33617 = 0, i02_skew_1_1 = t10 + t11, t33619 = 0, i03_skew = t11, t33621 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 128 L2 32
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1018.080017

{ comp03[t8, t9, t10, t11] -> comp03[0, t33703 = 0, i00_outer, t33705 = 0, i01_outer, t33707 = 0, i02_skew_1_1_outer, t33709 = 0, i00_inner, t33711 = 0, i01_inner, t33700 = 0, i02_skew_1_1_inner, t33713 = 0, i03_skew = t11, t33715 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 128 L2 64
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1044.520020

{ comp03[t8, t9, t10, t11] -> comp03[0, t33816 = 0, i00_outer, t33818 = 0, i01_outer, t33820 = 0, i02_skew_1_1_outer, t33822 = 0, i00_inner, t33824 = 0, i01_inner, t33813 = 0, i02_skew_1_1_inner, t33826 = 0, i03_skew = t11, t33828 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 64 L1 128 L2 128
0- for 0 <= i00_outer < 4 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 64 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1057.089966

{ comp03[t8, t9, t10, t11] -> comp03[0, t33929 = 0, i00_outer, t33931 = 0, i01_outer, t33933 = 0, i02_skew_1_1_outer, t33935 = 0, i00_inner, t33937 = 0, i01_inner, t33926 = 0, i02_skew_1_1_inner, t33939 = 0, i03_skew = t11, t33941 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t8 <= 64i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 63 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1019.890015

{ comp03[t8, t9, t10, t11] -> comp03[0, t34027 = 0, i00_outer, t34029 = 0, i01_outer, t34031 = 0, i00_inner, t34024 = 0, i01_inner, t34033 = 0, i02_skew_1_1 = t10 + t11, t34035 = 0, i03_skew = t11, t34037 = 0] : (t9 - i01_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 32 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1016.909973

{ comp03[t8, t9, t10, t11] -> comp03[0, t34119 = 0, i00_outer, t34121 = 0, i01_outer, t34123 = 0, i02_skew_1_1_outer, t34125 = 0, i00_inner, t34127 = 0, i01_inner, t34116 = 0, i02_skew_1_1_inner, t34129 = 0, i03_skew = t11, t34131 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 32 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1041.589966

{ comp03[t8, t9, t10, t11] -> comp03[0, t34232 = 0, i00_outer, t34234 = 0, i01_outer, t34236 = 0, i02_skew_1_1_outer, t34238 = 0, i00_inner, t34240 = 0, i01_inner, t34229 = 0, i02_skew_1_1_inner, t34242 = 0, i03_skew = t11, t34244 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 32 L2 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1050.310059

{ comp03[t8, t9, t10, t11] -> comp03[0, t34345 = 0, i00_outer, t34347 = 0, i01_outer, t34349 = 0, i02_skew_1_1_outer, t34351 = 0, i00_inner, t34353 = 0, i01_inner, t34342 = 0, i02_skew_1_1_inner, t34355 = 0, i03_skew = t11, t34357 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1027.760010

{ comp03[t8, t9, t10, t11] -> comp03[0, t34443 = 0, i00_outer, t34445 = 0, i01_outer, t34447 = 0, i00_inner, t34440 = 0, i01_inner, t34449 = 0, i02_skew_1_1 = t10 + t11, t34451 = 0, i03_skew = t11, t34453 = 0] : (t9 - i01_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 64 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1020.809998

{ comp03[t8, t9, t10, t11] -> comp03[0, t34535 = 0, i00_outer, t34537 = 0, i01_outer, t34539 = 0, i02_skew_1_1_outer, t34541 = 0, i00_inner, t34543 = 0, i01_inner, t34532 = 0, i02_skew_1_1_inner, t34545 = 0, i03_skew = t11, t34547 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 64 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1041.250000

{ comp03[t8, t9, t10, t11] -> comp03[0, t34648 = 0, i00_outer, t34650 = 0, i01_outer, t34652 = 0, i02_skew_1_1_outer, t34654 = 0, i00_inner, t34656 = 0, i01_inner, t34645 = 0, i02_skew_1_1_inner, t34658 = 0, i03_skew = t11, t34660 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 64 L2 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1053.569946

{ comp03[t8, t9, t10, t11] -> comp03[0, t34761 = 0, i00_outer, t34763 = 0, i01_outer, t34765 = 0, i02_skew_1_1_outer, t34767 = 0, i00_inner, t34769 = 0, i01_inner, t34758 = 0, i02_skew_1_1_inner, t34771 = 0, i03_skew = t11, t34773 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 255) {
            for (c11, max((c9 + -127), 0), ((min(c9, 127) - max((c9 + -127), 0)) + 1)) {
              buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[(((c9 - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64((c9 - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i00_inner < 128 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1 < 255 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1055.900024

{ comp03[t8, t9, t10, t11] -> comp03[0, t34859 = 0, i00_outer, t34861 = 0, i01_outer, t34863 = 0, i00_inner, t34856 = 0, i01_inner, t34865 = 0, i02_skew_1_1 = t10 + t11, t34867 = 0, i03_skew = t11, t34869 = 0] : (t9 - i01_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*32), 223))) {
              for (c13, max((((c5*32) + c11) + -127), 0), ((min(((c5*32) + c11), 127) - max((((c5*32) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 128 L2 32
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1054.489990

{ comp03[t8, t9, t10, t11] -> comp03[0, t34951 = 0, i00_outer, t34953 = 0, i01_outer, t34955 = 0, i02_skew_1_1_outer, t34957 = 0, i00_inner, t34959 = 0, i01_inner, t34948 = 0, i02_skew_1_1_inner, t34961 = 0, i03_skew = t11, t34963 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*64), 191))) {
              for (c13, max((((c5*64) + c11) + -127), 0), ((min(((c5*64) + c11), 127) - max((((c5*64) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*64) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*64) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 128 L2 64
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1068.369995

{ comp03[t8, t9, t10, t11] -> comp03[0, t35064 = 0, i00_outer, t35066 = 0, i01_outer, t35068 = 0, i02_skew_1_1_outer, t35070 = 0, i00_inner, t35072 = 0, i01_inner, t35061 = 0, i02_skew_1_1_inner, t35074 = 0, i03_skew = t11, t35076 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:0 test : i00 & i01
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, (255 - max((c5*128), 127))) {
              for (c13, max((((c5*128) + c11) + -127), 0), ((min(((c5*128) + c11), 127) - max((((c5*128) + c11) + -127), 0)) + 1)) {
                buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[(((((c5*128) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64((((c5*128) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L0 128 L1 128 L2 128
0- for 0 <= i00_outer < 2 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i00_inner < 128 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew < 65 | 0
							comp03
Evaluation : 1073.060059

{ comp03[t8, t9, t10, t11] -> comp03[0, t35177 = 0, i00_outer, t35179 = 0, i01_outer, t35181 = 0, i02_skew_1_1_outer, t35183 = 0, i00_inner, t35185 = 0, i01_inner, t35174 = 0, i02_skew_1_1_inner, t35187 = 0, i03_skew = t11, t35189 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and (t8 - i00_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t8 <= 128i00_outer <= t8 and -127 + t9 <= 128i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i00_inner <= 127 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 127 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 32 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1042.010010

{ comp03[t8, t9, t10, t11] -> comp03[0, t35275 = 0, i00 = t8, t35277 = 0, i01_outer, t35279 = 0, i02_skew_1_1_outer, t35281 = 0, i01_inner, t35272 = 0, i02_skew_1_1_inner, t35283 = 0, i03_skew = t11, t35285 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 32) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 32 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1150.219971

{ comp03[t8, t9, t10, t11] -> comp03[0, t35367 = 0, i00 = t8, t35369 = 0, i01_outer, t35371 = 0, i02_skew_1_1_outer, t35373 = 0, i03_skew_outer, t35375 = 0, i01_inner, t35377 = 0, i02_skew_1_1_inner, t35364 = 0, i03_skew_inner, t35379 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 32 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1065.489990

{ comp03[t8, t9, t10, t11] -> comp03[0, t35465 = 0, i00 = t8, t35467 = 0, i01_outer, t35469 = 0, i02_skew_1_1_outer, t35471 = 0, i01_inner, t35462 = 0, i02_skew_1_1_inner, t35473 = 0, i03_skew = t11, t35475 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 32) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 32 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1222.699951

{ comp03[t8, t9, t10, t11] -> comp03[0, t35557 = 0, i00 = t8, t35559 = 0, i01_outer, t35561 = 0, i02_skew_1_1_outer, t35563 = 0, i03_skew_outer, t35565 = 0, i01_inner, t35567 = 0, i02_skew_1_1_inner, t35554 = 0, i03_skew_inner, t35569 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 32 L2 128
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 32 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1010.169983

{ comp03[t8, t9, t10, t11] -> comp03[0, t35655 = 0, i00 = t8, t35657 = 0, i01_outer, t35659 = 0, i02_skew_1_1_outer, t35661 = 0, i01_inner, t35652 = 0, i02_skew_1_1_inner, t35663 = 0, i03_skew = t11, t35665 = 0] : (t9 - i01_inner) mod 32 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 32 L2 128 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 8 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 32 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1154.869995

{ comp03[t8, t9, t10, t11] -> comp03[0, t35747 = 0, i00 = t8, t35749 = 0, i01_outer, t35751 = 0, i02_skew_1_1_outer, t35753 = 0, i03_skew_outer, t35755 = 0, i01_inner, t35757 = 0, i02_skew_1_1_inner, t35744 = 0, i03_skew_inner, t35759 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 32 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -31 + t9 <= 32i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 31 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 64 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1016.250000

{ comp03[t8, t9, t10, t11] -> comp03[0, t35845 = 0, i00 = t8, t35847 = 0, i01_outer, t35849 = 0, i02_skew_1_1_outer, t35851 = 0, i01_inner, t35842 = 0, i02_skew_1_1_inner, t35853 = 0, i03_skew = t11, t35855 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 64) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 64 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1110.239990

{ comp03[t8, t9, t10, t11] -> comp03[0, t35937 = 0, i00 = t8, t35939 = 0, i01_outer, t35941 = 0, i02_skew_1_1_outer, t35943 = 0, i03_skew_outer, t35945 = 0, i01_inner, t35947 = 0, i02_skew_1_1_inner, t35934 = 0, i03_skew_inner, t35949 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 64 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1046.390015

{ comp03[t8, t9, t10, t11] -> comp03[0, t36035 = 0, i00 = t8, t36037 = 0, i01_outer, t36039 = 0, i02_skew_1_1_outer, t36041 = 0, i01_inner, t36032 = 0, i02_skew_1_1_inner, t36043 = 0, i03_skew = t11, t36045 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 64) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 64 L2 64 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 64 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1217.689941

{ comp03[t8, t9, t10, t11] -> comp03[0, t36127 = 0, i00 = t8, t36129 = 0, i01_outer, t36131 = 0, i02_skew_1_1_outer, t36133 = 0, i03_skew_outer, t36135 = 0, i01_inner, t36137 = 0, i02_skew_1_1_inner, t36124 = 0, i03_skew_inner, t36139 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 64 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 63 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, (255 - max((c5*128), 127))) {
            for (c11, max((((c5*128) + c9) + -127), 0), ((min(((c5*128) + c9), 127) - max((((c5*128) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*128) + c9) - c11) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*128) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 64 L2 128
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i01_inner < 64 | 0
				4- for 0 <= i02_skew_1_1_inner < 128 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1002.909973

{ comp03[t8, t9, t10, t11] -> comp03[0, t36225 = 0, i00 = t8, t36227 = 0, i01_outer, t36229 = 0, i02_skew_1_1_outer, t36231 = 0, i01_inner, t36222 = 0, i02_skew_1_1_inner, t36233 = 0, i03_skew = t11, t36235 = 0] : (t9 - i01_inner) mod 64 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 128 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, max(((c7*32) - (c5*128)), 0), ((min((((c7*32) - (c5*128)) + 158), 127) - max(((c7*32) - (c5*128)), 0)) + 1)) {
              for (c13, max(((((c5*128) - (c7*32)) + c11) + -127), 0), ((min((((c5*128) - (c7*32)) + c11), 31) - max(((((c5*128) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*128) - (c7*32)) + c11) - c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*128) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 64 L2 128 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 4 | 0
		2- for 0 <= i02_skew_1_1_outer < 1 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 64 | 0
					5- for 0 <= i02_skew_1_1_inner < 128 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1156.219971

{ comp03[t8, t9, t10, t11] -> comp03[0, t36317 = 0, i00 = t8, t36319 = 0, i01_outer, t36321 = 0, i02_skew_1_1_outer, t36323 = 0, i03_skew_outer, t36325 = 0, i01_inner, t36327 = 0, i02_skew_1_1_inner, t36314 = 0, i03_skew_inner, t36329 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 128 = 0 and (t9 - i01_inner) mod 64 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -63 + t9 <= 64i01_outer <= t9 and -127 + t10 + t11 <= 128i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 63 and 0 <= i02_skew_1_1_inner <= 127 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*32), 223))) {
            for (c11, max((((c5*32) + c9) + -127), 0), ((min(((c5*32) + c9), 127) - max((((c5*32) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*32) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*32) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 128 L2 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 32 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1063.349976

{ comp03[t8, t9, t10, t11] -> comp03[0, t36415 = 0, i00 = t8, t36417 = 0, i01_outer, t36419 = 0, i02_skew_1_1_outer, t36421 = 0, i01_inner, t36412 = 0, i02_skew_1_1_inner, t36423 = 0, i03_skew = t11, t36425 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, max((c5 + -4), 0), ((min(c5, 3) - max((c5 + -4), 0)) + 1)) {
          for (c9, 0, 128) {
            for (c11, 0, (min((((c7 - c5)*32) + 158), 31) + 1)) {
              for (c13, max(((((c5 - c7)*32) + c11) + -127), 0), ((min((((c5 - c7)*32) + c11), 31) - max(((((c5 - c7)*32) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5 - c7)*32) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5 - c7)*32) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 128 L2 32 L3 32
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 7 | 0
			3- for 0 <= i03_skew_outer < 2 | 0
				4- for 0 <= i01_inner < 128 | 0
					5- for 0 <= i02_skew_1_1_inner < 32 | 0
						6- for 0 <= i03_skew_inner < 32 | 0
							comp03
Evaluation : 1167.380005

{ comp03[t8, t9, t10, t11] -> comp03[0, t36507 = 0, i00 = t8, t36509 = 0, i01_outer, t36511 = 0, i02_skew_1_1_outer, t36513 = 0, i03_skew_outer, t36515 = 0, i01_inner, t36517 = 0, i02_skew_1_1_inner, t36504 = 0, i03_skew_inner, t36519 = 0] : (-t10 - t11 + i02_skew_1_1_inner) mod 32 = 0 and (t9 - i01_inner) mod 128 = 0 and (-t11 + i03_skew_inner) mod 32 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -31 + t10 + t11 <= 32i02_skew_1_1_outer <= t10 + t11 and -31 + t11 <= 32i03_skew_outer <= t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 31 and 0 <= i03_skew_inner <= 31 }






comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
 Tiling 2 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, (255 - max((c5*64), 191))) {
            for (c11, max((((c5*64) + c9) + -127), 0), ((min(((c5*64) + c9), 127) - max((((c5*64) + c9) + -127), 0)) + 1)) {
              buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[(((((c5*64) + c9) - c11) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64((((c5*64) + c9) - c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

-----------
Skewing L2 1 L3 1
Tiling L1 128 L2 64
0- for 0 <= i00 < 256 | 0
	1- for 0 <= i01_outer < 2 | 0
		2- for 0 <= i02_skew_1_1_outer < 3 | 0
			3- for 0 <= i01_inner < 128 | 0
				4- for 0 <= i02_skew_1_1_inner < 64 | 0
					5- for 0 <= i03_skew < 65 | 0
						comp03
Evaluation : 1087.410034

{ comp03[t8, t9, t10, t11] -> comp03[0, t36605 = 0, i00 = t8, t36607 = 0, i01_outer, t36609 = 0, i02_skew_1_1_outer, t36611 = 0, i01_inner, t36602 = 0, i02_skew_1_1_inner, t36613 = 0, i03_skew = t11, t36615 = 0] : (t9 - i01_inner) mod 128 = 0 and (t10 + t11 - i02_skew_1_1_inner) mod 64 = 0 and 0 <= t8 <= 255 and 0 <= t9 <= 255 and 0 <= t10 <= 127 and 0 <= t11 <= 127 and -127 + t9 <= 128i01_outer <= t9 and -63 + t10 + t11 <= 64i02_skew_1_1_outer <= t10 + t11 and 0 <= i01_inner <= 127 and 0 <= i02_skew_1_1_inner <= 63 }





comp03:1 0 0 0 0 ,0 1 0 0 0 ,0 0 1 0 0 ,0 0 0 1 0 ,
input00:1 0 0 0 0 ,0 1 0 0 0 ,0 0 0 1 0 ,
input01:0 0 1 0 0 ,0 0 0 1 0 ,

<legal>
Tiling3 loop names: i00 i01 i02_skew_1_1 i03_skew  deapth of outer is:1 test : i01 & i02_skew_1_1
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  for (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, max(((c5*2) + -4), 0), ((min(((c5*2) + 1), 3) - max(((c5*2) + -4), 0)) + 1)) {
          for (c9, 0, 128) {
            for (c11, max(((c7*32) - (c5*64)), 0), ((min((((c7*32) - (c5*64)) + 158), 63) - max(((c7*32) - (c5*64)), 0)) + 1)) {
              for (c13, max(((((c5*64) - (c7*32)) + c11) + -127), 0), ((min((((c5*64) - (c7*32)) + c11), 31) - max(((((c5*64) - (c7*32)) + c11) + -127), 0)) + 1)) {
                buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c5*64) - (c7*32)) + c11) - c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((((c5*64) - (c7*32)) + c11) - c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
